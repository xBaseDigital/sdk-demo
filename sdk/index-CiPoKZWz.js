import { p as Ls, o as $r, q as Zt, t as kl, u as Cl, v as Il, l as xl } from "./index-BOgFtvav.js";
import { r as Qe } from "./inherits_browser-BPb0V7-q.js";
import { p as Al, h as Tl } from "./hooks.module-C3CSZ0PZ.js";
import { r as hn } from "./events-BCEOhv4q.js";
var In = {}, tr = {}, rr = {}, no;
function Ll() {
  if (no) return rr;
  no = 1, Object.defineProperty(rr, "__esModule", { value: !0 }), rr.walletLogo = void 0;
  const e = (r, i) => {
    let t;
    switch (r) {
      case "standard":
        return t = i, `data:image/svg+xml,%3Csvg width='${i}' height='${t}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
      case "circle":
        return t = i, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${i}' height='${t}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
      case "text":
        return t = (0.1 * i).toFixed(2), `data:image/svg+xml,%3Csvg width='${i}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
      case "textWithLogo":
        return t = (0.25 * i).toFixed(2), `data:image/svg+xml,%3Csvg width='${i}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
      case "textLight":
        return t = (0.1 * i).toFixed(2), `data:image/svg+xml,%3Csvg width='${i}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
      case "textWithLogoLight":
        return t = (0.25 * i).toFixed(2), `data:image/svg+xml,%3Csvg width='${i}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
      default:
        return t = i, `data:image/svg+xml,%3Csvg width='${i}' height='${t}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    }
  };
  return rr.walletLogo = e, rr;
}
var nr = {}, io;
function Bl() {
  return io || (io = 1, Object.defineProperty(nr, "__esModule", { value: !0 }), nr.LINK_API_URL = void 0, nr.LINK_API_URL = "https://www.walletlink.org"), nr;
}
var ie = {}, ln = { exports: {} }, Nl = ln.exports, so;
function dn() {
  return so || (so = 1, function(e) {
    (function(r, i) {
      function t(F, l) {
        if (!F) throw new Error(l || "Assertion failed");
      }
      function p(F, l) {
        F.super_ = l;
        var E = function() {
        };
        E.prototype = l.prototype, F.prototype = new E(), F.prototype.constructor = F;
      }
      function n(F, l, E) {
        if (n.isBN(F))
          return F;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, F !== null && ((l === "le" || l === "be") && (E = l, l = 10), this._init(F || 0, l || 10, E || "be"));
      }
      typeof r == "object" ? r.exports = n : i.BN = n, n.BN = n, n.wordSize = 26;
      var u;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? u = window.Buffer : u = Ls.Buffer;
      } catch {
      }
      n.isBN = function(l) {
        return l instanceof n ? !0 : l !== null && typeof l == "object" && l.constructor.wordSize === n.wordSize && Array.isArray(l.words);
      }, n.max = function(l, E) {
        return l.cmp(E) > 0 ? l : E;
      }, n.min = function(l, E) {
        return l.cmp(E) < 0 ? l : E;
      }, n.prototype._init = function(l, E, M) {
        if (typeof l == "number")
          return this._initNumber(l, E, M);
        if (typeof l == "object")
          return this._initArray(l, E, M);
        E === "hex" && (E = 16), t(E === (E | 0) && E >= 2 && E <= 36), l = l.toString().replace(/\s+/g, "");
        var k = 0;
        l[0] === "-" && (k++, this.negative = 1), k < l.length && (E === 16 ? this._parseHex(l, k, M) : (this._parseBase(l, E, k), M === "le" && this._initArray(this.toArray(), E, M)));
      }, n.prototype._initNumber = function(l, E, M) {
        l < 0 && (this.negative = 1, l = -l), l < 67108864 ? (this.words = [l & 67108863], this.length = 1) : l < 4503599627370496 ? (this.words = [
          l & 67108863,
          l / 67108864 & 67108863
        ], this.length = 2) : (t(l < 9007199254740992), this.words = [
          l & 67108863,
          l / 67108864 & 67108863,
          1
        ], this.length = 3), M === "le" && this._initArray(this.toArray(), E, M);
      }, n.prototype._initArray = function(l, E, M) {
        if (t(typeof l.length == "number"), l.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(l.length / 3), this.words = new Array(this.length);
        for (var k = 0; k < this.length; k++)
          this.words[k] = 0;
        var x, B, j = 0;
        if (M === "be")
          for (k = l.length - 1, x = 0; k >= 0; k -= 3)
            B = l[k] | l[k - 1] << 8 | l[k - 2] << 16, this.words[x] |= B << j & 67108863, this.words[x + 1] = B >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, x++);
        else if (M === "le")
          for (k = 0, x = 0; k < l.length; k += 3)
            B = l[k] | l[k + 1] << 8 | l[k + 2] << 16, this.words[x] |= B << j & 67108863, this.words[x + 1] = B >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, x++);
        return this._strip();
      };
      function o(F, l) {
        var E = F.charCodeAt(l);
        if (E >= 48 && E <= 57)
          return E - 48;
        if (E >= 65 && E <= 70)
          return E - 55;
        if (E >= 97 && E <= 102)
          return E - 87;
        t(!1, "Invalid character in " + F);
      }
      function d(F, l, E) {
        var M = o(F, E);
        return E - 1 >= l && (M |= o(F, E - 1) << 4), M;
      }
      n.prototype._parseHex = function(l, E, M) {
        this.length = Math.ceil((l.length - E) / 6), this.words = new Array(this.length);
        for (var k = 0; k < this.length; k++)
          this.words[k] = 0;
        var x = 0, B = 0, j;
        if (M === "be")
          for (k = l.length - 1; k >= E; k -= 2)
            j = d(l, E, k) << x, this.words[B] |= j & 67108863, x >= 18 ? (x -= 18, B += 1, this.words[B] |= j >>> 26) : x += 8;
        else {
          var A = l.length - E;
          for (k = A % 2 === 0 ? E + 1 : E; k < l.length; k += 2)
            j = d(l, E, k) << x, this.words[B] |= j & 67108863, x >= 18 ? (x -= 18, B += 1, this.words[B] |= j >>> 26) : x += 8;
        }
        this._strip();
      };
      function m(F, l, E, M) {
        for (var k = 0, x = 0, B = Math.min(F.length, E), j = l; j < B; j++) {
          var A = F.charCodeAt(j) - 48;
          k *= M, A >= 49 ? x = A - 49 + 10 : A >= 17 ? x = A - 17 + 10 : x = A, t(A >= 0 && x < M, "Invalid character"), k += x;
        }
        return k;
      }
      n.prototype._parseBase = function(l, E, M) {
        this.words = [0], this.length = 1;
        for (var k = 0, x = 1; x <= 67108863; x *= E)
          k++;
        k--, x = x / E | 0;
        for (var B = l.length - M, j = B % k, A = Math.min(B, B - j) + M, y = 0, N = M; N < A; N += k)
          y = m(l, N, N + k, E), this.imuln(x), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
        if (j !== 0) {
          var te = 1;
          for (y = m(l, N, l.length, E), N = 0; N < j; N++)
            te *= E;
          this.imuln(te), this.words[0] + y < 67108864 ? this.words[0] += y : this._iaddn(y);
        }
        this._strip();
      }, n.prototype.copy = function(l) {
        l.words = new Array(this.length);
        for (var E = 0; E < this.length; E++)
          l.words[E] = this.words[E];
        l.length = this.length, l.negative = this.negative, l.red = this.red;
      };
      function g(F, l) {
        F.words = l.words, F.length = l.length, F.negative = l.negative, F.red = l.red;
      }
      if (n.prototype._move = function(l) {
        g(l, this);
      }, n.prototype.clone = function() {
        var l = new n(null);
        return this.copy(l), l;
      }, n.prototype._expand = function(l) {
        for (; this.length < l; )
          this.words[this.length++] = 0;
        return this;
      }, n.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, n.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          n.prototype[Symbol.for("nodejs.util.inspect.custom")] = c;
        } catch {
          n.prototype.inspect = c;
        }
      else
        n.prototype.inspect = c;
      function c() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var h = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], s = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], f = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      n.prototype.toString = function(l, E) {
        l = l || 10, E = E | 0 || 1;
        var M;
        if (l === 16 || l === "hex") {
          M = "";
          for (var k = 0, x = 0, B = 0; B < this.length; B++) {
            var j = this.words[B], A = ((j << k | x) & 16777215).toString(16);
            x = j >>> 24 - k & 16777215, k += 2, k >= 26 && (k -= 26, B--), x !== 0 || B !== this.length - 1 ? M = h[6 - A.length] + A + M : M = A + M;
          }
          for (x !== 0 && (M = x.toString(16) + M); M.length % E !== 0; )
            M = "0" + M;
          return this.negative !== 0 && (M = "-" + M), M;
        }
        if (l === (l | 0) && l >= 2 && l <= 36) {
          var y = s[l], N = f[l];
          M = "";
          var te = this.clone();
          for (te.negative = 0; !te.isZero(); ) {
            var K = te.modrn(N).toString(l);
            te = te.idivn(N), te.isZero() ? M = K + M : M = h[y - K.length] + K + M;
          }
          for (this.isZero() && (M = "0" + M); M.length % E !== 0; )
            M = "0" + M;
          return this.negative !== 0 && (M = "-" + M), M;
        }
        t(!1, "Base should be between 2 and 36");
      }, n.prototype.toNumber = function() {
        var l = this.words[0];
        return this.length === 2 ? l += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? l += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -l : l;
      }, n.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, u && (n.prototype.toBuffer = function(l, E) {
        return this.toArrayLike(u, l, E);
      }), n.prototype.toArray = function(l, E) {
        return this.toArrayLike(Array, l, E);
      };
      var b = function(l, E) {
        return l.allocUnsafe ? l.allocUnsafe(E) : new l(E);
      };
      n.prototype.toArrayLike = function(l, E, M) {
        this._strip();
        var k = this.byteLength(), x = M || Math.max(1, k);
        t(k <= x, "byte array longer than desired length"), t(x > 0, "Requested array length <= 0");
        var B = b(l, x), j = E === "le" ? "LE" : "BE";
        return this["_toArrayLike" + j](B, k), B;
      }, n.prototype._toArrayLikeLE = function(l, E) {
        for (var M = 0, k = 0, x = 0, B = 0; x < this.length; x++) {
          var j = this.words[x] << B | k;
          l[M++] = j & 255, M < l.length && (l[M++] = j >> 8 & 255), M < l.length && (l[M++] = j >> 16 & 255), B === 6 ? (M < l.length && (l[M++] = j >> 24 & 255), k = 0, B = 0) : (k = j >>> 24, B += 2);
        }
        if (M < l.length)
          for (l[M++] = k; M < l.length; )
            l[M++] = 0;
      }, n.prototype._toArrayLikeBE = function(l, E) {
        for (var M = l.length - 1, k = 0, x = 0, B = 0; x < this.length; x++) {
          var j = this.words[x] << B | k;
          l[M--] = j & 255, M >= 0 && (l[M--] = j >> 8 & 255), M >= 0 && (l[M--] = j >> 16 & 255), B === 6 ? (M >= 0 && (l[M--] = j >> 24 & 255), k = 0, B = 0) : (k = j >>> 24, B += 2);
        }
        if (M >= 0)
          for (l[M--] = k; M >= 0; )
            l[M--] = 0;
      }, Math.clz32 ? n.prototype._countBits = function(l) {
        return 32 - Math.clz32(l);
      } : n.prototype._countBits = function(l) {
        var E = l, M = 0;
        return E >= 4096 && (M += 13, E >>>= 13), E >= 64 && (M += 7, E >>>= 7), E >= 8 && (M += 4, E >>>= 4), E >= 2 && (M += 2, E >>>= 2), M + E;
      }, n.prototype._zeroBits = function(l) {
        if (l === 0) return 26;
        var E = l, M = 0;
        return E & 8191 || (M += 13, E >>>= 13), E & 127 || (M += 7, E >>>= 7), E & 15 || (M += 4, E >>>= 4), E & 3 || (M += 2, E >>>= 2), E & 1 || M++, M;
      }, n.prototype.bitLength = function() {
        var l = this.words[this.length - 1], E = this._countBits(l);
        return (this.length - 1) * 26 + E;
      };
      function v(F) {
        for (var l = new Array(F.bitLength()), E = 0; E < l.length; E++) {
          var M = E / 26 | 0, k = E % 26;
          l[E] = F.words[M] >>> k & 1;
        }
        return l;
      }
      n.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var l = 0, E = 0; E < this.length; E++) {
          var M = this._zeroBits(this.words[E]);
          if (l += M, M !== 26) break;
        }
        return l;
      }, n.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, n.prototype.toTwos = function(l) {
        return this.negative !== 0 ? this.abs().inotn(l).iaddn(1) : this.clone();
      }, n.prototype.fromTwos = function(l) {
        return this.testn(l - 1) ? this.notn(l).iaddn(1).ineg() : this.clone();
      }, n.prototype.isNeg = function() {
        return this.negative !== 0;
      }, n.prototype.neg = function() {
        return this.clone().ineg();
      }, n.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, n.prototype.iuor = function(l) {
        for (; this.length < l.length; )
          this.words[this.length++] = 0;
        for (var E = 0; E < l.length; E++)
          this.words[E] = this.words[E] | l.words[E];
        return this._strip();
      }, n.prototype.ior = function(l) {
        return t((this.negative | l.negative) === 0), this.iuor(l);
      }, n.prototype.or = function(l) {
        return this.length > l.length ? this.clone().ior(l) : l.clone().ior(this);
      }, n.prototype.uor = function(l) {
        return this.length > l.length ? this.clone().iuor(l) : l.clone().iuor(this);
      }, n.prototype.iuand = function(l) {
        var E;
        this.length > l.length ? E = l : E = this;
        for (var M = 0; M < E.length; M++)
          this.words[M] = this.words[M] & l.words[M];
        return this.length = E.length, this._strip();
      }, n.prototype.iand = function(l) {
        return t((this.negative | l.negative) === 0), this.iuand(l);
      }, n.prototype.and = function(l) {
        return this.length > l.length ? this.clone().iand(l) : l.clone().iand(this);
      }, n.prototype.uand = function(l) {
        return this.length > l.length ? this.clone().iuand(l) : l.clone().iuand(this);
      }, n.prototype.iuxor = function(l) {
        var E, M;
        this.length > l.length ? (E = this, M = l) : (E = l, M = this);
        for (var k = 0; k < M.length; k++)
          this.words[k] = E.words[k] ^ M.words[k];
        if (this !== E)
          for (; k < E.length; k++)
            this.words[k] = E.words[k];
        return this.length = E.length, this._strip();
      }, n.prototype.ixor = function(l) {
        return t((this.negative | l.negative) === 0), this.iuxor(l);
      }, n.prototype.xor = function(l) {
        return this.length > l.length ? this.clone().ixor(l) : l.clone().ixor(this);
      }, n.prototype.uxor = function(l) {
        return this.length > l.length ? this.clone().iuxor(l) : l.clone().iuxor(this);
      }, n.prototype.inotn = function(l) {
        t(typeof l == "number" && l >= 0);
        var E = Math.ceil(l / 26) | 0, M = l % 26;
        this._expand(E), M > 0 && E--;
        for (var k = 0; k < E; k++)
          this.words[k] = ~this.words[k] & 67108863;
        return M > 0 && (this.words[k] = ~this.words[k] & 67108863 >> 26 - M), this._strip();
      }, n.prototype.notn = function(l) {
        return this.clone().inotn(l);
      }, n.prototype.setn = function(l, E) {
        t(typeof l == "number" && l >= 0);
        var M = l / 26 | 0, k = l % 26;
        return this._expand(M + 1), E ? this.words[M] = this.words[M] | 1 << k : this.words[M] = this.words[M] & ~(1 << k), this._strip();
      }, n.prototype.iadd = function(l) {
        var E;
        if (this.negative !== 0 && l.negative === 0)
          return this.negative = 0, E = this.isub(l), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && l.negative !== 0)
          return l.negative = 0, E = this.isub(l), l.negative = 1, E._normSign();
        var M, k;
        this.length > l.length ? (M = this, k = l) : (M = l, k = this);
        for (var x = 0, B = 0; B < k.length; B++)
          E = (M.words[B] | 0) + (k.words[B] | 0) + x, this.words[B] = E & 67108863, x = E >>> 26;
        for (; x !== 0 && B < M.length; B++)
          E = (M.words[B] | 0) + x, this.words[B] = E & 67108863, x = E >>> 26;
        if (this.length = M.length, x !== 0)
          this.words[this.length] = x, this.length++;
        else if (M !== this)
          for (; B < M.length; B++)
            this.words[B] = M.words[B];
        return this;
      }, n.prototype.add = function(l) {
        var E;
        return l.negative !== 0 && this.negative === 0 ? (l.negative = 0, E = this.sub(l), l.negative ^= 1, E) : l.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = l.sub(this), this.negative = 1, E) : this.length > l.length ? this.clone().iadd(l) : l.clone().iadd(this);
      }, n.prototype.isub = function(l) {
        if (l.negative !== 0) {
          l.negative = 0;
          var E = this.iadd(l);
          return l.negative = 1, E._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(l), this.negative = 1, this._normSign();
        var M = this.cmp(l);
        if (M === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var k, x;
        M > 0 ? (k = this, x = l) : (k = l, x = this);
        for (var B = 0, j = 0; j < x.length; j++)
          E = (k.words[j] | 0) - (x.words[j] | 0) + B, B = E >> 26, this.words[j] = E & 67108863;
        for (; B !== 0 && j < k.length; j++)
          E = (k.words[j] | 0) + B, B = E >> 26, this.words[j] = E & 67108863;
        if (B === 0 && j < k.length && k !== this)
          for (; j < k.length; j++)
            this.words[j] = k.words[j];
        return this.length = Math.max(this.length, j), k !== this && (this.negative = 1), this._strip();
      }, n.prototype.sub = function(l) {
        return this.clone().isub(l);
      };
      function a(F, l, E) {
        E.negative = l.negative ^ F.negative;
        var M = F.length + l.length | 0;
        E.length = M, M = M - 1 | 0;
        var k = F.words[0] | 0, x = l.words[0] | 0, B = k * x, j = B & 67108863, A = B / 67108864 | 0;
        E.words[0] = j;
        for (var y = 1; y < M; y++) {
          for (var N = A >>> 26, te = A & 67108863, K = Math.min(y, l.length - 1), $ = Math.max(0, y - F.length + 1); $ <= K; $++) {
            var W = y - $ | 0;
            k = F.words[W] | 0, x = l.words[$] | 0, B = k * x + te, N += B / 67108864 | 0, te = B & 67108863;
          }
          E.words[y] = te | 0, A = N | 0;
        }
        return A !== 0 ? E.words[y] = A | 0 : E.length--, E._strip();
      }
      var R = function(l, E, M) {
        var k = l.words, x = E.words, B = M.words, j = 0, A, y, N, te = k[0] | 0, K = te & 8191, $ = te >>> 13, W = k[1] | 0, J = W & 8191, X = W >>> 13, oe = k[2] | 0, P = oe & 8191, O = oe >>> 13, Z = k[3] | 0, Q = Z & 8191, ae = Z >>> 13, le = k[4] | 0, ne = le & 8191, fe = le >>> 13, He = k[5] | 0, me = He & 8191, he = He >>> 13, ve = k[6] | 0, pe = ve & 8191, we = ve >>> 13, je = k[7] | 0, ye = je & 8191, C = je >>> 13, w = k[8] | 0, _ = w & 8191, L = w >>> 13, U = k[9] | 0, V = U & 8191, z = U >>> 13, de = x[0] | 0, ce = de & 8191, ue = de >>> 13, be = x[1] | 0, se = be & 8191, _e = be >>> 13, At = x[2] | 0, Ee = At & 8191, Re = At >>> 13, Tt = x[3] | 0, Se = Tt & 8191, Me = Tt >>> 13, Lt = x[4] | 0, ke = Lt & 8191, Ce = Lt >>> 13, Bt = x[5] | 0, Ie = Bt & 8191, xe = Bt >>> 13, Nt = x[6] | 0, Ae = Nt & 8191, Te = Nt >>> 13, Pt = x[7] | 0, Le = Pt & 8191, Be = Pt >>> 13, Ot = x[8] | 0, Ne = Ot & 8191, Pe = Ot >>> 13, Ft = x[9] | 0, Oe = Ft & 8191, Fe = Ft >>> 13;
        M.negative = l.negative ^ E.negative, M.length = 19, A = Math.imul(K, ce), y = Math.imul(K, ue), y = y + Math.imul($, ce) | 0, N = Math.imul($, ue);
        var at = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, A = Math.imul(J, ce), y = Math.imul(J, ue), y = y + Math.imul(X, ce) | 0, N = Math.imul(X, ue), A = A + Math.imul(K, se) | 0, y = y + Math.imul(K, _e) | 0, y = y + Math.imul($, se) | 0, N = N + Math.imul($, _e) | 0;
        var ut = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, A = Math.imul(P, ce), y = Math.imul(P, ue), y = y + Math.imul(O, ce) | 0, N = Math.imul(O, ue), A = A + Math.imul(J, se) | 0, y = y + Math.imul(J, _e) | 0, y = y + Math.imul(X, se) | 0, N = N + Math.imul(X, _e) | 0, A = A + Math.imul(K, Ee) | 0, y = y + Math.imul(K, Re) | 0, y = y + Math.imul($, Ee) | 0, N = N + Math.imul($, Re) | 0;
        var ct = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, A = Math.imul(Q, ce), y = Math.imul(Q, ue), y = y + Math.imul(ae, ce) | 0, N = Math.imul(ae, ue), A = A + Math.imul(P, se) | 0, y = y + Math.imul(P, _e) | 0, y = y + Math.imul(O, se) | 0, N = N + Math.imul(O, _e) | 0, A = A + Math.imul(J, Ee) | 0, y = y + Math.imul(J, Re) | 0, y = y + Math.imul(X, Ee) | 0, N = N + Math.imul(X, Re) | 0, A = A + Math.imul(K, Se) | 0, y = y + Math.imul(K, Me) | 0, y = y + Math.imul($, Se) | 0, N = N + Math.imul($, Me) | 0;
        var lt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, A = Math.imul(ne, ce), y = Math.imul(ne, ue), y = y + Math.imul(fe, ce) | 0, N = Math.imul(fe, ue), A = A + Math.imul(Q, se) | 0, y = y + Math.imul(Q, _e) | 0, y = y + Math.imul(ae, se) | 0, N = N + Math.imul(ae, _e) | 0, A = A + Math.imul(P, Ee) | 0, y = y + Math.imul(P, Re) | 0, y = y + Math.imul(O, Ee) | 0, N = N + Math.imul(O, Re) | 0, A = A + Math.imul(J, Se) | 0, y = y + Math.imul(J, Me) | 0, y = y + Math.imul(X, Se) | 0, N = N + Math.imul(X, Me) | 0, A = A + Math.imul(K, ke) | 0, y = y + Math.imul(K, Ce) | 0, y = y + Math.imul($, ke) | 0, N = N + Math.imul($, Ce) | 0;
        var ht = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, A = Math.imul(me, ce), y = Math.imul(me, ue), y = y + Math.imul(he, ce) | 0, N = Math.imul(he, ue), A = A + Math.imul(ne, se) | 0, y = y + Math.imul(ne, _e) | 0, y = y + Math.imul(fe, se) | 0, N = N + Math.imul(fe, _e) | 0, A = A + Math.imul(Q, Ee) | 0, y = y + Math.imul(Q, Re) | 0, y = y + Math.imul(ae, Ee) | 0, N = N + Math.imul(ae, Re) | 0, A = A + Math.imul(P, Se) | 0, y = y + Math.imul(P, Me) | 0, y = y + Math.imul(O, Se) | 0, N = N + Math.imul(O, Me) | 0, A = A + Math.imul(J, ke) | 0, y = y + Math.imul(J, Ce) | 0, y = y + Math.imul(X, ke) | 0, N = N + Math.imul(X, Ce) | 0, A = A + Math.imul(K, Ie) | 0, y = y + Math.imul(K, xe) | 0, y = y + Math.imul($, Ie) | 0, N = N + Math.imul($, xe) | 0;
        var dt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, A = Math.imul(pe, ce), y = Math.imul(pe, ue), y = y + Math.imul(we, ce) | 0, N = Math.imul(we, ue), A = A + Math.imul(me, se) | 0, y = y + Math.imul(me, _e) | 0, y = y + Math.imul(he, se) | 0, N = N + Math.imul(he, _e) | 0, A = A + Math.imul(ne, Ee) | 0, y = y + Math.imul(ne, Re) | 0, y = y + Math.imul(fe, Ee) | 0, N = N + Math.imul(fe, Re) | 0, A = A + Math.imul(Q, Se) | 0, y = y + Math.imul(Q, Me) | 0, y = y + Math.imul(ae, Se) | 0, N = N + Math.imul(ae, Me) | 0, A = A + Math.imul(P, ke) | 0, y = y + Math.imul(P, Ce) | 0, y = y + Math.imul(O, ke) | 0, N = N + Math.imul(O, Ce) | 0, A = A + Math.imul(J, Ie) | 0, y = y + Math.imul(J, xe) | 0, y = y + Math.imul(X, Ie) | 0, N = N + Math.imul(X, xe) | 0, A = A + Math.imul(K, Ae) | 0, y = y + Math.imul(K, Te) | 0, y = y + Math.imul($, Ae) | 0, N = N + Math.imul($, Te) | 0;
        var ft = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, A = Math.imul(ye, ce), y = Math.imul(ye, ue), y = y + Math.imul(C, ce) | 0, N = Math.imul(C, ue), A = A + Math.imul(pe, se) | 0, y = y + Math.imul(pe, _e) | 0, y = y + Math.imul(we, se) | 0, N = N + Math.imul(we, _e) | 0, A = A + Math.imul(me, Ee) | 0, y = y + Math.imul(me, Re) | 0, y = y + Math.imul(he, Ee) | 0, N = N + Math.imul(he, Re) | 0, A = A + Math.imul(ne, Se) | 0, y = y + Math.imul(ne, Me) | 0, y = y + Math.imul(fe, Se) | 0, N = N + Math.imul(fe, Me) | 0, A = A + Math.imul(Q, ke) | 0, y = y + Math.imul(Q, Ce) | 0, y = y + Math.imul(ae, ke) | 0, N = N + Math.imul(ae, Ce) | 0, A = A + Math.imul(P, Ie) | 0, y = y + Math.imul(P, xe) | 0, y = y + Math.imul(O, Ie) | 0, N = N + Math.imul(O, xe) | 0, A = A + Math.imul(J, Ae) | 0, y = y + Math.imul(J, Te) | 0, y = y + Math.imul(X, Ae) | 0, N = N + Math.imul(X, Te) | 0, A = A + Math.imul(K, Le) | 0, y = y + Math.imul(K, Be) | 0, y = y + Math.imul($, Le) | 0, N = N + Math.imul($, Be) | 0;
        var pt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, A = Math.imul(_, ce), y = Math.imul(_, ue), y = y + Math.imul(L, ce) | 0, N = Math.imul(L, ue), A = A + Math.imul(ye, se) | 0, y = y + Math.imul(ye, _e) | 0, y = y + Math.imul(C, se) | 0, N = N + Math.imul(C, _e) | 0, A = A + Math.imul(pe, Ee) | 0, y = y + Math.imul(pe, Re) | 0, y = y + Math.imul(we, Ee) | 0, N = N + Math.imul(we, Re) | 0, A = A + Math.imul(me, Se) | 0, y = y + Math.imul(me, Me) | 0, y = y + Math.imul(he, Se) | 0, N = N + Math.imul(he, Me) | 0, A = A + Math.imul(ne, ke) | 0, y = y + Math.imul(ne, Ce) | 0, y = y + Math.imul(fe, ke) | 0, N = N + Math.imul(fe, Ce) | 0, A = A + Math.imul(Q, Ie) | 0, y = y + Math.imul(Q, xe) | 0, y = y + Math.imul(ae, Ie) | 0, N = N + Math.imul(ae, xe) | 0, A = A + Math.imul(P, Ae) | 0, y = y + Math.imul(P, Te) | 0, y = y + Math.imul(O, Ae) | 0, N = N + Math.imul(O, Te) | 0, A = A + Math.imul(J, Le) | 0, y = y + Math.imul(J, Be) | 0, y = y + Math.imul(X, Le) | 0, N = N + Math.imul(X, Be) | 0, A = A + Math.imul(K, Ne) | 0, y = y + Math.imul(K, Pe) | 0, y = y + Math.imul($, Ne) | 0, N = N + Math.imul($, Pe) | 0;
        var gt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, A = Math.imul(V, ce), y = Math.imul(V, ue), y = y + Math.imul(z, ce) | 0, N = Math.imul(z, ue), A = A + Math.imul(_, se) | 0, y = y + Math.imul(_, _e) | 0, y = y + Math.imul(L, se) | 0, N = N + Math.imul(L, _e) | 0, A = A + Math.imul(ye, Ee) | 0, y = y + Math.imul(ye, Re) | 0, y = y + Math.imul(C, Ee) | 0, N = N + Math.imul(C, Re) | 0, A = A + Math.imul(pe, Se) | 0, y = y + Math.imul(pe, Me) | 0, y = y + Math.imul(we, Se) | 0, N = N + Math.imul(we, Me) | 0, A = A + Math.imul(me, ke) | 0, y = y + Math.imul(me, Ce) | 0, y = y + Math.imul(he, ke) | 0, N = N + Math.imul(he, Ce) | 0, A = A + Math.imul(ne, Ie) | 0, y = y + Math.imul(ne, xe) | 0, y = y + Math.imul(fe, Ie) | 0, N = N + Math.imul(fe, xe) | 0, A = A + Math.imul(Q, Ae) | 0, y = y + Math.imul(Q, Te) | 0, y = y + Math.imul(ae, Ae) | 0, N = N + Math.imul(ae, Te) | 0, A = A + Math.imul(P, Le) | 0, y = y + Math.imul(P, Be) | 0, y = y + Math.imul(O, Le) | 0, N = N + Math.imul(O, Be) | 0, A = A + Math.imul(J, Ne) | 0, y = y + Math.imul(J, Pe) | 0, y = y + Math.imul(X, Ne) | 0, N = N + Math.imul(X, Pe) | 0, A = A + Math.imul(K, Oe) | 0, y = y + Math.imul(K, Fe) | 0, y = y + Math.imul($, Oe) | 0, N = N + Math.imul($, Fe) | 0;
        var mt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, A = Math.imul(V, se), y = Math.imul(V, _e), y = y + Math.imul(z, se) | 0, N = Math.imul(z, _e), A = A + Math.imul(_, Ee) | 0, y = y + Math.imul(_, Re) | 0, y = y + Math.imul(L, Ee) | 0, N = N + Math.imul(L, Re) | 0, A = A + Math.imul(ye, Se) | 0, y = y + Math.imul(ye, Me) | 0, y = y + Math.imul(C, Se) | 0, N = N + Math.imul(C, Me) | 0, A = A + Math.imul(pe, ke) | 0, y = y + Math.imul(pe, Ce) | 0, y = y + Math.imul(we, ke) | 0, N = N + Math.imul(we, Ce) | 0, A = A + Math.imul(me, Ie) | 0, y = y + Math.imul(me, xe) | 0, y = y + Math.imul(he, Ie) | 0, N = N + Math.imul(he, xe) | 0, A = A + Math.imul(ne, Ae) | 0, y = y + Math.imul(ne, Te) | 0, y = y + Math.imul(fe, Ae) | 0, N = N + Math.imul(fe, Te) | 0, A = A + Math.imul(Q, Le) | 0, y = y + Math.imul(Q, Be) | 0, y = y + Math.imul(ae, Le) | 0, N = N + Math.imul(ae, Be) | 0, A = A + Math.imul(P, Ne) | 0, y = y + Math.imul(P, Pe) | 0, y = y + Math.imul(O, Ne) | 0, N = N + Math.imul(O, Pe) | 0, A = A + Math.imul(J, Oe) | 0, y = y + Math.imul(J, Fe) | 0, y = y + Math.imul(X, Oe) | 0, N = N + Math.imul(X, Fe) | 0;
        var wt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, A = Math.imul(V, Ee), y = Math.imul(V, Re), y = y + Math.imul(z, Ee) | 0, N = Math.imul(z, Re), A = A + Math.imul(_, Se) | 0, y = y + Math.imul(_, Me) | 0, y = y + Math.imul(L, Se) | 0, N = N + Math.imul(L, Me) | 0, A = A + Math.imul(ye, ke) | 0, y = y + Math.imul(ye, Ce) | 0, y = y + Math.imul(C, ke) | 0, N = N + Math.imul(C, Ce) | 0, A = A + Math.imul(pe, Ie) | 0, y = y + Math.imul(pe, xe) | 0, y = y + Math.imul(we, Ie) | 0, N = N + Math.imul(we, xe) | 0, A = A + Math.imul(me, Ae) | 0, y = y + Math.imul(me, Te) | 0, y = y + Math.imul(he, Ae) | 0, N = N + Math.imul(he, Te) | 0, A = A + Math.imul(ne, Le) | 0, y = y + Math.imul(ne, Be) | 0, y = y + Math.imul(fe, Le) | 0, N = N + Math.imul(fe, Be) | 0, A = A + Math.imul(Q, Ne) | 0, y = y + Math.imul(Q, Pe) | 0, y = y + Math.imul(ae, Ne) | 0, N = N + Math.imul(ae, Pe) | 0, A = A + Math.imul(P, Oe) | 0, y = y + Math.imul(P, Fe) | 0, y = y + Math.imul(O, Oe) | 0, N = N + Math.imul(O, Fe) | 0;
        var yt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, A = Math.imul(V, Se), y = Math.imul(V, Me), y = y + Math.imul(z, Se) | 0, N = Math.imul(z, Me), A = A + Math.imul(_, ke) | 0, y = y + Math.imul(_, Ce) | 0, y = y + Math.imul(L, ke) | 0, N = N + Math.imul(L, Ce) | 0, A = A + Math.imul(ye, Ie) | 0, y = y + Math.imul(ye, xe) | 0, y = y + Math.imul(C, Ie) | 0, N = N + Math.imul(C, xe) | 0, A = A + Math.imul(pe, Ae) | 0, y = y + Math.imul(pe, Te) | 0, y = y + Math.imul(we, Ae) | 0, N = N + Math.imul(we, Te) | 0, A = A + Math.imul(me, Le) | 0, y = y + Math.imul(me, Be) | 0, y = y + Math.imul(he, Le) | 0, N = N + Math.imul(he, Be) | 0, A = A + Math.imul(ne, Ne) | 0, y = y + Math.imul(ne, Pe) | 0, y = y + Math.imul(fe, Ne) | 0, N = N + Math.imul(fe, Pe) | 0, A = A + Math.imul(Q, Oe) | 0, y = y + Math.imul(Q, Fe) | 0, y = y + Math.imul(ae, Oe) | 0, N = N + Math.imul(ae, Fe) | 0;
        var bt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, A = Math.imul(V, ke), y = Math.imul(V, Ce), y = y + Math.imul(z, ke) | 0, N = Math.imul(z, Ce), A = A + Math.imul(_, Ie) | 0, y = y + Math.imul(_, xe) | 0, y = y + Math.imul(L, Ie) | 0, N = N + Math.imul(L, xe) | 0, A = A + Math.imul(ye, Ae) | 0, y = y + Math.imul(ye, Te) | 0, y = y + Math.imul(C, Ae) | 0, N = N + Math.imul(C, Te) | 0, A = A + Math.imul(pe, Le) | 0, y = y + Math.imul(pe, Be) | 0, y = y + Math.imul(we, Le) | 0, N = N + Math.imul(we, Be) | 0, A = A + Math.imul(me, Ne) | 0, y = y + Math.imul(me, Pe) | 0, y = y + Math.imul(he, Ne) | 0, N = N + Math.imul(he, Pe) | 0, A = A + Math.imul(ne, Oe) | 0, y = y + Math.imul(ne, Fe) | 0, y = y + Math.imul(fe, Oe) | 0, N = N + Math.imul(fe, Fe) | 0;
        var vt = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, A = Math.imul(V, Ie), y = Math.imul(V, xe), y = y + Math.imul(z, Ie) | 0, N = Math.imul(z, xe), A = A + Math.imul(_, Ae) | 0, y = y + Math.imul(_, Te) | 0, y = y + Math.imul(L, Ae) | 0, N = N + Math.imul(L, Te) | 0, A = A + Math.imul(ye, Le) | 0, y = y + Math.imul(ye, Be) | 0, y = y + Math.imul(C, Le) | 0, N = N + Math.imul(C, Be) | 0, A = A + Math.imul(pe, Ne) | 0, y = y + Math.imul(pe, Pe) | 0, y = y + Math.imul(we, Ne) | 0, N = N + Math.imul(we, Pe) | 0, A = A + Math.imul(me, Oe) | 0, y = y + Math.imul(me, Fe) | 0, y = y + Math.imul(he, Oe) | 0, N = N + Math.imul(he, Fe) | 0;
        var _t = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, A = Math.imul(V, Ae), y = Math.imul(V, Te), y = y + Math.imul(z, Ae) | 0, N = Math.imul(z, Te), A = A + Math.imul(_, Le) | 0, y = y + Math.imul(_, Be) | 0, y = y + Math.imul(L, Le) | 0, N = N + Math.imul(L, Be) | 0, A = A + Math.imul(ye, Ne) | 0, y = y + Math.imul(ye, Pe) | 0, y = y + Math.imul(C, Ne) | 0, N = N + Math.imul(C, Pe) | 0, A = A + Math.imul(pe, Oe) | 0, y = y + Math.imul(pe, Fe) | 0, y = y + Math.imul(we, Oe) | 0, N = N + Math.imul(we, Fe) | 0;
        var Sn = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (Sn >>> 26) | 0, Sn &= 67108863, A = Math.imul(V, Le), y = Math.imul(V, Be), y = y + Math.imul(z, Le) | 0, N = Math.imul(z, Be), A = A + Math.imul(_, Ne) | 0, y = y + Math.imul(_, Pe) | 0, y = y + Math.imul(L, Ne) | 0, N = N + Math.imul(L, Pe) | 0, A = A + Math.imul(ye, Oe) | 0, y = y + Math.imul(ye, Fe) | 0, y = y + Math.imul(C, Oe) | 0, N = N + Math.imul(C, Fe) | 0;
        var Mn = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, A = Math.imul(V, Ne), y = Math.imul(V, Pe), y = y + Math.imul(z, Ne) | 0, N = Math.imul(z, Pe), A = A + Math.imul(_, Oe) | 0, y = y + Math.imul(_, Fe) | 0, y = y + Math.imul(L, Oe) | 0, N = N + Math.imul(L, Fe) | 0;
        var kn = (j + A | 0) + ((y & 8191) << 13) | 0;
        j = (N + (y >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, A = Math.imul(V, Oe), y = Math.imul(V, Fe), y = y + Math.imul(z, Oe) | 0, N = Math.imul(z, Fe);
        var Cn = (j + A | 0) + ((y & 8191) << 13) | 0;
        return j = (N + (y >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, B[0] = at, B[1] = ut, B[2] = ct, B[3] = lt, B[4] = ht, B[5] = dt, B[6] = ft, B[7] = pt, B[8] = gt, B[9] = mt, B[10] = wt, B[11] = yt, B[12] = bt, B[13] = vt, B[14] = _t, B[15] = Sn, B[16] = Mn, B[17] = kn, B[18] = Cn, j !== 0 && (B[19] = j, M.length++), M;
      };
      Math.imul || (R = a);
      function S(F, l, E) {
        E.negative = l.negative ^ F.negative, E.length = F.length + l.length;
        for (var M = 0, k = 0, x = 0; x < E.length - 1; x++) {
          var B = k;
          k = 0;
          for (var j = M & 67108863, A = Math.min(x, l.length - 1), y = Math.max(0, x - F.length + 1); y <= A; y++) {
            var N = x - y, te = F.words[N] | 0, K = l.words[y] | 0, $ = te * K, W = $ & 67108863;
            B = B + ($ / 67108864 | 0) | 0, W = W + j | 0, j = W & 67108863, B = B + (W >>> 26) | 0, k += B >>> 26, B &= 67108863;
          }
          E.words[x] = j, M = B, B = k;
        }
        return M !== 0 ? E.words[x] = M : E.length--, E._strip();
      }
      function I(F, l, E) {
        return S(F, l, E);
      }
      n.prototype.mulTo = function(l, E) {
        var M, k = this.length + l.length;
        return this.length === 10 && l.length === 10 ? M = R(this, l, E) : k < 63 ? M = a(this, l, E) : k < 1024 ? M = S(this, l, E) : M = I(this, l, E), M;
      }, n.prototype.mul = function(l) {
        var E = new n(null);
        return E.words = new Array(this.length + l.length), this.mulTo(l, E);
      }, n.prototype.mulf = function(l) {
        var E = new n(null);
        return E.words = new Array(this.length + l.length), I(this, l, E);
      }, n.prototype.imul = function(l) {
        return this.clone().mulTo(l, this);
      }, n.prototype.imuln = function(l) {
        var E = l < 0;
        E && (l = -l), t(typeof l == "number"), t(l < 67108864);
        for (var M = 0, k = 0; k < this.length; k++) {
          var x = (this.words[k] | 0) * l, B = (x & 67108863) + (M & 67108863);
          M >>= 26, M += x / 67108864 | 0, M += B >>> 26, this.words[k] = B & 67108863;
        }
        return M !== 0 && (this.words[k] = M, this.length++), E ? this.ineg() : this;
      }, n.prototype.muln = function(l) {
        return this.clone().imuln(l);
      }, n.prototype.sqr = function() {
        return this.mul(this);
      }, n.prototype.isqr = function() {
        return this.imul(this.clone());
      }, n.prototype.pow = function(l) {
        var E = v(l);
        if (E.length === 0) return new n(1);
        for (var M = this, k = 0; k < E.length && E[k] === 0; k++, M = M.sqr())
          ;
        if (++k < E.length)
          for (var x = M.sqr(); k < E.length; k++, x = x.sqr())
            E[k] !== 0 && (M = M.mul(x));
        return M;
      }, n.prototype.iushln = function(l) {
        t(typeof l == "number" && l >= 0);
        var E = l % 26, M = (l - E) / 26, k = 67108863 >>> 26 - E << 26 - E, x;
        if (E !== 0) {
          var B = 0;
          for (x = 0; x < this.length; x++) {
            var j = this.words[x] & k, A = (this.words[x] | 0) - j << E;
            this.words[x] = A | B, B = j >>> 26 - E;
          }
          B && (this.words[x] = B, this.length++);
        }
        if (M !== 0) {
          for (x = this.length - 1; x >= 0; x--)
            this.words[x + M] = this.words[x];
          for (x = 0; x < M; x++)
            this.words[x] = 0;
          this.length += M;
        }
        return this._strip();
      }, n.prototype.ishln = function(l) {
        return t(this.negative === 0), this.iushln(l);
      }, n.prototype.iushrn = function(l, E, M) {
        t(typeof l == "number" && l >= 0);
        var k;
        E ? k = (E - E % 26) / 26 : k = 0;
        var x = l % 26, B = Math.min((l - x) / 26, this.length), j = 67108863 ^ 67108863 >>> x << x, A = M;
        if (k -= B, k = Math.max(0, k), A) {
          for (var y = 0; y < B; y++)
            A.words[y] = this.words[y];
          A.length = B;
        }
        if (B !== 0) if (this.length > B)
          for (this.length -= B, y = 0; y < this.length; y++)
            this.words[y] = this.words[y + B];
        else
          this.words[0] = 0, this.length = 1;
        var N = 0;
        for (y = this.length - 1; y >= 0 && (N !== 0 || y >= k); y--) {
          var te = this.words[y] | 0;
          this.words[y] = N << 26 - x | te >>> x, N = te & j;
        }
        return A && N !== 0 && (A.words[A.length++] = N), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, n.prototype.ishrn = function(l, E, M) {
        return t(this.negative === 0), this.iushrn(l, E, M);
      }, n.prototype.shln = function(l) {
        return this.clone().ishln(l);
      }, n.prototype.ushln = function(l) {
        return this.clone().iushln(l);
      }, n.prototype.shrn = function(l) {
        return this.clone().ishrn(l);
      }, n.prototype.ushrn = function(l) {
        return this.clone().iushrn(l);
      }, n.prototype.testn = function(l) {
        t(typeof l == "number" && l >= 0);
        var E = l % 26, M = (l - E) / 26, k = 1 << E;
        if (this.length <= M) return !1;
        var x = this.words[M];
        return !!(x & k);
      }, n.prototype.imaskn = function(l) {
        t(typeof l == "number" && l >= 0);
        var E = l % 26, M = (l - E) / 26;
        if (t(this.negative === 0, "imaskn works only with positive numbers"), this.length <= M)
          return this;
        if (E !== 0 && M++, this.length = Math.min(M, this.length), E !== 0) {
          var k = 67108863 ^ 67108863 >>> E << E;
          this.words[this.length - 1] &= k;
        }
        return this._strip();
      }, n.prototype.maskn = function(l) {
        return this.clone().imaskn(l);
      }, n.prototype.iaddn = function(l) {
        return t(typeof l == "number"), t(l < 67108864), l < 0 ? this.isubn(-l) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= l ? (this.words[0] = l - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(l), this.negative = 1, this) : this._iaddn(l);
      }, n.prototype._iaddn = function(l) {
        this.words[0] += l;
        for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
          this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
        return this.length = Math.max(this.length, E + 1), this;
      }, n.prototype.isubn = function(l) {
        if (t(typeof l == "number"), t(l < 67108864), l < 0) return this.iaddn(-l);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(l), this.negative = 1, this;
        if (this.words[0] -= l, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var E = 0; E < this.length && this.words[E] < 0; E++)
            this.words[E] += 67108864, this.words[E + 1] -= 1;
        return this._strip();
      }, n.prototype.addn = function(l) {
        return this.clone().iaddn(l);
      }, n.prototype.subn = function(l) {
        return this.clone().isubn(l);
      }, n.prototype.iabs = function() {
        return this.negative = 0, this;
      }, n.prototype.abs = function() {
        return this.clone().iabs();
      }, n.prototype._ishlnsubmul = function(l, E, M) {
        var k = l.length + M, x;
        this._expand(k);
        var B, j = 0;
        for (x = 0; x < l.length; x++) {
          B = (this.words[x + M] | 0) + j;
          var A = (l.words[x] | 0) * E;
          B -= A & 67108863, j = (B >> 26) - (A / 67108864 | 0), this.words[x + M] = B & 67108863;
        }
        for (; x < this.length - M; x++)
          B = (this.words[x + M] | 0) + j, j = B >> 26, this.words[x + M] = B & 67108863;
        if (j === 0) return this._strip();
        for (t(j === -1), j = 0, x = 0; x < this.length; x++)
          B = -(this.words[x] | 0) + j, j = B >> 26, this.words[x] = B & 67108863;
        return this.negative = 1, this._strip();
      }, n.prototype._wordDiv = function(l, E) {
        var M = this.length - l.length, k = this.clone(), x = l, B = x.words[x.length - 1] | 0, j = this._countBits(B);
        M = 26 - j, M !== 0 && (x = x.ushln(M), k.iushln(M), B = x.words[x.length - 1] | 0);
        var A = k.length - x.length, y;
        if (E !== "mod") {
          y = new n(null), y.length = A + 1, y.words = new Array(y.length);
          for (var N = 0; N < y.length; N++)
            y.words[N] = 0;
        }
        var te = k.clone()._ishlnsubmul(x, 1, A);
        te.negative === 0 && (k = te, y && (y.words[A] = 1));
        for (var K = A - 1; K >= 0; K--) {
          var $ = (k.words[x.length + K] | 0) * 67108864 + (k.words[x.length + K - 1] | 0);
          for ($ = Math.min($ / B | 0, 67108863), k._ishlnsubmul(x, $, K); k.negative !== 0; )
            $--, k.negative = 0, k._ishlnsubmul(x, 1, K), k.isZero() || (k.negative ^= 1);
          y && (y.words[K] = $);
        }
        return y && y._strip(), k._strip(), E !== "div" && M !== 0 && k.iushrn(M), {
          div: y || null,
          mod: k
        };
      }, n.prototype.divmod = function(l, E, M) {
        if (t(!l.isZero()), this.isZero())
          return {
            div: new n(0),
            mod: new n(0)
          };
        var k, x, B;
        return this.negative !== 0 && l.negative === 0 ? (B = this.neg().divmod(l, E), E !== "mod" && (k = B.div.neg()), E !== "div" && (x = B.mod.neg(), M && x.negative !== 0 && x.iadd(l)), {
          div: k,
          mod: x
        }) : this.negative === 0 && l.negative !== 0 ? (B = this.divmod(l.neg(), E), E !== "mod" && (k = B.div.neg()), {
          div: k,
          mod: B.mod
        }) : this.negative & l.negative ? (B = this.neg().divmod(l.neg(), E), E !== "div" && (x = B.mod.neg(), M && x.negative !== 0 && x.isub(l)), {
          div: B.div,
          mod: x
        }) : l.length > this.length || this.cmp(l) < 0 ? {
          div: new n(0),
          mod: this
        } : l.length === 1 ? E === "div" ? {
          div: this.divn(l.words[0]),
          mod: null
        } : E === "mod" ? {
          div: null,
          mod: new n(this.modrn(l.words[0]))
        } : {
          div: this.divn(l.words[0]),
          mod: new n(this.modrn(l.words[0]))
        } : this._wordDiv(l, E);
      }, n.prototype.div = function(l) {
        return this.divmod(l, "div", !1).div;
      }, n.prototype.mod = function(l) {
        return this.divmod(l, "mod", !1).mod;
      }, n.prototype.umod = function(l) {
        return this.divmod(l, "mod", !0).mod;
      }, n.prototype.divRound = function(l) {
        var E = this.divmod(l);
        if (E.mod.isZero()) return E.div;
        var M = E.div.negative !== 0 ? E.mod.isub(l) : E.mod, k = l.ushrn(1), x = l.andln(1), B = M.cmp(k);
        return B < 0 || x === 1 && B === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
      }, n.prototype.modrn = function(l) {
        var E = l < 0;
        E && (l = -l), t(l <= 67108863);
        for (var M = (1 << 26) % l, k = 0, x = this.length - 1; x >= 0; x--)
          k = (M * k + (this.words[x] | 0)) % l;
        return E ? -k : k;
      }, n.prototype.modn = function(l) {
        return this.modrn(l);
      }, n.prototype.idivn = function(l) {
        var E = l < 0;
        E && (l = -l), t(l <= 67108863);
        for (var M = 0, k = this.length - 1; k >= 0; k--) {
          var x = (this.words[k] | 0) + M * 67108864;
          this.words[k] = x / l | 0, M = x % l;
        }
        return this._strip(), E ? this.ineg() : this;
      }, n.prototype.divn = function(l) {
        return this.clone().idivn(l);
      }, n.prototype.egcd = function(l) {
        t(l.negative === 0), t(!l.isZero());
        var E = this, M = l.clone();
        E.negative !== 0 ? E = E.umod(l) : E = E.clone();
        for (var k = new n(1), x = new n(0), B = new n(0), j = new n(1), A = 0; E.isEven() && M.isEven(); )
          E.iushrn(1), M.iushrn(1), ++A;
        for (var y = M.clone(), N = E.clone(); !E.isZero(); ) {
          for (var te = 0, K = 1; !(E.words[0] & K) && te < 26; ++te, K <<= 1) ;
          if (te > 0)
            for (E.iushrn(te); te-- > 0; )
              (k.isOdd() || x.isOdd()) && (k.iadd(y), x.isub(N)), k.iushrn(1), x.iushrn(1);
          for (var $ = 0, W = 1; !(M.words[0] & W) && $ < 26; ++$, W <<= 1) ;
          if ($ > 0)
            for (M.iushrn($); $-- > 0; )
              (B.isOdd() || j.isOdd()) && (B.iadd(y), j.isub(N)), B.iushrn(1), j.iushrn(1);
          E.cmp(M) >= 0 ? (E.isub(M), k.isub(B), x.isub(j)) : (M.isub(E), B.isub(k), j.isub(x));
        }
        return {
          a: B,
          b: j,
          gcd: M.iushln(A)
        };
      }, n.prototype._invmp = function(l) {
        t(l.negative === 0), t(!l.isZero());
        var E = this, M = l.clone();
        E.negative !== 0 ? E = E.umod(l) : E = E.clone();
        for (var k = new n(1), x = new n(0), B = M.clone(); E.cmpn(1) > 0 && M.cmpn(1) > 0; ) {
          for (var j = 0, A = 1; !(E.words[0] & A) && j < 26; ++j, A <<= 1) ;
          if (j > 0)
            for (E.iushrn(j); j-- > 0; )
              k.isOdd() && k.iadd(B), k.iushrn(1);
          for (var y = 0, N = 1; !(M.words[0] & N) && y < 26; ++y, N <<= 1) ;
          if (y > 0)
            for (M.iushrn(y); y-- > 0; )
              x.isOdd() && x.iadd(B), x.iushrn(1);
          E.cmp(M) >= 0 ? (E.isub(M), k.isub(x)) : (M.isub(E), x.isub(k));
        }
        var te;
        return E.cmpn(1) === 0 ? te = k : te = x, te.cmpn(0) < 0 && te.iadd(l), te;
      }, n.prototype.gcd = function(l) {
        if (this.isZero()) return l.abs();
        if (l.isZero()) return this.abs();
        var E = this.clone(), M = l.clone();
        E.negative = 0, M.negative = 0;
        for (var k = 0; E.isEven() && M.isEven(); k++)
          E.iushrn(1), M.iushrn(1);
        do {
          for (; E.isEven(); )
            E.iushrn(1);
          for (; M.isEven(); )
            M.iushrn(1);
          var x = E.cmp(M);
          if (x < 0) {
            var B = E;
            E = M, M = B;
          } else if (x === 0 || M.cmpn(1) === 0)
            break;
          E.isub(M);
        } while (!0);
        return M.iushln(k);
      }, n.prototype.invm = function(l) {
        return this.egcd(l).a.umod(l);
      }, n.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, n.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, n.prototype.andln = function(l) {
        return this.words[0] & l;
      }, n.prototype.bincn = function(l) {
        t(typeof l == "number");
        var E = l % 26, M = (l - E) / 26, k = 1 << E;
        if (this.length <= M)
          return this._expand(M + 1), this.words[M] |= k, this;
        for (var x = k, B = M; x !== 0 && B < this.length; B++) {
          var j = this.words[B] | 0;
          j += x, x = j >>> 26, j &= 67108863, this.words[B] = j;
        }
        return x !== 0 && (this.words[B] = x, this.length++), this;
      }, n.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, n.prototype.cmpn = function(l) {
        var E = l < 0;
        if (this.negative !== 0 && !E) return -1;
        if (this.negative === 0 && E) return 1;
        this._strip();
        var M;
        if (this.length > 1)
          M = 1;
        else {
          E && (l = -l), t(l <= 67108863, "Number is too big");
          var k = this.words[0] | 0;
          M = k === l ? 0 : k < l ? -1 : 1;
        }
        return this.negative !== 0 ? -M | 0 : M;
      }, n.prototype.cmp = function(l) {
        if (this.negative !== 0 && l.negative === 0) return -1;
        if (this.negative === 0 && l.negative !== 0) return 1;
        var E = this.ucmp(l);
        return this.negative !== 0 ? -E | 0 : E;
      }, n.prototype.ucmp = function(l) {
        if (this.length > l.length) return 1;
        if (this.length < l.length) return -1;
        for (var E = 0, M = this.length - 1; M >= 0; M--) {
          var k = this.words[M] | 0, x = l.words[M] | 0;
          if (k !== x) {
            k < x ? E = -1 : k > x && (E = 1);
            break;
          }
        }
        return E;
      }, n.prototype.gtn = function(l) {
        return this.cmpn(l) === 1;
      }, n.prototype.gt = function(l) {
        return this.cmp(l) === 1;
      }, n.prototype.gten = function(l) {
        return this.cmpn(l) >= 0;
      }, n.prototype.gte = function(l) {
        return this.cmp(l) >= 0;
      }, n.prototype.ltn = function(l) {
        return this.cmpn(l) === -1;
      }, n.prototype.lt = function(l) {
        return this.cmp(l) === -1;
      }, n.prototype.lten = function(l) {
        return this.cmpn(l) <= 0;
      }, n.prototype.lte = function(l) {
        return this.cmp(l) <= 0;
      }, n.prototype.eqn = function(l) {
        return this.cmpn(l) === 0;
      }, n.prototype.eq = function(l) {
        return this.cmp(l) === 0;
      }, n.red = function(l) {
        return new Y(l);
      }, n.prototype.toRed = function(l) {
        return t(!this.red, "Already a number in reduction context"), t(this.negative === 0, "red works only with positives"), l.convertTo(this)._forceRed(l);
      }, n.prototype.fromRed = function() {
        return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, n.prototype._forceRed = function(l) {
        return this.red = l, this;
      }, n.prototype.forceRed = function(l) {
        return t(!this.red, "Already a number in reduction context"), this._forceRed(l);
      }, n.prototype.redAdd = function(l) {
        return t(this.red, "redAdd works only with red numbers"), this.red.add(this, l);
      }, n.prototype.redIAdd = function(l) {
        return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, l);
      }, n.prototype.redSub = function(l) {
        return t(this.red, "redSub works only with red numbers"), this.red.sub(this, l);
      }, n.prototype.redISub = function(l) {
        return t(this.red, "redISub works only with red numbers"), this.red.isub(this, l);
      }, n.prototype.redShl = function(l) {
        return t(this.red, "redShl works only with red numbers"), this.red.shl(this, l);
      }, n.prototype.redMul = function(l) {
        return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, l), this.red.mul(this, l);
      }, n.prototype.redIMul = function(l) {
        return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, l), this.red.imul(this, l);
      }, n.prototype.redSqr = function() {
        return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, n.prototype.redISqr = function() {
        return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, n.prototype.redSqrt = function() {
        return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, n.prototype.redInvm = function() {
        return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, n.prototype.redNeg = function() {
        return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, n.prototype.redPow = function(l) {
        return t(this.red && !l.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, l);
      };
      var T = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function q(F, l) {
        this.name = F, this.p = new n(l, 16), this.n = this.p.bitLength(), this.k = new n(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      q.prototype._tmp = function() {
        var l = new n(null);
        return l.words = new Array(Math.ceil(this.n / 13)), l;
      }, q.prototype.ireduce = function(l) {
        var E = l, M;
        do
          this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), M = E.bitLength();
        while (M > this.n);
        var k = M < this.n ? -1 : E.ucmp(this.p);
        return k === 0 ? (E.words[0] = 0, E.length = 1) : k > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
      }, q.prototype.split = function(l, E) {
        l.iushrn(this.n, 0, E);
      }, q.prototype.imulK = function(l) {
        return l.imul(this.k);
      };
      function D() {
        q.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      p(D, q), D.prototype.split = function(l, E) {
        for (var M = 4194303, k = Math.min(l.length, 9), x = 0; x < k; x++)
          E.words[x] = l.words[x];
        if (E.length = k, l.length <= 9) {
          l.words[0] = 0, l.length = 1;
          return;
        }
        var B = l.words[9];
        for (E.words[E.length++] = B & M, x = 10; x < l.length; x++) {
          var j = l.words[x] | 0;
          l.words[x - 10] = (j & M) << 4 | B >>> 22, B = j;
        }
        B >>>= 22, l.words[x - 10] = B, B === 0 && l.length > 10 ? l.length -= 10 : l.length -= 9;
      }, D.prototype.imulK = function(l) {
        l.words[l.length] = 0, l.words[l.length + 1] = 0, l.length += 2;
        for (var E = 0, M = 0; M < l.length; M++) {
          var k = l.words[M] | 0;
          E += k * 977, l.words[M] = E & 67108863, E = k * 64 + (E / 67108864 | 0);
        }
        return l.words[l.length - 1] === 0 && (l.length--, l.words[l.length - 1] === 0 && l.length--), l;
      };
      function H() {
        q.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      p(H, q);
      function G() {
        q.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      p(G, q);
      function ee() {
        q.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      p(ee, q), ee.prototype.imulK = function(l) {
        for (var E = 0, M = 0; M < l.length; M++) {
          var k = (l.words[M] | 0) * 19 + E, x = k & 67108863;
          k >>>= 26, l.words[M] = x, E = k;
        }
        return E !== 0 && (l.words[l.length++] = E), l;
      }, n._prime = function(l) {
        if (T[l]) return T[l];
        var E;
        if (l === "k256")
          E = new D();
        else if (l === "p224")
          E = new H();
        else if (l === "p192")
          E = new G();
        else if (l === "p25519")
          E = new ee();
        else
          throw new Error("Unknown prime " + l);
        return T[l] = E, E;
      };
      function Y(F) {
        if (typeof F == "string") {
          var l = n._prime(F);
          this.m = l.p, this.prime = l;
        } else
          t(F.gtn(1), "modulus must be greater than 1"), this.m = F, this.prime = null;
      }
      Y.prototype._verify1 = function(l) {
        t(l.negative === 0, "red works only with positives"), t(l.red, "red works only with red numbers");
      }, Y.prototype._verify2 = function(l, E) {
        t((l.negative | E.negative) === 0, "red works only with positives"), t(
          l.red && l.red === E.red,
          "red works only with red numbers"
        );
      }, Y.prototype.imod = function(l) {
        return this.prime ? this.prime.ireduce(l)._forceRed(this) : (g(l, l.umod(this.m)._forceRed(this)), l);
      }, Y.prototype.neg = function(l) {
        return l.isZero() ? l.clone() : this.m.sub(l)._forceRed(this);
      }, Y.prototype.add = function(l, E) {
        this._verify2(l, E);
        var M = l.add(E);
        return M.cmp(this.m) >= 0 && M.isub(this.m), M._forceRed(this);
      }, Y.prototype.iadd = function(l, E) {
        this._verify2(l, E);
        var M = l.iadd(E);
        return M.cmp(this.m) >= 0 && M.isub(this.m), M;
      }, Y.prototype.sub = function(l, E) {
        this._verify2(l, E);
        var M = l.sub(E);
        return M.cmpn(0) < 0 && M.iadd(this.m), M._forceRed(this);
      }, Y.prototype.isub = function(l, E) {
        this._verify2(l, E);
        var M = l.isub(E);
        return M.cmpn(0) < 0 && M.iadd(this.m), M;
      }, Y.prototype.shl = function(l, E) {
        return this._verify1(l), this.imod(l.ushln(E));
      }, Y.prototype.imul = function(l, E) {
        return this._verify2(l, E), this.imod(l.imul(E));
      }, Y.prototype.mul = function(l, E) {
        return this._verify2(l, E), this.imod(l.mul(E));
      }, Y.prototype.isqr = function(l) {
        return this.imul(l, l.clone());
      }, Y.prototype.sqr = function(l) {
        return this.mul(l, l);
      }, Y.prototype.sqrt = function(l) {
        if (l.isZero()) return l.clone();
        var E = this.m.andln(3);
        if (t(E % 2 === 1), E === 3) {
          var M = this.m.add(new n(1)).iushrn(2);
          return this.pow(l, M);
        }
        for (var k = this.m.subn(1), x = 0; !k.isZero() && k.andln(1) === 0; )
          x++, k.iushrn(1);
        t(!k.isZero());
        var B = new n(1).toRed(this), j = B.redNeg(), A = this.m.subn(1).iushrn(1), y = this.m.bitLength();
        for (y = new n(2 * y * y).toRed(this); this.pow(y, A).cmp(j) !== 0; )
          y.redIAdd(j);
        for (var N = this.pow(y, k), te = this.pow(l, k.addn(1).iushrn(1)), K = this.pow(l, k), $ = x; K.cmp(B) !== 0; ) {
          for (var W = K, J = 0; W.cmp(B) !== 0; J++)
            W = W.redSqr();
          t(J < $);
          var X = this.pow(N, new n(1).iushln($ - J - 1));
          te = te.redMul(X), N = X.redSqr(), K = K.redMul(N), $ = J;
        }
        return te;
      }, Y.prototype.invm = function(l) {
        var E = l._invmp(this.m);
        return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
      }, Y.prototype.pow = function(l, E) {
        if (E.isZero()) return new n(1).toRed(this);
        if (E.cmpn(1) === 0) return l.clone();
        var M = 4, k = new Array(1 << M);
        k[0] = new n(1).toRed(this), k[1] = l;
        for (var x = 2; x < k.length; x++)
          k[x] = this.mul(k[x - 1], l);
        var B = k[0], j = 0, A = 0, y = E.bitLength() % 26;
        for (y === 0 && (y = 26), x = E.length - 1; x >= 0; x--) {
          for (var N = E.words[x], te = y - 1; te >= 0; te--) {
            var K = N >> te & 1;
            if (B !== k[0] && (B = this.sqr(B)), K === 0 && j === 0) {
              A = 0;
              continue;
            }
            j <<= 1, j |= K, A++, !(A !== M && (x !== 0 || te !== 0)) && (B = this.mul(B, k[j]), A = 0, j = 0);
          }
          y = 26;
        }
        return B;
      }, Y.prototype.convertTo = function(l) {
        var E = l.umod(this.m);
        return E === l ? E.clone() : E;
      }, Y.prototype.convertFrom = function(l) {
        var E = l.clone();
        return E.red = null, E;
      }, n.mont = function(l) {
        return new re(l);
      };
      function re(F) {
        Y.call(this, F), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new n(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      p(re, Y), re.prototype.convertTo = function(l) {
        return this.imod(l.ushln(this.shift));
      }, re.prototype.convertFrom = function(l) {
        var E = this.imod(l.mul(this.rinv));
        return E.red = null, E;
      }, re.prototype.imul = function(l, E) {
        if (l.isZero() || E.isZero())
          return l.words[0] = 0, l.length = 1, l;
        var M = l.imul(E), k = M.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), x = M.isub(k).iushrn(this.shift), B = x;
        return x.cmp(this.m) >= 0 ? B = x.isub(this.m) : x.cmpn(0) < 0 && (B = x.iadd(this.m)), B._forceRed(this);
      }, re.prototype.mul = function(l, E) {
        if (l.isZero() || E.isZero()) return new n(0)._forceRed(this);
        var M = l.mul(E), k = M.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), x = M.isub(k).iushrn(this.shift), B = x;
        return x.cmp(this.m) >= 0 ? B = x.isub(this.m) : x.cmpn(0) < 0 && (B = x.iadd(this.m)), B._forceRed(this);
      }, re.prototype.invm = function(l) {
        var E = this.imod(l._invmp(this.m).mul(this.r2));
        return E._forceRed(this);
      };
    })(e, Nl);
  }(ln)), ln.exports;
}
var xn = {}, Et = {}, oo;
function fn() {
  return oo || (oo = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.errorValues = Et.standardErrorCodes = void 0, Et.standardErrorCodes = {
    rpc: {
      invalidInput: -32e3,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603
    },
    provider: {
      userRejectedRequest: 4001,
      unauthorized: 4100,
      unsupportedMethod: 4200,
      disconnected: 4900,
      chainDisconnected: 4901,
      unsupportedChain: 4902
    }
  }, Et.errorValues = {
    "-32700": {
      standard: "JSON RPC 2.0",
      message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
      standard: "JSON RPC 2.0",
      message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
      standard: "JSON RPC 2.0",
      message: "The method does not exist / is not available."
    },
    "-32602": {
      standard: "JSON RPC 2.0",
      message: "Invalid method parameter(s)."
    },
    "-32603": {
      standard: "JSON RPC 2.0",
      message: "Internal JSON-RPC error."
    },
    "-32000": {
      standard: "EIP-1474",
      message: "Invalid input."
    },
    "-32001": {
      standard: "EIP-1474",
      message: "Resource not found."
    },
    "-32002": {
      standard: "EIP-1474",
      message: "Resource unavailable."
    },
    "-32003": {
      standard: "EIP-1474",
      message: "Transaction rejected."
    },
    "-32004": {
      standard: "EIP-1474",
      message: "Method not supported."
    },
    "-32005": {
      standard: "EIP-1474",
      message: "Request limit exceeded."
    },
    4001: {
      standard: "EIP-1193",
      message: "User rejected the request."
    },
    4100: {
      standard: "EIP-1193",
      message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
      standard: "EIP-1193",
      message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
      standard: "EIP-1193",
      message: "The provider is disconnected from all chains."
    },
    4901: {
      standard: "EIP-1193",
      message: "The provider is disconnected from the specified chain."
    },
    4902: {
      standard: "EIP-3085",
      message: "Unrecognized chain ID."
    }
  }), Et;
}
var ir = {}, An = {}, ao;
function Bs() {
  return ao || (ao = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.serialize = e.getErrorCode = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const r = /* @__PURE__ */ fn(), i = "Unspecified error message.";
    e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function t(h, s = i) {
      if (h && Number.isInteger(h)) {
        const f = h.toString();
        if (g(r.errorValues, f))
          return r.errorValues[f].message;
        if (d(h))
          return e.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
      return s;
    }
    e.getMessageFromCode = t;
    function p(h) {
      if (!Number.isInteger(h))
        return !1;
      const s = h.toString();
      return !!(r.errorValues[s] || d(h));
    }
    e.isValidCode = p;
    function n(h) {
      var s;
      if (typeof h == "number")
        return h;
      if (u(h))
        return (s = h.code) !== null && s !== void 0 ? s : h.errorCode;
    }
    e.getErrorCode = n;
    function u(h) {
      return typeof h == "object" && h !== null && (typeof h.code == "number" || typeof h.errorCode == "number");
    }
    function o(h, { shouldIncludeStack: s = !1 } = {}) {
      const f = {};
      if (h && typeof h == "object" && !Array.isArray(h) && g(h, "code") && p(h.code)) {
        const b = h;
        f.code = b.code, b.message && typeof b.message == "string" ? (f.message = b.message, g(b, "data") && (f.data = b.data)) : (f.message = t(f.code), f.data = { originalError: m(h) });
      } else
        f.code = r.standardErrorCodes.rpc.internal, f.message = c(h, "message") ? h.message : i, f.data = { originalError: m(h) };
      return s && (f.stack = c(h, "stack") ? h.stack : void 0), f;
    }
    e.serialize = o;
    function d(h) {
      return h >= -32099 && h <= -32e3;
    }
    function m(h) {
      return h && typeof h == "object" && !Array.isArray(h) ? Object.assign({}, h) : h;
    }
    function g(h, s) {
      return Object.prototype.hasOwnProperty.call(h, s);
    }
    function c(h, s) {
      return typeof h == "object" && h !== null && s in h && typeof h[s] == "string";
    }
  }(An)), An;
}
var uo;
function Pl() {
  if (uo) return ir;
  uo = 1, Object.defineProperty(ir, "__esModule", { value: !0 }), ir.standardErrors = void 0;
  const e = /* @__PURE__ */ fn(), r = /* @__PURE__ */ Bs();
  ir.standardErrors = {
    rpc: {
      parse: (d) => i(e.standardErrorCodes.rpc.parse, d),
      invalidRequest: (d) => i(e.standardErrorCodes.rpc.invalidRequest, d),
      invalidParams: (d) => i(e.standardErrorCodes.rpc.invalidParams, d),
      methodNotFound: (d) => i(e.standardErrorCodes.rpc.methodNotFound, d),
      internal: (d) => i(e.standardErrorCodes.rpc.internal, d),
      server: (d) => {
        if (!d || typeof d != "object" || Array.isArray(d))
          throw new Error("Ethereum RPC Server errors must provide single object argument.");
        const { code: m } = d;
        if (!Number.isInteger(m) || m > -32005 || m < -32099)
          throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        return i(m, d);
      },
      invalidInput: (d) => i(e.standardErrorCodes.rpc.invalidInput, d),
      resourceNotFound: (d) => i(e.standardErrorCodes.rpc.resourceNotFound, d),
      resourceUnavailable: (d) => i(e.standardErrorCodes.rpc.resourceUnavailable, d),
      transactionRejected: (d) => i(e.standardErrorCodes.rpc.transactionRejected, d),
      methodNotSupported: (d) => i(e.standardErrorCodes.rpc.methodNotSupported, d),
      limitExceeded: (d) => i(e.standardErrorCodes.rpc.limitExceeded, d)
    },
    provider: {
      userRejectedRequest: (d) => t(e.standardErrorCodes.provider.userRejectedRequest, d),
      unauthorized: (d) => t(e.standardErrorCodes.provider.unauthorized, d),
      unsupportedMethod: (d) => t(e.standardErrorCodes.provider.unsupportedMethod, d),
      disconnected: (d) => t(e.standardErrorCodes.provider.disconnected, d),
      chainDisconnected: (d) => t(e.standardErrorCodes.provider.chainDisconnected, d),
      unsupportedChain: (d) => t(e.standardErrorCodes.provider.unsupportedChain, d),
      custom: (d) => {
        if (!d || typeof d != "object" || Array.isArray(d))
          throw new Error("Ethereum Provider custom errors must provide single object argument.");
        const { code: m, message: g, data: c } = d;
        if (!g || typeof g != "string")
          throw new Error('"message" must be a nonempty string');
        return new u(m, g, c);
      }
    }
  };
  function i(d, m) {
    const [g, c] = p(m);
    return new n(d, g || (0, r.getMessageFromCode)(d), c);
  }
  function t(d, m) {
    const [g, c] = p(m);
    return new u(d, g || (0, r.getMessageFromCode)(d), c);
  }
  function p(d) {
    if (d) {
      if (typeof d == "string")
        return [d];
      if (typeof d == "object" && !Array.isArray(d)) {
        const { message: m, data: g } = d;
        if (m && typeof m != "string")
          throw new Error("Must specify string message.");
        return [m || void 0, g];
      }
    }
    return [];
  }
  class n extends Error {
    constructor(m, g, c) {
      if (!Number.isInteger(m))
        throw new Error('"code" must be an integer.');
      if (!g || typeof g != "string")
        throw new Error('"message" must be a nonempty string.');
      super(g), this.code = m, c !== void 0 && (this.data = c);
    }
  }
  class u extends n {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     * `code` must be an integer in the 1000 <= 4999 range.
     */
    constructor(m, g, c) {
      if (!o(m))
        throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
      super(m, g, c);
    }
  }
  function o(d) {
    return Number.isInteger(d) && d >= 1e3 && d <= 4999;
  }
  return ir;
}
var sr = {}, or = {}, co;
function Ns() {
  if (co) return or;
  co = 1, Object.defineProperty(or, "__esModule", { value: !0 }), or.isErrorResponse = void 0;
  function e(r) {
    return r.errorMessage !== void 0;
  }
  return or.isErrorResponse = e, or;
}
var ar = {}, lo;
function Ps() {
  return lo || (lo = 1, Object.defineProperty(ar, "__esModule", { value: !0 }), ar.LIB_VERSION = void 0, ar.LIB_VERSION = "3.9.3"), ar;
}
var ho;
function Ol() {
  if (ho) return sr;
  ho = 1, Object.defineProperty(sr, "__esModule", { value: !0 }), sr.serializeError = void 0;
  const e = /* @__PURE__ */ Ns(), r = /* @__PURE__ */ Ps(), i = /* @__PURE__ */ fn(), t = /* @__PURE__ */ Bs();
  function p(o, d) {
    const m = (0, t.serialize)(n(o), {
      shouldIncludeStack: !0
    }), g = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    g.searchParams.set("version", r.LIB_VERSION), g.searchParams.set("code", m.code.toString());
    const c = u(m.data, d);
    return c && g.searchParams.set("method", c), g.searchParams.set("message", m.message), Object.assign(Object.assign({}, m), { docUrl: g.href });
  }
  sr.serializeError = p;
  function n(o) {
    return typeof o == "string" ? {
      message: o,
      code: i.standardErrorCodes.rpc.internal
    } : (0, e.isErrorResponse)(o) ? Object.assign(Object.assign({}, o), { message: o.errorMessage, code: o.errorCode, data: { method: o.method } }) : o;
  }
  function u(o, d) {
    const m = o == null ? void 0 : o.method;
    if (m)
      return m;
    if (d !== void 0) {
      if (typeof d == "string")
        return d;
      if (Array.isArray(d)) {
        if (d.length > 0)
          return d[0].method;
      } else return d.method;
    }
  }
  return sr;
}
var fo;
function pn() {
  return fo || (fo = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.standardErrors = e.standardErrorCodes = e.serializeError = e.getMessageFromCode = e.getErrorCode = void 0;
    const r = /* @__PURE__ */ fn();
    Object.defineProperty(e, "standardErrorCodes", { enumerable: !0, get: function() {
      return r.standardErrorCodes;
    } });
    const i = /* @__PURE__ */ Pl();
    Object.defineProperty(e, "standardErrors", { enumerable: !0, get: function() {
      return i.standardErrors;
    } });
    const t = /* @__PURE__ */ Ol();
    Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
      return t.serializeError;
    } });
    const p = /* @__PURE__ */ Bs();
    Object.defineProperty(e, "getErrorCode", { enumerable: !0, get: function() {
      return p.getErrorCode;
    } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
      return p.getMessageFromCode;
    } });
  }(xn)), xn;
}
var $e = {}, po;
function gn() {
  if (po) return $e;
  po = 1, Object.defineProperty($e, "__esModule", { value: !0 }), $e.ProviderType = $e.RegExpString = $e.IntNumber = $e.BigIntString = $e.AddressString = $e.HexString = $e.OpaqueType = void 0;
  function e() {
    return (t) => t;
  }
  $e.OpaqueType = e, $e.HexString = e(), $e.AddressString = e(), $e.BigIntString = e();
  function r(t) {
    return Math.floor(t);
  }
  $e.IntNumber = r, $e.RegExpString = e();
  var i;
  return function(t) {
    t.CoinbaseWallet = "CoinbaseWallet", t.MetaMask = "MetaMask", t.Unselected = "";
  }(i || ($e.ProviderType = i = {})), $e;
}
var go;
function tt() {
  if (go) return ie;
  go = 1;
  var e = ie.__importDefault || function(M) {
    return M && M.__esModule ? M : { default: M };
  };
  Object.defineProperty(ie, "__esModule", { value: !0 }), ie.isMobileWeb = ie.getLocation = ie.isInIFrame = ie.createQrUrl = ie.getFavicon = ie.range = ie.isBigNumber = ie.ensureParsedJSONObject = ie.ensureBN = ie.ensureRegExpString = ie.ensureIntNumber = ie.ensureBuffer = ie.ensureAddressString = ie.ensureEvenLengthHexString = ie.ensureHexString = ie.isHexString = ie.prepend0x = ie.strip0x = ie.has0xPrefix = ie.hexStringFromIntNumber = ie.intNumberFromHexString = ie.bigIntStringFromBN = ie.hexStringFromBuffer = ie.hexStringToUint8Array = ie.uint8ArrayToHex = ie.randomBytesHex = void 0;
  const r = e(dn()), i = /* @__PURE__ */ pn(), t = /* @__PURE__ */ gn(), p = /^[0-9]*$/, n = /^[a-f0-9]*$/;
  function u(M) {
    return o(crypto.getRandomValues(new Uint8Array(M)));
  }
  ie.randomBytesHex = u;
  function o(M) {
    return [...M].map((k) => k.toString(16).padStart(2, "0")).join("");
  }
  ie.uint8ArrayToHex = o;
  function d(M) {
    return new Uint8Array(M.match(/.{1,2}/g).map((k) => parseInt(k, 16)));
  }
  ie.hexStringToUint8Array = d;
  function m(M, k = !1) {
    const x = M.toString("hex");
    return (0, t.HexString)(k ? `0x${x}` : x);
  }
  ie.hexStringFromBuffer = m;
  function g(M) {
    return (0, t.BigIntString)(M.toString(10));
  }
  ie.bigIntStringFromBN = g;
  function c(M) {
    return (0, t.IntNumber)(new r.default(R(M, !1), 16).toNumber());
  }
  ie.intNumberFromHexString = c;
  function h(M) {
    return (0, t.HexString)(`0x${new r.default(M).toString(16)}`);
  }
  ie.hexStringFromIntNumber = h;
  function s(M) {
    return M.startsWith("0x") || M.startsWith("0X");
  }
  ie.has0xPrefix = s;
  function f(M) {
    return s(M) ? M.slice(2) : M;
  }
  ie.strip0x = f;
  function b(M) {
    return s(M) ? `0x${M.slice(2)}` : `0x${M}`;
  }
  ie.prepend0x = b;
  function v(M) {
    if (typeof M != "string")
      return !1;
    const k = f(M).toLowerCase();
    return n.test(k);
  }
  ie.isHexString = v;
  function a(M, k = !1) {
    if (typeof M == "string") {
      const x = f(M).toLowerCase();
      if (n.test(x))
        return (0, t.HexString)(k ? `0x${x}` : x);
    }
    throw i.standardErrors.rpc.invalidParams(`"${String(M)}" is not a hexadecimal string`);
  }
  ie.ensureHexString = a;
  function R(M, k = !1) {
    let x = a(M, !1);
    return x.length % 2 === 1 && (x = (0, t.HexString)(`0${x}`)), k ? (0, t.HexString)(`0x${x}`) : x;
  }
  ie.ensureEvenLengthHexString = R;
  function S(M) {
    if (typeof M == "string") {
      const k = f(M).toLowerCase();
      if (v(k) && k.length === 40)
        return (0, t.AddressString)(b(k));
    }
    throw i.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(M)}`);
  }
  ie.ensureAddressString = S;
  function I(M) {
    if (Buffer.isBuffer(M))
      return M;
    if (typeof M == "string") {
      if (v(M)) {
        const k = R(M, !1);
        return Buffer.from(k, "hex");
      }
      return Buffer.from(M, "utf8");
    }
    throw i.standardErrors.rpc.invalidParams(`Not binary data: ${String(M)}`);
  }
  ie.ensureBuffer = I;
  function T(M) {
    if (typeof M == "number" && Number.isInteger(M))
      return (0, t.IntNumber)(M);
    if (typeof M == "string") {
      if (p.test(M))
        return (0, t.IntNumber)(Number(M));
      if (v(M))
        return (0, t.IntNumber)(new r.default(R(M, !1), 16).toNumber());
    }
    throw i.standardErrors.rpc.invalidParams(`Not an integer: ${String(M)}`);
  }
  ie.ensureIntNumber = T;
  function q(M) {
    if (M instanceof RegExp)
      return (0, t.RegExpString)(M.toString());
    throw i.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(M)}`);
  }
  ie.ensureRegExpString = q;
  function D(M) {
    if (M !== null && (r.default.isBN(M) || G(M)))
      return new r.default(M.toString(10), 10);
    if (typeof M == "number")
      return new r.default(T(M));
    if (typeof M == "string") {
      if (p.test(M))
        return new r.default(M, 10);
      if (v(M))
        return new r.default(R(M, !1), 16);
    }
    throw i.standardErrors.rpc.invalidParams(`Not an integer: ${String(M)}`);
  }
  ie.ensureBN = D;
  function H(M) {
    if (typeof M == "string")
      return JSON.parse(M);
    if (typeof M == "object")
      return M;
    throw i.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(M)}`);
  }
  ie.ensureParsedJSONObject = H;
  function G(M) {
    if (M == null || typeof M.constructor != "function")
      return !1;
    const { constructor: k } = M;
    return typeof k.config == "function" && typeof k.EUCLID == "number";
  }
  ie.isBigNumber = G;
  function ee(M, k) {
    return Array.from({ length: k - M }, (x, B) => M + B);
  }
  ie.range = ee;
  function Y() {
    const M = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'), { protocol: k, host: x } = document.location, B = M ? M.getAttribute("href") : null;
    return !B || B.startsWith("javascript:") || B.startsWith("vbscript:") ? null : B.startsWith("http://") || B.startsWith("https://") || B.startsWith("data:") ? B : B.startsWith("//") ? k + B : `${k}//${x}${B}`;
  }
  ie.getFavicon = Y;
  function re(M, k, x, B, j, A) {
    const y = B ? "parent-id" : "id", N = new URLSearchParams({
      [y]: M,
      secret: k,
      server: x,
      v: j,
      chainId: A.toString()
    }).toString();
    return `${x}/#/link?${N}`;
  }
  ie.createQrUrl = re;
  function F() {
    try {
      return window.frameElement !== null;
    } catch {
      return !1;
    }
  }
  ie.isInIFrame = F;
  function l() {
    try {
      return F() && window.top ? window.top.location : window.location;
    } catch {
      return window.location;
    }
  }
  ie.getLocation = l;
  function E() {
    var M;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((M = window == null ? void 0 : window.navigator) === null || M === void 0 ? void 0 : M.userAgent);
  }
  return ie.isMobileWeb = E, ie;
}
var ur = {}, mo;
function Fl() {
  if (mo) return ur;
  mo = 1, Object.defineProperty(ur, "__esModule", { value: !0 }), ur.ScopedLocalStorage = void 0;
  let e = class {
    // eslint-disable-next-line no-useless-constructor
    constructor(i) {
      this.scope = i;
    }
    setItem(i, t) {
      localStorage.setItem(this.scopedKey(i), t);
    }
    getItem(i) {
      return localStorage.getItem(this.scopedKey(i));
    }
    removeItem(i) {
      localStorage.removeItem(this.scopedKey(i));
    }
    clear() {
      const i = this.scopedKey(""), t = [];
      for (let p = 0; p < localStorage.length; p++) {
        const n = localStorage.key(p);
        typeof n == "string" && n.startsWith(i) && t.push(n);
      }
      t.forEach((p) => localStorage.removeItem(p));
    }
    scopedKey(i) {
      return `${this.scope}:${i}`;
    }
  };
  return ur.ScopedLocalStorage = e, ur;
}
var Dt = {}, cr = {}, lr = {}, hr = {}, wo;
function Os() {
  return wo || (wo = 1, Object.defineProperty(hr, "__esModule", { value: !0 }), hr.EVENTS = void 0, hr.EVENTS = {
    STARTED_CONNECTING: "walletlink_sdk.started.connecting",
    CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
    DISCONNECTED: "walletlink_sdk.disconnected",
    METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
    LINKED: "walletlink_sdk.linked",
    FAILURE: "walletlink_sdk.generic_failure",
    SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
    ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
    SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
    UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
    SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
    GENERAL_ERROR: "walletlink_sdk.general_error",
    WEB3_REQUEST: "walletlink_sdk.web3.request",
    WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
    WEB3_RESPONSE: "walletlink_sdk.web3.response",
    METHOD_NOT_IMPLEMENTED: "walletlink_sdk.method_not_implemented",
    UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
  }), hr;
}
var Je = {}, yo;
function Fs() {
  if (yo) return Je;
  yo = 1, Object.defineProperty(Je, "__esModule", { value: !0 }), Je.RelayAbstract = Je.APP_VERSION_KEY = Je.LOCAL_STORAGE_ADDRESSES_KEY = Je.WALLET_USER_NAME_KEY = void 0;
  const e = /* @__PURE__ */ pn();
  Je.WALLET_USER_NAME_KEY = "walletUsername", Je.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses", Je.APP_VERSION_KEY = "AppVersion";
  let r = class {
    async makeEthereumJSONRPCRequest(t, p) {
      if (!p)
        throw new Error("Error: No jsonRpcUrl provided");
      return window.fetch(p, {
        method: "POST",
        body: JSON.stringify(t),
        mode: "cors",
        headers: { "Content-Type": "application/json" }
      }).then((n) => n.json()).then((n) => {
        if (!n)
          throw e.standardErrors.rpc.parse({});
        const u = n, { error: o } = u;
        if (o)
          throw (0, e.serializeError)(o, t.method);
        return u;
      });
    }
  };
  return Je.RelayAbstract = r, Je;
}
var dr = {}, Tn = { exports: {} }, Jr = { exports: {} }, Ln = {}, fr = {}, bo;
function Dl() {
  if (bo) return fr;
  bo = 1, fr.byteLength = o, fr.toByteArray = m, fr.fromByteArray = h;
  for (var e = [], r = [], i = typeof Uint8Array < "u" ? Uint8Array : Array, t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", p = 0, n = t.length; p < n; ++p)
    e[p] = t[p], r[t.charCodeAt(p)] = p;
  r[45] = 62, r[95] = 63;
  function u(s) {
    var f = s.length;
    if (f % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var b = s.indexOf("=");
    b === -1 && (b = f);
    var v = b === f ? 0 : 4 - b % 4;
    return [b, v];
  }
  function o(s) {
    var f = u(s), b = f[0], v = f[1];
    return (b + v) * 3 / 4 - v;
  }
  function d(s, f, b) {
    return (f + b) * 3 / 4 - b;
  }
  function m(s) {
    var f, b = u(s), v = b[0], a = b[1], R = new i(d(s, v, a)), S = 0, I = a > 0 ? v - 4 : v, T;
    for (T = 0; T < I; T += 4)
      f = r[s.charCodeAt(T)] << 18 | r[s.charCodeAt(T + 1)] << 12 | r[s.charCodeAt(T + 2)] << 6 | r[s.charCodeAt(T + 3)], R[S++] = f >> 16 & 255, R[S++] = f >> 8 & 255, R[S++] = f & 255;
    return a === 2 && (f = r[s.charCodeAt(T)] << 2 | r[s.charCodeAt(T + 1)] >> 4, R[S++] = f & 255), a === 1 && (f = r[s.charCodeAt(T)] << 10 | r[s.charCodeAt(T + 1)] << 4 | r[s.charCodeAt(T + 2)] >> 2, R[S++] = f >> 8 & 255, R[S++] = f & 255), R;
  }
  function g(s) {
    return e[s >> 18 & 63] + e[s >> 12 & 63] + e[s >> 6 & 63] + e[s & 63];
  }
  function c(s, f, b) {
    for (var v, a = [], R = f; R < b; R += 3)
      v = (s[R] << 16 & 16711680) + (s[R + 1] << 8 & 65280) + (s[R + 2] & 255), a.push(g(v));
    return a.join("");
  }
  function h(s) {
    for (var f, b = s.length, v = b % 3, a = [], R = 16383, S = 0, I = b - v; S < I; S += R)
      a.push(c(s, S, S + R > I ? I : S + R));
    return v === 1 ? (f = s[b - 1], a.push(
      e[f >> 2] + e[f << 4 & 63] + "=="
    )) : v === 2 && (f = (s[b - 2] << 8) + s[b - 1], a.push(
      e[f >> 10] + e[f >> 4 & 63] + e[f << 2 & 63] + "="
    )), a.join("");
  }
  return fr;
}
var Gr = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var vo;
function ql() {
  return vo || (vo = 1, Gr.read = function(e, r, i, t, p) {
    var n, u, o = p * 8 - t - 1, d = (1 << o) - 1, m = d >> 1, g = -7, c = i ? p - 1 : 0, h = i ? -1 : 1, s = e[r + c];
    for (c += h, n = s & (1 << -g) - 1, s >>= -g, g += o; g > 0; n = n * 256 + e[r + c], c += h, g -= 8)
      ;
    for (u = n & (1 << -g) - 1, n >>= -g, g += t; g > 0; u = u * 256 + e[r + c], c += h, g -= 8)
      ;
    if (n === 0)
      n = 1 - m;
    else {
      if (n === d)
        return u ? NaN : (s ? -1 : 1) * (1 / 0);
      u = u + Math.pow(2, t), n = n - m;
    }
    return (s ? -1 : 1) * u * Math.pow(2, n - t);
  }, Gr.write = function(e, r, i, t, p, n) {
    var u, o, d, m = n * 8 - p - 1, g = (1 << m) - 1, c = g >> 1, h = p === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, s = t ? 0 : n - 1, f = t ? 1 : -1, b = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (o = isNaN(r) ? 1 : 0, u = g) : (u = Math.floor(Math.log(r) / Math.LN2), r * (d = Math.pow(2, -u)) < 1 && (u--, d *= 2), u + c >= 1 ? r += h / d : r += h * Math.pow(2, 1 - c), r * d >= 2 && (u++, d /= 2), u + c >= g ? (o = 0, u = g) : u + c >= 1 ? (o = (r * d - 1) * Math.pow(2, p), u = u + c) : (o = r * Math.pow(2, c - 1) * Math.pow(2, p), u = 0)); p >= 8; e[i + s] = o & 255, s += f, o /= 256, p -= 8)
      ;
    for (u = u << p | o, m += p; m > 0; e[i + s] = u & 255, s += f, u /= 256, m -= 8)
      ;
    e[i + s - f] |= b * 128;
  }), Gr;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var _o;
function mn() {
  return _o || (_o = 1, function(e) {
    const r = Dl(), i = ql(), t = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = o, e.SlowBuffer = R, e.INSPECT_MAX_BYTES = 50;
    const p = 2147483647;
    e.kMaxLength = p, o.TYPED_ARRAY_SUPPORT = n(), !o.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function n() {
      try {
        const C = new Uint8Array(1), w = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(w, Uint8Array.prototype), Object.setPrototypeOf(C, w), C.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(o.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(o.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (o.isBuffer(this))
          return this.byteOffset;
      }
    });
    function u(C) {
      if (C > p)
        throw new RangeError('The value "' + C + '" is invalid for option "size"');
      const w = new Uint8Array(C);
      return Object.setPrototypeOf(w, o.prototype), w;
    }
    function o(C, w, _) {
      if (typeof C == "number") {
        if (typeof w == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return c(C);
      }
      return d(C, w, _);
    }
    o.poolSize = 8192;
    function d(C, w, _) {
      if (typeof C == "string")
        return h(C, w);
      if (ArrayBuffer.isView(C))
        return f(C);
      if (C == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
        );
      if (ve(C, ArrayBuffer) || C && ve(C.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ve(C, SharedArrayBuffer) || C && ve(C.buffer, SharedArrayBuffer)))
        return b(C, w, _);
      if (typeof C == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const L = C.valueOf && C.valueOf();
      if (L != null && L !== C)
        return o.from(L, w, _);
      const U = v(C);
      if (U) return U;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof C[Symbol.toPrimitive] == "function")
        return o.from(C[Symbol.toPrimitive]("string"), w, _);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C
      );
    }
    o.from = function(C, w, _) {
      return d(C, w, _);
    }, Object.setPrototypeOf(o.prototype, Uint8Array.prototype), Object.setPrototypeOf(o, Uint8Array);
    function m(C) {
      if (typeof C != "number")
        throw new TypeError('"size" argument must be of type number');
      if (C < 0)
        throw new RangeError('The value "' + C + '" is invalid for option "size"');
    }
    function g(C, w, _) {
      return m(C), C <= 0 ? u(C) : w !== void 0 ? typeof _ == "string" ? u(C).fill(w, _) : u(C).fill(w) : u(C);
    }
    o.alloc = function(C, w, _) {
      return g(C, w, _);
    };
    function c(C) {
      return m(C), u(C < 0 ? 0 : a(C) | 0);
    }
    o.allocUnsafe = function(C) {
      return c(C);
    }, o.allocUnsafeSlow = function(C) {
      return c(C);
    };
    function h(C, w) {
      if ((typeof w != "string" || w === "") && (w = "utf8"), !o.isEncoding(w))
        throw new TypeError("Unknown encoding: " + w);
      const _ = S(C, w) | 0;
      let L = u(_);
      const U = L.write(C, w);
      return U !== _ && (L = L.slice(0, U)), L;
    }
    function s(C) {
      const w = C.length < 0 ? 0 : a(C.length) | 0, _ = u(w);
      for (let L = 0; L < w; L += 1)
        _[L] = C[L] & 255;
      return _;
    }
    function f(C) {
      if (ve(C, Uint8Array)) {
        const w = new Uint8Array(C);
        return b(w.buffer, w.byteOffset, w.byteLength);
      }
      return s(C);
    }
    function b(C, w, _) {
      if (w < 0 || C.byteLength < w)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (C.byteLength < w + (_ || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let L;
      return w === void 0 && _ === void 0 ? L = new Uint8Array(C) : _ === void 0 ? L = new Uint8Array(C, w) : L = new Uint8Array(C, w, _), Object.setPrototypeOf(L, o.prototype), L;
    }
    function v(C) {
      if (o.isBuffer(C)) {
        const w = a(C.length) | 0, _ = u(w);
        return _.length === 0 || C.copy(_, 0, 0, w), _;
      }
      if (C.length !== void 0)
        return typeof C.length != "number" || pe(C.length) ? u(0) : s(C);
      if (C.type === "Buffer" && Array.isArray(C.data))
        return s(C.data);
    }
    function a(C) {
      if (C >= p)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + p.toString(16) + " bytes");
      return C | 0;
    }
    function R(C) {
      return +C != C && (C = 0), o.alloc(+C);
    }
    o.isBuffer = function(w) {
      return w != null && w._isBuffer === !0 && w !== o.prototype;
    }, o.compare = function(w, _) {
      if (ve(w, Uint8Array) && (w = o.from(w, w.offset, w.byteLength)), ve(_, Uint8Array) && (_ = o.from(_, _.offset, _.byteLength)), !o.isBuffer(w) || !o.isBuffer(_))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (w === _) return 0;
      let L = w.length, U = _.length;
      for (let V = 0, z = Math.min(L, U); V < z; ++V)
        if (w[V] !== _[V]) {
          L = w[V], U = _[V];
          break;
        }
      return L < U ? -1 : U < L ? 1 : 0;
    }, o.isEncoding = function(w) {
      switch (String(w).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, o.concat = function(w, _) {
      if (!Array.isArray(w))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (w.length === 0)
        return o.alloc(0);
      let L;
      if (_ === void 0)
        for (_ = 0, L = 0; L < w.length; ++L)
          _ += w[L].length;
      const U = o.allocUnsafe(_);
      let V = 0;
      for (L = 0; L < w.length; ++L) {
        let z = w[L];
        if (ve(z, Uint8Array))
          V + z.length > U.length ? (o.isBuffer(z) || (z = o.from(z)), z.copy(U, V)) : Uint8Array.prototype.set.call(
            U,
            z,
            V
          );
        else if (o.isBuffer(z))
          z.copy(U, V);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        V += z.length;
      }
      return U;
    };
    function S(C, w) {
      if (o.isBuffer(C))
        return C.length;
      if (ArrayBuffer.isView(C) || ve(C, ArrayBuffer))
        return C.byteLength;
      if (typeof C != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof C
        );
      const _ = C.length, L = arguments.length > 2 && arguments[2] === !0;
      if (!L && _ === 0) return 0;
      let U = !1;
      for (; ; )
        switch (w) {
          case "ascii":
          case "latin1":
          case "binary":
            return _;
          case "utf8":
          case "utf-8":
            return ne(C).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return _ * 2;
          case "hex":
            return _ >>> 1;
          case "base64":
            return me(C).length;
          default:
            if (U)
              return L ? -1 : ne(C).length;
            w = ("" + w).toLowerCase(), U = !0;
        }
    }
    o.byteLength = S;
    function I(C, w, _) {
      let L = !1;
      if ((w === void 0 || w < 0) && (w = 0), w > this.length || ((_ === void 0 || _ > this.length) && (_ = this.length), _ <= 0) || (_ >>>= 0, w >>>= 0, _ <= w))
        return "";
      for (C || (C = "utf8"); ; )
        switch (C) {
          case "hex":
            return B(this, w, _);
          case "utf8":
          case "utf-8":
            return l(this, w, _);
          case "ascii":
            return k(this, w, _);
          case "latin1":
          case "binary":
            return x(this, w, _);
          case "base64":
            return F(this, w, _);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return j(this, w, _);
          default:
            if (L) throw new TypeError("Unknown encoding: " + C);
            C = (C + "").toLowerCase(), L = !0;
        }
    }
    o.prototype._isBuffer = !0;
    function T(C, w, _) {
      const L = C[w];
      C[w] = C[_], C[_] = L;
    }
    o.prototype.swap16 = function() {
      const w = this.length;
      if (w % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let _ = 0; _ < w; _ += 2)
        T(this, _, _ + 1);
      return this;
    }, o.prototype.swap32 = function() {
      const w = this.length;
      if (w % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let _ = 0; _ < w; _ += 4)
        T(this, _, _ + 3), T(this, _ + 1, _ + 2);
      return this;
    }, o.prototype.swap64 = function() {
      const w = this.length;
      if (w % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let _ = 0; _ < w; _ += 8)
        T(this, _, _ + 7), T(this, _ + 1, _ + 6), T(this, _ + 2, _ + 5), T(this, _ + 3, _ + 4);
      return this;
    }, o.prototype.toString = function() {
      const w = this.length;
      return w === 0 ? "" : arguments.length === 0 ? l(this, 0, w) : I.apply(this, arguments);
    }, o.prototype.toLocaleString = o.prototype.toString, o.prototype.equals = function(w) {
      if (!o.isBuffer(w)) throw new TypeError("Argument must be a Buffer");
      return this === w ? !0 : o.compare(this, w) === 0;
    }, o.prototype.inspect = function() {
      let w = "";
      const _ = e.INSPECT_MAX_BYTES;
      return w = this.toString("hex", 0, _).replace(/(.{2})/g, "$1 ").trim(), this.length > _ && (w += " ... "), "<Buffer " + w + ">";
    }, t && (o.prototype[t] = o.prototype.inspect), o.prototype.compare = function(w, _, L, U, V) {
      if (ve(w, Uint8Array) && (w = o.from(w, w.offset, w.byteLength)), !o.isBuffer(w))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof w
        );
      if (_ === void 0 && (_ = 0), L === void 0 && (L = w ? w.length : 0), U === void 0 && (U = 0), V === void 0 && (V = this.length), _ < 0 || L > w.length || U < 0 || V > this.length)
        throw new RangeError("out of range index");
      if (U >= V && _ >= L)
        return 0;
      if (U >= V)
        return -1;
      if (_ >= L)
        return 1;
      if (_ >>>= 0, L >>>= 0, U >>>= 0, V >>>= 0, this === w) return 0;
      let z = V - U, de = L - _;
      const ce = Math.min(z, de), ue = this.slice(U, V), be = w.slice(_, L);
      for (let se = 0; se < ce; ++se)
        if (ue[se] !== be[se]) {
          z = ue[se], de = be[se];
          break;
        }
      return z < de ? -1 : de < z ? 1 : 0;
    };
    function q(C, w, _, L, U) {
      if (C.length === 0) return -1;
      if (typeof _ == "string" ? (L = _, _ = 0) : _ > 2147483647 ? _ = 2147483647 : _ < -2147483648 && (_ = -2147483648), _ = +_, pe(_) && (_ = U ? 0 : C.length - 1), _ < 0 && (_ = C.length + _), _ >= C.length) {
        if (U) return -1;
        _ = C.length - 1;
      } else if (_ < 0)
        if (U) _ = 0;
        else return -1;
      if (typeof w == "string" && (w = o.from(w, L)), o.isBuffer(w))
        return w.length === 0 ? -1 : D(C, w, _, L, U);
      if (typeof w == "number")
        return w = w & 255, typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(C, w, _) : Uint8Array.prototype.lastIndexOf.call(C, w, _) : D(C, [w], _, L, U);
      throw new TypeError("val must be string, number or Buffer");
    }
    function D(C, w, _, L, U) {
      let V = 1, z = C.length, de = w.length;
      if (L !== void 0 && (L = String(L).toLowerCase(), L === "ucs2" || L === "ucs-2" || L === "utf16le" || L === "utf-16le")) {
        if (C.length < 2 || w.length < 2)
          return -1;
        V = 2, z /= 2, de /= 2, _ /= 2;
      }
      function ce(be, se) {
        return V === 1 ? be[se] : be.readUInt16BE(se * V);
      }
      let ue;
      if (U) {
        let be = -1;
        for (ue = _; ue < z; ue++)
          if (ce(C, ue) === ce(w, be === -1 ? 0 : ue - be)) {
            if (be === -1 && (be = ue), ue - be + 1 === de) return be * V;
          } else
            be !== -1 && (ue -= ue - be), be = -1;
      } else
        for (_ + de > z && (_ = z - de), ue = _; ue >= 0; ue--) {
          let be = !0;
          for (let se = 0; se < de; se++)
            if (ce(C, ue + se) !== ce(w, se)) {
              be = !1;
              break;
            }
          if (be) return ue;
        }
      return -1;
    }
    o.prototype.includes = function(w, _, L) {
      return this.indexOf(w, _, L) !== -1;
    }, o.prototype.indexOf = function(w, _, L) {
      return q(this, w, _, L, !0);
    }, o.prototype.lastIndexOf = function(w, _, L) {
      return q(this, w, _, L, !1);
    };
    function H(C, w, _, L) {
      _ = Number(_) || 0;
      const U = C.length - _;
      L ? (L = Number(L), L > U && (L = U)) : L = U;
      const V = w.length;
      L > V / 2 && (L = V / 2);
      let z;
      for (z = 0; z < L; ++z) {
        const de = parseInt(w.substr(z * 2, 2), 16);
        if (pe(de)) return z;
        C[_ + z] = de;
      }
      return z;
    }
    function G(C, w, _, L) {
      return he(ne(w, C.length - _), C, _, L);
    }
    function ee(C, w, _, L) {
      return he(fe(w), C, _, L);
    }
    function Y(C, w, _, L) {
      return he(me(w), C, _, L);
    }
    function re(C, w, _, L) {
      return he(He(w, C.length - _), C, _, L);
    }
    o.prototype.write = function(w, _, L, U) {
      if (_ === void 0)
        U = "utf8", L = this.length, _ = 0;
      else if (L === void 0 && typeof _ == "string")
        U = _, L = this.length, _ = 0;
      else if (isFinite(_))
        _ = _ >>> 0, isFinite(L) ? (L = L >>> 0, U === void 0 && (U = "utf8")) : (U = L, L = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const V = this.length - _;
      if ((L === void 0 || L > V) && (L = V), w.length > 0 && (L < 0 || _ < 0) || _ > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      U || (U = "utf8");
      let z = !1;
      for (; ; )
        switch (U) {
          case "hex":
            return H(this, w, _, L);
          case "utf8":
          case "utf-8":
            return G(this, w, _, L);
          case "ascii":
          case "latin1":
          case "binary":
            return ee(this, w, _, L);
          case "base64":
            return Y(this, w, _, L);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return re(this, w, _, L);
          default:
            if (z) throw new TypeError("Unknown encoding: " + U);
            U = ("" + U).toLowerCase(), z = !0;
        }
    }, o.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function F(C, w, _) {
      return w === 0 && _ === C.length ? r.fromByteArray(C) : r.fromByteArray(C.slice(w, _));
    }
    function l(C, w, _) {
      _ = Math.min(C.length, _);
      const L = [];
      let U = w;
      for (; U < _; ) {
        const V = C[U];
        let z = null, de = V > 239 ? 4 : V > 223 ? 3 : V > 191 ? 2 : 1;
        if (U + de <= _) {
          let ce, ue, be, se;
          switch (de) {
            case 1:
              V < 128 && (z = V);
              break;
            case 2:
              ce = C[U + 1], (ce & 192) === 128 && (se = (V & 31) << 6 | ce & 63, se > 127 && (z = se));
              break;
            case 3:
              ce = C[U + 1], ue = C[U + 2], (ce & 192) === 128 && (ue & 192) === 128 && (se = (V & 15) << 12 | (ce & 63) << 6 | ue & 63, se > 2047 && (se < 55296 || se > 57343) && (z = se));
              break;
            case 4:
              ce = C[U + 1], ue = C[U + 2], be = C[U + 3], (ce & 192) === 128 && (ue & 192) === 128 && (be & 192) === 128 && (se = (V & 15) << 18 | (ce & 63) << 12 | (ue & 63) << 6 | be & 63, se > 65535 && se < 1114112 && (z = se));
          }
        }
        z === null ? (z = 65533, de = 1) : z > 65535 && (z -= 65536, L.push(z >>> 10 & 1023 | 55296), z = 56320 | z & 1023), L.push(z), U += de;
      }
      return M(L);
    }
    const E = 4096;
    function M(C) {
      const w = C.length;
      if (w <= E)
        return String.fromCharCode.apply(String, C);
      let _ = "", L = 0;
      for (; L < w; )
        _ += String.fromCharCode.apply(
          String,
          C.slice(L, L += E)
        );
      return _;
    }
    function k(C, w, _) {
      let L = "";
      _ = Math.min(C.length, _);
      for (let U = w; U < _; ++U)
        L += String.fromCharCode(C[U] & 127);
      return L;
    }
    function x(C, w, _) {
      let L = "";
      _ = Math.min(C.length, _);
      for (let U = w; U < _; ++U)
        L += String.fromCharCode(C[U]);
      return L;
    }
    function B(C, w, _) {
      const L = C.length;
      (!w || w < 0) && (w = 0), (!_ || _ < 0 || _ > L) && (_ = L);
      let U = "";
      for (let V = w; V < _; ++V)
        U += we[C[V]];
      return U;
    }
    function j(C, w, _) {
      const L = C.slice(w, _);
      let U = "";
      for (let V = 0; V < L.length - 1; V += 2)
        U += String.fromCharCode(L[V] + L[V + 1] * 256);
      return U;
    }
    o.prototype.slice = function(w, _) {
      const L = this.length;
      w = ~~w, _ = _ === void 0 ? L : ~~_, w < 0 ? (w += L, w < 0 && (w = 0)) : w > L && (w = L), _ < 0 ? (_ += L, _ < 0 && (_ = 0)) : _ > L && (_ = L), _ < w && (_ = w);
      const U = this.subarray(w, _);
      return Object.setPrototypeOf(U, o.prototype), U;
    };
    function A(C, w, _) {
      if (C % 1 !== 0 || C < 0) throw new RangeError("offset is not uint");
      if (C + w > _) throw new RangeError("Trying to access beyond buffer length");
    }
    o.prototype.readUintLE = o.prototype.readUIntLE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = this[w], V = 1, z = 0;
      for (; ++z < _ && (V *= 256); )
        U += this[w + z] * V;
      return U;
    }, o.prototype.readUintBE = o.prototype.readUIntBE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = this[w + --_], V = 1;
      for (; _ > 0 && (V *= 256); )
        U += this[w + --_] * V;
      return U;
    }, o.prototype.readUint8 = o.prototype.readUInt8 = function(w, _) {
      return w = w >>> 0, _ || A(w, 1, this.length), this[w];
    }, o.prototype.readUint16LE = o.prototype.readUInt16LE = function(w, _) {
      return w = w >>> 0, _ || A(w, 2, this.length), this[w] | this[w + 1] << 8;
    }, o.prototype.readUint16BE = o.prototype.readUInt16BE = function(w, _) {
      return w = w >>> 0, _ || A(w, 2, this.length), this[w] << 8 | this[w + 1];
    }, o.prototype.readUint32LE = o.prototype.readUInt32LE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), (this[w] | this[w + 1] << 8 | this[w + 2] << 16) + this[w + 3] * 16777216;
    }, o.prototype.readUint32BE = o.prototype.readUInt32BE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), this[w] * 16777216 + (this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3]);
    }, o.prototype.readBigUInt64LE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = _ + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24, V = this[++w] + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + L * 2 ** 24;
      return BigInt(U) + (BigInt(V) << BigInt(32));
    }), o.prototype.readBigUInt64BE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = _ * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w], V = this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + L;
      return (BigInt(U) << BigInt(32)) + BigInt(V);
    }), o.prototype.readIntLE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = this[w], V = 1, z = 0;
      for (; ++z < _ && (V *= 256); )
        U += this[w + z] * V;
      return V *= 128, U >= V && (U -= Math.pow(2, 8 * _)), U;
    }, o.prototype.readIntBE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = _, V = 1, z = this[w + --U];
      for (; U > 0 && (V *= 256); )
        z += this[w + --U] * V;
      return V *= 128, z >= V && (z -= Math.pow(2, 8 * _)), z;
    }, o.prototype.readInt8 = function(w, _) {
      return w = w >>> 0, _ || A(w, 1, this.length), this[w] & 128 ? (255 - this[w] + 1) * -1 : this[w];
    }, o.prototype.readInt16LE = function(w, _) {
      w = w >>> 0, _ || A(w, 2, this.length);
      const L = this[w] | this[w + 1] << 8;
      return L & 32768 ? L | 4294901760 : L;
    }, o.prototype.readInt16BE = function(w, _) {
      w = w >>> 0, _ || A(w, 2, this.length);
      const L = this[w + 1] | this[w] << 8;
      return L & 32768 ? L | 4294901760 : L;
    }, o.prototype.readInt32LE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), this[w] | this[w + 1] << 8 | this[w + 2] << 16 | this[w + 3] << 24;
    }, o.prototype.readInt32BE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), this[w] << 24 | this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3];
    }, o.prototype.readBigInt64LE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = this[w + 4] + this[w + 5] * 2 ** 8 + this[w + 6] * 2 ** 16 + (L << 24);
      return (BigInt(U) << BigInt(32)) + BigInt(_ + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24);
    }), o.prototype.readBigInt64BE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = (_ << 24) + // Overflow
      this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w];
      return (BigInt(U) << BigInt(32)) + BigInt(this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + L);
    }), o.prototype.readFloatLE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), i.read(this, w, !0, 23, 4);
    }, o.prototype.readFloatBE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), i.read(this, w, !1, 23, 4);
    }, o.prototype.readDoubleLE = function(w, _) {
      return w = w >>> 0, _ || A(w, 8, this.length), i.read(this, w, !0, 52, 8);
    }, o.prototype.readDoubleBE = function(w, _) {
      return w = w >>> 0, _ || A(w, 8, this.length), i.read(this, w, !1, 52, 8);
    };
    function y(C, w, _, L, U, V) {
      if (!o.isBuffer(C)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (w > U || w < V) throw new RangeError('"value" argument is out of bounds');
      if (_ + L > C.length) throw new RangeError("Index out of range");
    }
    o.prototype.writeUintLE = o.prototype.writeUIntLE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, L = L >>> 0, !U) {
        const de = Math.pow(2, 8 * L) - 1;
        y(this, w, _, L, de, 0);
      }
      let V = 1, z = 0;
      for (this[_] = w & 255; ++z < L && (V *= 256); )
        this[_ + z] = w / V & 255;
      return _ + L;
    }, o.prototype.writeUintBE = o.prototype.writeUIntBE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, L = L >>> 0, !U) {
        const de = Math.pow(2, 8 * L) - 1;
        y(this, w, _, L, de, 0);
      }
      let V = L - 1, z = 1;
      for (this[_ + V] = w & 255; --V >= 0 && (z *= 256); )
        this[_ + V] = w / z & 255;
      return _ + L;
    }, o.prototype.writeUint8 = o.prototype.writeUInt8 = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 1, 255, 0), this[_] = w & 255, _ + 1;
    }, o.prototype.writeUint16LE = o.prototype.writeUInt16LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 2, 65535, 0), this[_] = w & 255, this[_ + 1] = w >>> 8, _ + 2;
    }, o.prototype.writeUint16BE = o.prototype.writeUInt16BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 2, 65535, 0), this[_] = w >>> 8, this[_ + 1] = w & 255, _ + 2;
    }, o.prototype.writeUint32LE = o.prototype.writeUInt32LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 4, 4294967295, 0), this[_ + 3] = w >>> 24, this[_ + 2] = w >>> 16, this[_ + 1] = w >>> 8, this[_] = w & 255, _ + 4;
    }, o.prototype.writeUint32BE = o.prototype.writeUInt32BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 4, 4294967295, 0), this[_] = w >>> 24, this[_ + 1] = w >>> 16, this[_ + 2] = w >>> 8, this[_ + 3] = w & 255, _ + 4;
    };
    function N(C, w, _, L, U) {
      O(w, L, U, C, _, 7);
      let V = Number(w & BigInt(4294967295));
      C[_++] = V, V = V >> 8, C[_++] = V, V = V >> 8, C[_++] = V, V = V >> 8, C[_++] = V;
      let z = Number(w >> BigInt(32) & BigInt(4294967295));
      return C[_++] = z, z = z >> 8, C[_++] = z, z = z >> 8, C[_++] = z, z = z >> 8, C[_++] = z, _;
    }
    function te(C, w, _, L, U) {
      O(w, L, U, C, _, 7);
      let V = Number(w & BigInt(4294967295));
      C[_ + 7] = V, V = V >> 8, C[_ + 6] = V, V = V >> 8, C[_ + 5] = V, V = V >> 8, C[_ + 4] = V;
      let z = Number(w >> BigInt(32) & BigInt(4294967295));
      return C[_ + 3] = z, z = z >> 8, C[_ + 2] = z, z = z >> 8, C[_ + 1] = z, z = z >> 8, C[_] = z, _ + 8;
    }
    o.prototype.writeBigUInt64LE = je(function(w, _ = 0) {
      return N(this, w, _, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeBigUInt64BE = je(function(w, _ = 0) {
      return te(this, w, _, BigInt(0), BigInt("0xffffffffffffffff"));
    }), o.prototype.writeIntLE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, !U) {
        const ce = Math.pow(2, 8 * L - 1);
        y(this, w, _, L, ce - 1, -ce);
      }
      let V = 0, z = 1, de = 0;
      for (this[_] = w & 255; ++V < L && (z *= 256); )
        w < 0 && de === 0 && this[_ + V - 1] !== 0 && (de = 1), this[_ + V] = (w / z >> 0) - de & 255;
      return _ + L;
    }, o.prototype.writeIntBE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, !U) {
        const ce = Math.pow(2, 8 * L - 1);
        y(this, w, _, L, ce - 1, -ce);
      }
      let V = L - 1, z = 1, de = 0;
      for (this[_ + V] = w & 255; --V >= 0 && (z *= 256); )
        w < 0 && de === 0 && this[_ + V + 1] !== 0 && (de = 1), this[_ + V] = (w / z >> 0) - de & 255;
      return _ + L;
    }, o.prototype.writeInt8 = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 1, 127, -128), w < 0 && (w = 255 + w + 1), this[_] = w & 255, _ + 1;
    }, o.prototype.writeInt16LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 2, 32767, -32768), this[_] = w & 255, this[_ + 1] = w >>> 8, _ + 2;
    }, o.prototype.writeInt16BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 2, 32767, -32768), this[_] = w >>> 8, this[_ + 1] = w & 255, _ + 2;
    }, o.prototype.writeInt32LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 4, 2147483647, -2147483648), this[_] = w & 255, this[_ + 1] = w >>> 8, this[_ + 2] = w >>> 16, this[_ + 3] = w >>> 24, _ + 4;
    }, o.prototype.writeInt32BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || y(this, w, _, 4, 2147483647, -2147483648), w < 0 && (w = 4294967295 + w + 1), this[_] = w >>> 24, this[_ + 1] = w >>> 16, this[_ + 2] = w >>> 8, this[_ + 3] = w & 255, _ + 4;
    }, o.prototype.writeBigInt64LE = je(function(w, _ = 0) {
      return N(this, w, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), o.prototype.writeBigInt64BE = je(function(w, _ = 0) {
      return te(this, w, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function K(C, w, _, L, U, V) {
      if (_ + L > C.length) throw new RangeError("Index out of range");
      if (_ < 0) throw new RangeError("Index out of range");
    }
    function $(C, w, _, L, U) {
      return w = +w, _ = _ >>> 0, U || K(C, w, _, 4), i.write(C, w, _, L, 23, 4), _ + 4;
    }
    o.prototype.writeFloatLE = function(w, _, L) {
      return $(this, w, _, !0, L);
    }, o.prototype.writeFloatBE = function(w, _, L) {
      return $(this, w, _, !1, L);
    };
    function W(C, w, _, L, U) {
      return w = +w, _ = _ >>> 0, U || K(C, w, _, 8), i.write(C, w, _, L, 52, 8), _ + 8;
    }
    o.prototype.writeDoubleLE = function(w, _, L) {
      return W(this, w, _, !0, L);
    }, o.prototype.writeDoubleBE = function(w, _, L) {
      return W(this, w, _, !1, L);
    }, o.prototype.copy = function(w, _, L, U) {
      if (!o.isBuffer(w)) throw new TypeError("argument should be a Buffer");
      if (L || (L = 0), !U && U !== 0 && (U = this.length), _ >= w.length && (_ = w.length), _ || (_ = 0), U > 0 && U < L && (U = L), U === L || w.length === 0 || this.length === 0) return 0;
      if (_ < 0)
        throw new RangeError("targetStart out of bounds");
      if (L < 0 || L >= this.length) throw new RangeError("Index out of range");
      if (U < 0) throw new RangeError("sourceEnd out of bounds");
      U > this.length && (U = this.length), w.length - _ < U - L && (U = w.length - _ + L);
      const V = U - L;
      return this === w && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(_, L, U) : Uint8Array.prototype.set.call(
        w,
        this.subarray(L, U),
        _
      ), V;
    }, o.prototype.fill = function(w, _, L, U) {
      if (typeof w == "string") {
        if (typeof _ == "string" ? (U = _, _ = 0, L = this.length) : typeof L == "string" && (U = L, L = this.length), U !== void 0 && typeof U != "string")
          throw new TypeError("encoding must be a string");
        if (typeof U == "string" && !o.isEncoding(U))
          throw new TypeError("Unknown encoding: " + U);
        if (w.length === 1) {
          const z = w.charCodeAt(0);
          (U === "utf8" && z < 128 || U === "latin1") && (w = z);
        }
      } else typeof w == "number" ? w = w & 255 : typeof w == "boolean" && (w = Number(w));
      if (_ < 0 || this.length < _ || this.length < L)
        throw new RangeError("Out of range index");
      if (L <= _)
        return this;
      _ = _ >>> 0, L = L === void 0 ? this.length : L >>> 0, w || (w = 0);
      let V;
      if (typeof w == "number")
        for (V = _; V < L; ++V)
          this[V] = w;
      else {
        const z = o.isBuffer(w) ? w : o.from(w, U), de = z.length;
        if (de === 0)
          throw new TypeError('The value "' + w + '" is invalid for argument "value"');
        for (V = 0; V < L - _; ++V)
          this[V + _] = z[V % de];
      }
      return this;
    };
    const J = {};
    function X(C, w, _) {
      J[C] = class extends _ {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: w.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${C}]`, this.stack, delete this.name;
        }
        get code() {
          return C;
        }
        set code(U) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: U,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${C}]: ${this.message}`;
        }
      };
    }
    X(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(C) {
        return C ? `${C} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), X(
      "ERR_INVALID_ARG_TYPE",
      function(C, w) {
        return `The "${C}" argument must be of type number. Received type ${typeof w}`;
      },
      TypeError
    ), X(
      "ERR_OUT_OF_RANGE",
      function(C, w, _) {
        let L = `The value of "${C}" is out of range.`, U = _;
        return Number.isInteger(_) && Math.abs(_) > 2 ** 32 ? U = oe(String(_)) : typeof _ == "bigint" && (U = String(_), (_ > BigInt(2) ** BigInt(32) || _ < -(BigInt(2) ** BigInt(32))) && (U = oe(U)), U += "n"), L += ` It must be ${w}. Received ${U}`, L;
      },
      RangeError
    );
    function oe(C) {
      let w = "", _ = C.length;
      const L = C[0] === "-" ? 1 : 0;
      for (; _ >= L + 4; _ -= 3)
        w = `_${C.slice(_ - 3, _)}${w}`;
      return `${C.slice(0, _)}${w}`;
    }
    function P(C, w, _) {
      Z(w, "offset"), (C[w] === void 0 || C[w + _] === void 0) && Q(w, C.length - (_ + 1));
    }
    function O(C, w, _, L, U, V) {
      if (C > _ || C < w) {
        const z = typeof w == "bigint" ? "n" : "";
        let de;
        throw w === 0 || w === BigInt(0) ? de = `>= 0${z} and < 2${z} ** ${(V + 1) * 8}${z}` : de = `>= -(2${z} ** ${(V + 1) * 8 - 1}${z}) and < 2 ** ${(V + 1) * 8 - 1}${z}`, new J.ERR_OUT_OF_RANGE("value", de, C);
      }
      P(L, U, V);
    }
    function Z(C, w) {
      if (typeof C != "number")
        throw new J.ERR_INVALID_ARG_TYPE(w, "number", C);
    }
    function Q(C, w, _) {
      throw Math.floor(C) !== C ? (Z(C, _), new J.ERR_OUT_OF_RANGE("offset", "an integer", C)) : w < 0 ? new J.ERR_BUFFER_OUT_OF_BOUNDS() : new J.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${w}`,
        C
      );
    }
    const ae = /[^+/0-9A-Za-z-_]/g;
    function le(C) {
      if (C = C.split("=")[0], C = C.trim().replace(ae, ""), C.length < 2) return "";
      for (; C.length % 4 !== 0; )
        C = C + "=";
      return C;
    }
    function ne(C, w) {
      w = w || 1 / 0;
      let _;
      const L = C.length;
      let U = null;
      const V = [];
      for (let z = 0; z < L; ++z) {
        if (_ = C.charCodeAt(z), _ > 55295 && _ < 57344) {
          if (!U) {
            if (_ > 56319) {
              (w -= 3) > -1 && V.push(239, 191, 189);
              continue;
            } else if (z + 1 === L) {
              (w -= 3) > -1 && V.push(239, 191, 189);
              continue;
            }
            U = _;
            continue;
          }
          if (_ < 56320) {
            (w -= 3) > -1 && V.push(239, 191, 189), U = _;
            continue;
          }
          _ = (U - 55296 << 10 | _ - 56320) + 65536;
        } else U && (w -= 3) > -1 && V.push(239, 191, 189);
        if (U = null, _ < 128) {
          if ((w -= 1) < 0) break;
          V.push(_);
        } else if (_ < 2048) {
          if ((w -= 2) < 0) break;
          V.push(
            _ >> 6 | 192,
            _ & 63 | 128
          );
        } else if (_ < 65536) {
          if ((w -= 3) < 0) break;
          V.push(
            _ >> 12 | 224,
            _ >> 6 & 63 | 128,
            _ & 63 | 128
          );
        } else if (_ < 1114112) {
          if ((w -= 4) < 0) break;
          V.push(
            _ >> 18 | 240,
            _ >> 12 & 63 | 128,
            _ >> 6 & 63 | 128,
            _ & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return V;
    }
    function fe(C) {
      const w = [];
      for (let _ = 0; _ < C.length; ++_)
        w.push(C.charCodeAt(_) & 255);
      return w;
    }
    function He(C, w) {
      let _, L, U;
      const V = [];
      for (let z = 0; z < C.length && !((w -= 2) < 0); ++z)
        _ = C.charCodeAt(z), L = _ >> 8, U = _ % 256, V.push(U), V.push(L);
      return V;
    }
    function me(C) {
      return r.toByteArray(le(C));
    }
    function he(C, w, _, L) {
      let U;
      for (U = 0; U < L && !(U + _ >= w.length || U >= C.length); ++U)
        w[U + _] = C[U];
      return U;
    }
    function ve(C, w) {
      return C instanceof w || C != null && C.constructor != null && C.constructor.name != null && C.constructor.name === w.name;
    }
    function pe(C) {
      return C !== C;
    }
    const we = function() {
      const C = "0123456789abcdef", w = new Array(256);
      for (let _ = 0; _ < 16; ++_) {
        const L = _ * 16;
        for (let U = 0; U < 16; ++U)
          w[L + U] = C[_] + C[U];
      }
      return w;
    }();
    function je(C) {
      return typeof BigInt > "u" ? ye : C;
    }
    function ye() {
      throw new Error("BigInt not supported");
    }
  }(Ln)), Ln;
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Eo;
function st() {
  return Eo || (Eo = 1, function(e, r) {
    var i = mn(), t = i.Buffer;
    function p(u, o) {
      for (var d in u)
        o[d] = u[d];
    }
    t.from && t.alloc && t.allocUnsafe && t.allocUnsafeSlow ? e.exports = i : (p(i, r), r.Buffer = n);
    function n(u, o, d) {
      return t(u, o, d);
    }
    n.prototype = Object.create(t.prototype), p(t, n), n.from = function(u, o, d) {
      if (typeof u == "number")
        throw new TypeError("Argument must not be a number");
      return t(u, o, d);
    }, n.alloc = function(u, o, d) {
      if (typeof u != "number")
        throw new TypeError("Argument must be a number");
      var m = t(u);
      return o !== void 0 ? typeof d == "string" ? m.fill(o, d) : m.fill(o) : m.fill(0), m;
    }, n.allocUnsafe = function(u) {
      if (typeof u != "number")
        throw new TypeError("Argument must be a number");
      return t(u);
    }, n.allocUnsafeSlow = function(u) {
      if (typeof u != "number")
        throw new TypeError("Argument must be a number");
      return i.SlowBuffer(u);
    };
  }(Jr, Jr.exports)), Jr.exports;
}
var Bn, Ro;
function Qt() {
  if (Ro) return Bn;
  Ro = 1;
  var e = st().Buffer;
  function r(i, t) {
    this._block = e.alloc(i), this._finalSize = t, this._blockSize = i, this._len = 0;
  }
  return r.prototype.update = function(i, t) {
    typeof i == "string" && (t = t || "utf8", i = e.from(i, t));
    for (var p = this._block, n = this._blockSize, u = i.length, o = this._len, d = 0; d < u; ) {
      for (var m = o % n, g = Math.min(u - d, n - m), c = 0; c < g; c++)
        p[m + c] = i[d + c];
      o += g, d += g, o % n === 0 && this._update(p);
    }
    return this._len += u, this;
  }, r.prototype.digest = function(i) {
    var t = this._len % this._blockSize;
    this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var p = this._len * 8;
    if (p <= 4294967295)
      this._block.writeUInt32BE(p, this._blockSize - 4);
    else {
      var n = (p & 4294967295) >>> 0, u = (p - n) / 4294967296;
      this._block.writeUInt32BE(u, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
    }
    this._update(this._block);
    var o = this._hash();
    return i ? o.toString(i) : o;
  }, r.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, Bn = r, Bn;
}
var Nn, So;
function jl() {
  if (So) return Nn;
  So = 1;
  var e = Qe(), r = Qt(), i = st().Buffer, t = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], p = new Array(80);
  function n() {
    this.init(), this._w = p, r.call(this, 64, 56);
  }
  e(n, r), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function u(m) {
    return m << 5 | m >>> 27;
  }
  function o(m) {
    return m << 30 | m >>> 2;
  }
  function d(m, g, c, h) {
    return m === 0 ? g & c | ~g & h : m === 2 ? g & c | g & h | c & h : g ^ c ^ h;
  }
  return n.prototype._update = function(m) {
    for (var g = this._w, c = this._a | 0, h = this._b | 0, s = this._c | 0, f = this._d | 0, b = this._e | 0, v = 0; v < 16; ++v) g[v] = m.readInt32BE(v * 4);
    for (; v < 80; ++v) g[v] = g[v - 3] ^ g[v - 8] ^ g[v - 14] ^ g[v - 16];
    for (var a = 0; a < 80; ++a) {
      var R = ~~(a / 20), S = u(c) + d(R, h, s, f) + b + g[a] + t[R] | 0;
      b = f, f = s, s = o(h), h = c, c = S;
    }
    this._a = c + this._a | 0, this._b = h + this._b | 0, this._c = s + this._c | 0, this._d = f + this._d | 0, this._e = b + this._e | 0;
  }, n.prototype._hash = function() {
    var m = i.allocUnsafe(20);
    return m.writeInt32BE(this._a | 0, 0), m.writeInt32BE(this._b | 0, 4), m.writeInt32BE(this._c | 0, 8), m.writeInt32BE(this._d | 0, 12), m.writeInt32BE(this._e | 0, 16), m;
  }, Nn = n, Nn;
}
var Pn, Mo;
function $l() {
  if (Mo) return Pn;
  Mo = 1;
  var e = Qe(), r = Qt(), i = st().Buffer, t = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], p = new Array(80);
  function n() {
    this.init(), this._w = p, r.call(this, 64, 56);
  }
  e(n, r), n.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function u(g) {
    return g << 1 | g >>> 31;
  }
  function o(g) {
    return g << 5 | g >>> 27;
  }
  function d(g) {
    return g << 30 | g >>> 2;
  }
  function m(g, c, h, s) {
    return g === 0 ? c & h | ~c & s : g === 2 ? c & h | c & s | h & s : c ^ h ^ s;
  }
  return n.prototype._update = function(g) {
    for (var c = this._w, h = this._a | 0, s = this._b | 0, f = this._c | 0, b = this._d | 0, v = this._e | 0, a = 0; a < 16; ++a) c[a] = g.readInt32BE(a * 4);
    for (; a < 80; ++a) c[a] = u(c[a - 3] ^ c[a - 8] ^ c[a - 14] ^ c[a - 16]);
    for (var R = 0; R < 80; ++R) {
      var S = ~~(R / 20), I = o(h) + m(S, s, f, b) + v + c[R] + t[S] | 0;
      v = b, b = f, f = d(s), s = h, h = I;
    }
    this._a = h + this._a | 0, this._b = s + this._b | 0, this._c = f + this._c | 0, this._d = b + this._d | 0, this._e = v + this._e | 0;
  }, n.prototype._hash = function() {
    var g = i.allocUnsafe(20);
    return g.writeInt32BE(this._a | 0, 0), g.writeInt32BE(this._b | 0, 4), g.writeInt32BE(this._c | 0, 8), g.writeInt32BE(this._d | 0, 12), g.writeInt32BE(this._e | 0, 16), g;
  }, Pn = n, Pn;
}
var On, ko;
function qc() {
  if (ko) return On;
  ko = 1;
  var e = Qe(), r = Qt(), i = st().Buffer, t = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], p = new Array(64);
  function n() {
    this.init(), this._w = p, r.call(this, 64, 56);
  }
  e(n, r), n.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function u(h, s, f) {
    return f ^ h & (s ^ f);
  }
  function o(h, s, f) {
    return h & s | f & (h | s);
  }
  function d(h) {
    return (h >>> 2 | h << 30) ^ (h >>> 13 | h << 19) ^ (h >>> 22 | h << 10);
  }
  function m(h) {
    return (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);
  }
  function g(h) {
    return (h >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3;
  }
  function c(h) {
    return (h >>> 17 | h << 15) ^ (h >>> 19 | h << 13) ^ h >>> 10;
  }
  return n.prototype._update = function(h) {
    for (var s = this._w, f = this._a | 0, b = this._b | 0, v = this._c | 0, a = this._d | 0, R = this._e | 0, S = this._f | 0, I = this._g | 0, T = this._h | 0, q = 0; q < 16; ++q) s[q] = h.readInt32BE(q * 4);
    for (; q < 64; ++q) s[q] = c(s[q - 2]) + s[q - 7] + g(s[q - 15]) + s[q - 16] | 0;
    for (var D = 0; D < 64; ++D) {
      var H = T + m(R) + u(R, S, I) + t[D] + s[D] | 0, G = d(f) + o(f, b, v) | 0;
      T = I, I = S, S = R, R = a + H | 0, a = v, v = b, b = f, f = H + G | 0;
    }
    this._a = f + this._a | 0, this._b = b + this._b | 0, this._c = v + this._c | 0, this._d = a + this._d | 0, this._e = R + this._e | 0, this._f = S + this._f | 0, this._g = I + this._g | 0, this._h = T + this._h | 0;
  }, n.prototype._hash = function() {
    var h = i.allocUnsafe(32);
    return h.writeInt32BE(this._a, 0), h.writeInt32BE(this._b, 4), h.writeInt32BE(this._c, 8), h.writeInt32BE(this._d, 12), h.writeInt32BE(this._e, 16), h.writeInt32BE(this._f, 20), h.writeInt32BE(this._g, 24), h.writeInt32BE(this._h, 28), h;
  }, On = n, On;
}
var Fn, Co;
function Ul() {
  if (Co) return Fn;
  Co = 1;
  var e = Qe(), r = qc(), i = Qt(), t = st().Buffer, p = new Array(64);
  function n() {
    this.init(), this._w = p, i.call(this, 64, 56);
  }
  return e(n, r), n.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, n.prototype._hash = function() {
    var u = t.allocUnsafe(28);
    return u.writeInt32BE(this._a, 0), u.writeInt32BE(this._b, 4), u.writeInt32BE(this._c, 8), u.writeInt32BE(this._d, 12), u.writeInt32BE(this._e, 16), u.writeInt32BE(this._f, 20), u.writeInt32BE(this._g, 24), u;
  }, Fn = n, Fn;
}
var Dn, Io;
function jc() {
  if (Io) return Dn;
  Io = 1;
  var e = Qe(), r = Qt(), i = st().Buffer, t = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], p = new Array(160);
  function n() {
    this.init(), this._w = p, r.call(this, 128, 112);
  }
  e(n, r), n.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function u(b, v, a) {
    return a ^ b & (v ^ a);
  }
  function o(b, v, a) {
    return b & v | a & (b | v);
  }
  function d(b, v) {
    return (b >>> 28 | v << 4) ^ (v >>> 2 | b << 30) ^ (v >>> 7 | b << 25);
  }
  function m(b, v) {
    return (b >>> 14 | v << 18) ^ (b >>> 18 | v << 14) ^ (v >>> 9 | b << 23);
  }
  function g(b, v) {
    return (b >>> 1 | v << 31) ^ (b >>> 8 | v << 24) ^ b >>> 7;
  }
  function c(b, v) {
    return (b >>> 1 | v << 31) ^ (b >>> 8 | v << 24) ^ (b >>> 7 | v << 25);
  }
  function h(b, v) {
    return (b >>> 19 | v << 13) ^ (v >>> 29 | b << 3) ^ b >>> 6;
  }
  function s(b, v) {
    return (b >>> 19 | v << 13) ^ (v >>> 29 | b << 3) ^ (b >>> 6 | v << 26);
  }
  function f(b, v) {
    return b >>> 0 < v >>> 0 ? 1 : 0;
  }
  return n.prototype._update = function(b) {
    for (var v = this._w, a = this._ah | 0, R = this._bh | 0, S = this._ch | 0, I = this._dh | 0, T = this._eh | 0, q = this._fh | 0, D = this._gh | 0, H = this._hh | 0, G = this._al | 0, ee = this._bl | 0, Y = this._cl | 0, re = this._dl | 0, F = this._el | 0, l = this._fl | 0, E = this._gl | 0, M = this._hl | 0, k = 0; k < 32; k += 2)
      v[k] = b.readInt32BE(k * 4), v[k + 1] = b.readInt32BE(k * 4 + 4);
    for (; k < 160; k += 2) {
      var x = v[k - 30], B = v[k - 15 * 2 + 1], j = g(x, B), A = c(B, x);
      x = v[k - 2 * 2], B = v[k - 2 * 2 + 1];
      var y = h(x, B), N = s(B, x), te = v[k - 7 * 2], K = v[k - 7 * 2 + 1], $ = v[k - 16 * 2], W = v[k - 16 * 2 + 1], J = A + K | 0, X = j + te + f(J, A) | 0;
      J = J + N | 0, X = X + y + f(J, N) | 0, J = J + W | 0, X = X + $ + f(J, W) | 0, v[k] = X, v[k + 1] = J;
    }
    for (var oe = 0; oe < 160; oe += 2) {
      X = v[oe], J = v[oe + 1];
      var P = o(a, R, S), O = o(G, ee, Y), Z = d(a, G), Q = d(G, a), ae = m(T, F), le = m(F, T), ne = t[oe], fe = t[oe + 1], He = u(T, q, D), me = u(F, l, E), he = M + le | 0, ve = H + ae + f(he, M) | 0;
      he = he + me | 0, ve = ve + He + f(he, me) | 0, he = he + fe | 0, ve = ve + ne + f(he, fe) | 0, he = he + J | 0, ve = ve + X + f(he, J) | 0;
      var pe = Q + O | 0, we = Z + P + f(pe, Q) | 0;
      H = D, M = E, D = q, E = l, q = T, l = F, F = re + he | 0, T = I + ve + f(F, re) | 0, I = S, re = Y, S = R, Y = ee, R = a, ee = G, G = he + pe | 0, a = ve + we + f(G, he) | 0;
    }
    this._al = this._al + G | 0, this._bl = this._bl + ee | 0, this._cl = this._cl + Y | 0, this._dl = this._dl + re | 0, this._el = this._el + F | 0, this._fl = this._fl + l | 0, this._gl = this._gl + E | 0, this._hl = this._hl + M | 0, this._ah = this._ah + a + f(this._al, G) | 0, this._bh = this._bh + R + f(this._bl, ee) | 0, this._ch = this._ch + S + f(this._cl, Y) | 0, this._dh = this._dh + I + f(this._dl, re) | 0, this._eh = this._eh + T + f(this._el, F) | 0, this._fh = this._fh + q + f(this._fl, l) | 0, this._gh = this._gh + D + f(this._gl, E) | 0, this._hh = this._hh + H + f(this._hl, M) | 0;
  }, n.prototype._hash = function() {
    var b = i.allocUnsafe(64);
    function v(a, R, S) {
      b.writeInt32BE(a, S), b.writeInt32BE(R, S + 4);
    }
    return v(this._ah, this._al, 0), v(this._bh, this._bl, 8), v(this._ch, this._cl, 16), v(this._dh, this._dl, 24), v(this._eh, this._el, 32), v(this._fh, this._fl, 40), v(this._gh, this._gl, 48), v(this._hh, this._hl, 56), b;
  }, Dn = n, Dn;
}
var qn, xo;
function Hl() {
  if (xo) return qn;
  xo = 1;
  var e = Qe(), r = jc(), i = Qt(), t = st().Buffer, p = new Array(160);
  function n() {
    this.init(), this._w = p, i.call(this, 128, 112);
  }
  return e(n, r), n.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, n.prototype._hash = function() {
    var u = t.allocUnsafe(48);
    function o(d, m, g) {
      u.writeInt32BE(d, g), u.writeInt32BE(m, g + 4);
    }
    return o(this._ah, this._al, 0), o(this._bh, this._bl, 8), o(this._ch, this._cl, 16), o(this._dh, this._dl, 24), o(this._eh, this._el, 32), o(this._fh, this._fl, 40), u;
  }, qn = n, qn;
}
var Ao;
function Wl() {
  if (Ao) return Tn.exports;
  Ao = 1;
  var e = Tn.exports = function(i) {
    i = i.toLowerCase();
    var t = e[i];
    if (!t) throw new Error(i + " is not supported (we accept pull requests)");
    return new t();
  };
  return e.sha = jl(), e.sha1 = $l(), e.sha224 = Ul(), e.sha256 = qc(), e.sha384 = Hl(), e.sha512 = jc(), Tn.exports;
}
var To;
function Ds() {
  if (To) return dr;
  To = 1, Object.defineProperty(dr, "__esModule", { value: !0 }), dr.Session = void 0;
  const e = Wl(), r = /* @__PURE__ */ tt(), i = "session:id", t = "session:secret", p = "session:linked";
  let n = class $c {
    constructor(o, d, m, g) {
      this._storage = o, this._id = d || (0, r.randomBytesHex)(16), this._secret = m || (0, r.randomBytesHex)(32), this._key = new e.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex"), this._linked = !!g;
    }
    static load(o) {
      const d = o.getItem(i), m = o.getItem(p), g = o.getItem(t);
      return d && g ? new $c(o, d, g, m === "1") : null;
    }
    /**
     * Takes in a session ID and returns the sha256 hash of it.
     * @param sessionId session ID
     */
    static hash(o) {
      return new e.sha256().update(o).digest("hex");
    }
    get id() {
      return this._id;
    }
    get secret() {
      return this._secret;
    }
    get key() {
      return this._key;
    }
    get linked() {
      return this._linked;
    }
    set linked(o) {
      this._linked = o, this.persistLinked();
    }
    save() {
      return this._storage.setItem(i, this._id), this._storage.setItem(t, this._secret), this.persistLinked(), this;
    }
    persistLinked() {
      this._storage.setItem(p, this._linked ? "1" : "0");
    }
  };
  return dr.Session = n, dr;
}
var pr = {}, gr = {}, Lo;
function Vl() {
  if (Lo) return gr;
  Lo = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.Cipher = void 0;
  const e = /* @__PURE__ */ tt();
  let r = class {
    // @param secret hex representation of 32-byte secret
    constructor(t) {
      this.secret = t;
    }
    /**
     *
     * @param plainText string to be encrypted
     * returns hex string representation of bytes in the order: initialization vector (iv),
     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
     * encrypted plainText.
     */
    async encrypt(t) {
      const p = this.secret;
      if (p.length !== 64)
        throw Error("secret must be 256 bits");
      const n = crypto.getRandomValues(new Uint8Array(12)), u = await crypto.subtle.importKey("raw", (0, e.hexStringToUint8Array)(p), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), o = new TextEncoder(), d = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: n
      }, u, o.encode(t)), m = 16, g = d.slice(d.byteLength - m), c = d.slice(0, d.byteLength - m), h = new Uint8Array(g), s = new Uint8Array(c), f = new Uint8Array([...n, ...h, ...s]);
      return (0, e.uint8ArrayToHex)(f);
    }
    /**
     *
     * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
     */
    async decrypt(t) {
      const p = this.secret;
      if (p.length !== 64)
        throw Error("secret must be 256 bits");
      return new Promise((n, u) => {
        (async function() {
          const o = await crypto.subtle.importKey("raw", (0, e.hexStringToUint8Array)(p), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), d = (0, e.hexStringToUint8Array)(t), m = d.slice(0, 12), g = d.slice(12, 28), c = d.slice(28), h = new Uint8Array([...c, ...g]), s = {
            name: "AES-GCM",
            iv: new Uint8Array(m)
          };
          try {
            const f = await window.crypto.subtle.decrypt(s, o, h), b = new TextDecoder();
            n(b.decode(f));
          } catch (f) {
            u(f);
          }
        })();
      });
    }
  };
  return gr.Cipher = r, gr;
}
var mr = {}, Bo;
function zl() {
  if (Bo) return mr;
  Bo = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.WalletLinkHTTP = void 0;
  let e = class {
    constructor(i, t, p) {
      this.linkAPIUrl = i, this.sessionId = t;
      const n = `${t}:${p}`;
      this.auth = `Basic ${btoa(n)}`;
    }
    // mark unseen events as seen
    async markUnseenEventsAsSeen(i) {
      return Promise.all(i.map((t) => fetch(`${this.linkAPIUrl}/events/${t.eventId}/seen`, {
        method: "POST",
        headers: {
          Authorization: this.auth
        }
      }))).catch((t) => console.error("Unabled to mark event as failed:", t));
    }
    async fetchUnseenEvents() {
      var i;
      const t = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
        headers: {
          Authorization: this.auth
        }
      });
      if (t.ok) {
        const { events: p, error: n } = await t.json();
        if (n)
          throw new Error(`Check unseen events failed: ${n}`);
        const u = (i = p == null ? void 0 : p.filter((o) => o.event === "Web3Response").map((o) => ({
          type: "Event",
          sessionId: this.sessionId,
          eventId: o.id,
          event: o.event,
          data: o.data
        }))) !== null && i !== void 0 ? i : [];
        return this.markUnseenEventsAsSeen(u), u;
      }
      throw new Error(`Check unseen events failed: ${t.status}`);
    }
  };
  return mr.WalletLinkHTTP = e, mr;
}
var Rt = {}, No;
function Jl() {
  if (No) return Rt;
  No = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.WalletLinkWebSocket = Rt.ConnectionState = void 0;
  var e;
  (function(i) {
    i[i.DISCONNECTED = 0] = "DISCONNECTED", i[i.CONNECTING = 1] = "CONNECTING", i[i.CONNECTED = 2] = "CONNECTED";
  })(e || (Rt.ConnectionState = e = {}));
  let r = class {
    setConnectionStateListener(t) {
      this.connectionStateListener = t;
    }
    setIncomingDataListener(t) {
      this.incomingDataListener = t;
    }
    /**
     * Constructor
     * @param url WebSocket server URL
     * @param [WebSocketClass] Custom WebSocket implementation
     */
    constructor(t, p = WebSocket) {
      this.WebSocketClass = p, this.webSocket = null, this.pendingData = [], this.url = t.replace(/^http/, "ws");
    }
    /**
     * Make a websocket connection
     * @returns a Promise that resolves when connected
     */
    async connect() {
      if (this.webSocket)
        throw new Error("webSocket object is not null");
      return new Promise((t, p) => {
        var n;
        let u;
        try {
          this.webSocket = u = new this.WebSocketClass(this.url);
        } catch (o) {
          p(o);
          return;
        }
        (n = this.connectionStateListener) === null || n === void 0 || n.call(this, e.CONNECTING), u.onclose = (o) => {
          var d;
          this.clearWebSocket(), p(new Error(`websocket error ${o.code}: ${o.reason}`)), (d = this.connectionStateListener) === null || d === void 0 || d.call(this, e.DISCONNECTED);
        }, u.onopen = (o) => {
          var d;
          t(), (d = this.connectionStateListener) === null || d === void 0 || d.call(this, e.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((g) => this.sendData(g)), this.pendingData = []);
        }, u.onmessage = (o) => {
          var d, m;
          if (o.data === "h")
            (d = this.incomingDataListener) === null || d === void 0 || d.call(this, {
              type: "Heartbeat"
            });
          else
            try {
              const g = JSON.parse(o.data);
              (m = this.incomingDataListener) === null || m === void 0 || m.call(this, g);
            } catch {
            }
        };
      });
    }
    /**
     * Disconnect from server
     */
    disconnect() {
      var t;
      const { webSocket: p } = this;
      if (p) {
        this.clearWebSocket(), (t = this.connectionStateListener) === null || t === void 0 || t.call(this, e.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
        try {
          p.close();
        } catch {
        }
      }
    }
    /**
     * Send data to server
     * @param data text to send
     */
    sendData(t) {
      const { webSocket: p } = this;
      if (!p) {
        this.pendingData.push(t), this.connect();
        return;
      }
      p.send(t);
    }
    clearWebSocket() {
      const { webSocket: t } = this;
      t && (this.webSocket = null, t.onclose = null, t.onerror = null, t.onmessage = null, t.onopen = null);
    }
  };
  return Rt.WalletLinkWebSocket = r, Rt;
}
var Po;
function Gl() {
  if (Po) return pr;
  Po = 1, Object.defineProperty(pr, "__esModule", { value: !0 }), pr.WalletLinkConnection = void 0;
  const e = /* @__PURE__ */ gn(), r = /* @__PURE__ */ Vl(), i = /* @__PURE__ */ Os(), t = /* @__PURE__ */ Fs(), p = /* @__PURE__ */ Ds(), n = /* @__PURE__ */ zl(), u = /* @__PURE__ */ Jl(), o = 1e4, d = 6e4;
  let m = class {
    /**
     * Constructor
     * @param session Session
     * @param linkAPIUrl Coinbase Wallet link server URL
     * @param listener WalletLinkConnectionUpdateListener
     * @param [WebSocketClass] Custom WebSocket implementation
     */
    constructor({ session: c, linkAPIUrl: h, listener: s, diagnostic: f, WebSocketClass: b = WebSocket }) {
      this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = (0, e.IntNumber)(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (a) => {
        if (!a)
          return;
        (/* @__PURE__ */ new Map([
          ["__destroyed", this.handleDestroyed],
          ["EthereumAddress", this.handleAccountUpdated],
          ["WalletUsername", this.handleWalletUsernameUpdated],
          ["AppVersion", this.handleAppVersionUpdated],
          [
            "ChainId",
            (S) => a.JsonRpcUrl && this.handleChainUpdated(S, a.JsonRpcUrl)
          ]
        ])).forEach((S, I) => {
          const T = a[I];
          T !== void 0 && S(T);
        });
      }, this.handleDestroyed = (a) => {
        var R, S;
        a === "1" && ((R = this.listener) === null || R === void 0 || R.resetAndReload(), (S = this.diagnostic) === null || S === void 0 || S.log(i.EVENTS.METADATA_DESTROYED, {
          alreadyDestroyed: this.isDestroyed,
          sessionIdHash: p.Session.hash(this.session.id)
        }));
      }, this.handleAccountUpdated = async (a) => {
        var R, S;
        try {
          const I = await this.cipher.decrypt(a);
          (R = this.listener) === null || R === void 0 || R.accountUpdated(I);
        } catch {
          (S = this.diagnostic) === null || S === void 0 || S.log(i.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "selectedAddress"
          });
        }
      }, this.handleMetadataUpdated = async (a, R) => {
        var S, I;
        try {
          const T = await this.cipher.decrypt(R);
          (S = this.listener) === null || S === void 0 || S.metadataUpdated(a, T);
        } catch {
          (I = this.diagnostic) === null || I === void 0 || I.log(i.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: a
          });
        }
      }, this.handleWalletUsernameUpdated = async (a) => {
        this.handleMetadataUpdated(t.WALLET_USER_NAME_KEY, a);
      }, this.handleAppVersionUpdated = async (a) => {
        this.handleMetadataUpdated(t.APP_VERSION_KEY, a);
      }, this.handleChainUpdated = async (a, R) => {
        var S, I;
        try {
          const T = await this.cipher.decrypt(a), q = await this.cipher.decrypt(R);
          (S = this.listener) === null || S === void 0 || S.chainUpdated(T, q);
        } catch {
          (I = this.diagnostic) === null || I === void 0 || I.log(i.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "chainId|jsonRpcUrl"
          });
        }
      }, this.session = c, this.cipher = new r.Cipher(c.secret), this.diagnostic = f, this.listener = s;
      const v = new u.WalletLinkWebSocket(`${h}/rpc`, b);
      v.setConnectionStateListener(async (a) => {
        var R;
        (R = this.diagnostic) === null || R === void 0 || R.log(i.EVENTS.CONNECTED_STATE_CHANGE, {
          state: a,
          sessionIdHash: p.Session.hash(c.id)
        });
        let S = !1;
        switch (a) {
          case u.ConnectionState.DISCONNECTED:
            if (!this.destroyed) {
              const I = async () => {
                await new Promise((T) => setTimeout(T, 5e3)), this.destroyed || v.connect().catch(() => {
                  I();
                });
              };
              I();
            }
            break;
          case u.ConnectionState.CONNECTED:
            try {
              await this.authenticate(), this.sendIsLinked(), this.sendGetSessionConfig(), S = !0;
            } catch {
            }
            this.updateLastHeartbeat(), setInterval(() => {
              this.heartbeat();
            }, o), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
            break;
          case u.ConnectionState.CONNECTING:
            break;
        }
        this.connected !== S && (this.connected = S);
      }), v.setIncomingDataListener((a) => {
        var R, S, I;
        switch (a.type) {
          // handle server's heartbeat responses
          case "Heartbeat":
            this.updateLastHeartbeat();
            return;
          // handle link status updates
          case "IsLinkedOK":
          case "Linked": {
            const T = a.type === "IsLinkedOK" ? a.linked : void 0;
            (R = this.diagnostic) === null || R === void 0 || R.log(i.EVENTS.LINKED, {
              sessionIdHash: p.Session.hash(c.id),
              linked: T,
              type: a.type,
              onlineGuests: a.onlineGuests
            }), this.linked = T || a.onlineGuests > 0;
            break;
          }
          // handle session config updates
          case "GetSessionConfigOK":
          case "SessionConfigUpdated": {
            (S = this.diagnostic) === null || S === void 0 || S.log(i.EVENTS.SESSION_CONFIG_RECEIVED, {
              sessionIdHash: p.Session.hash(c.id),
              metadata_keys: a && a.metadata ? Object.keys(a.metadata) : void 0
            }), this.handleSessionMetadataUpdated(a.metadata);
            break;
          }
          case "Event": {
            this.handleIncomingEvent(a);
            break;
          }
        }
        a.id !== void 0 && ((I = this.requestResolutions.get(a.id)) === null || I === void 0 || I(a));
      }), this.ws = v, this.http = new n.WalletLinkHTTP(h, c.id, c.key);
    }
    /**
     * Make a connection to the server
     */
    connect() {
      var c;
      if (this.destroyed)
        throw new Error("instance is destroyed");
      (c = this.diagnostic) === null || c === void 0 || c.log(i.EVENTS.STARTED_CONNECTING, {
        sessionIdHash: p.Session.hash(this.session.id)
      }), this.ws.connect();
    }
    /**
     * Terminate connection, and mark as destroyed. To reconnect, create a new
     * instance of WalletSDKConnection
     */
    destroy() {
      var c;
      this.destroyed = !0, this.ws.disconnect(), (c = this.diagnostic) === null || c === void 0 || c.log(i.EVENTS.DISCONNECTED, {
        sessionIdHash: p.Session.hash(this.session.id)
      }), this.listener = void 0;
    }
    get isDestroyed() {
      return this.destroyed;
    }
    get connected() {
      return this._connected;
    }
    set connected(c) {
      var h, s;
      this._connected = c, c && ((h = this.onceConnected) === null || h === void 0 || h.call(this)), (s = this.listener) === null || s === void 0 || s.connectedUpdated(c);
    }
    setOnceConnected(c) {
      return new Promise((h) => {
        this.connected ? c().then(h) : this.onceConnected = () => {
          c().then(h), this.onceConnected = void 0;
        };
      });
    }
    get linked() {
      return this._linked;
    }
    set linked(c) {
      var h, s;
      this._linked = c, c && ((h = this.onceLinked) === null || h === void 0 || h.call(this)), (s = this.listener) === null || s === void 0 || s.linkedUpdated(c);
    }
    setOnceLinked(c) {
      return new Promise((h) => {
        this.linked ? c().then(h) : this.onceLinked = () => {
          c().then(h), this.onceLinked = void 0;
        };
      });
    }
    async handleIncomingEvent(c) {
      var h, s;
      if (!(c.type !== "Event" || c.event !== "Web3Response"))
        try {
          const f = await this.cipher.decrypt(c.data), b = JSON.parse(f);
          if (b.type !== "WEB3_RESPONSE")
            return;
          (h = this.listener) === null || h === void 0 || h.handleWeb3ResponseMessage(b);
        } catch {
          (s = this.diagnostic) === null || s === void 0 || s.log(i.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent"
          });
        }
    }
    async checkUnseenEvents() {
      if (!this.connected) {
        this.shouldFetchUnseenEventsOnConnect = !0;
        return;
      }
      await new Promise((c) => setTimeout(c, 250));
      try {
        await this.fetchUnseenEventsAPI();
      } catch (c) {
        console.error("Unable to check for unseen events", c);
      }
    }
    async fetchUnseenEventsAPI() {
      this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((h) => this.handleIncomingEvent(h));
    }
    /**
     * Set session metadata in SessionConfig object
     * @param key
     * @param value
     * @returns a Promise that completes when successful
     */
    async setSessionMetadata(c, h) {
      const s = {
        type: "SetSessionConfig",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        metadata: { [c]: h }
      };
      return this.setOnceConnected(async () => {
        const f = await this.makeRequest(s);
        if (f.type === "Fail")
          throw new Error(f.error || "failed to set session metadata");
      });
    }
    /**
     * Publish an event and emit event ID when successful
     * @param event event name
     * @param unencryptedData unencrypted event data
     * @param callWebhook whether the webhook should be invoked
     * @returns a Promise that emits event ID when successful
     */
    async publishEvent(c, h, s = !1) {
      const f = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, h), { origin: location.origin, relaySource: window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), b = {
        type: "PublishEvent",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        event: c,
        data: f,
        callWebhook: s
      };
      return this.setOnceLinked(async () => {
        const v = await this.makeRequest(b);
        if (v.type === "Fail")
          throw new Error(v.error || "failed to publish event");
        return v.eventId;
      });
    }
    sendData(c) {
      this.ws.sendData(JSON.stringify(c));
    }
    updateLastHeartbeat() {
      this.lastHeartbeatResponse = Date.now();
    }
    heartbeat() {
      if (Date.now() - this.lastHeartbeatResponse > o * 2) {
        this.ws.disconnect();
        return;
      }
      try {
        this.ws.sendData("h");
      } catch {
      }
    }
    async makeRequest(c, h = d) {
      const s = c.id;
      this.sendData(c);
      let f;
      return Promise.race([
        new Promise((b, v) => {
          f = window.setTimeout(() => {
            v(new Error(`request ${s} timed out`));
          }, h);
        }),
        new Promise((b) => {
          this.requestResolutions.set(s, (v) => {
            clearTimeout(f), b(v), this.requestResolutions.delete(s);
          });
        })
      ]);
    }
    async authenticate() {
      const c = {
        type: "HostSession",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        sessionKey: this.session.key
      }, h = await this.makeRequest(c);
      if (h.type === "Fail")
        throw new Error(h.error || "failed to authentcate");
    }
    sendIsLinked() {
      const c = {
        type: "IsLinked",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id
      };
      this.sendData(c);
    }
    sendGetSessionConfig() {
      const c = {
        type: "GetSessionConfig",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id
      };
      this.sendData(c);
    }
  };
  return pr.WalletLinkConnection = m, pr;
}
var wr = {}, qt = {}, Zr = {}, Oo;
function Zl() {
  return Oo || (Oo = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.default = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}'), Zr;
}
var Fo;
function Uc() {
  if (Fo) return qt;
  Fo = 1;
  var e = qt.__importDefault || function(t) {
    return t && t.__esModule ? t : { default: t };
  };
  Object.defineProperty(qt, "__esModule", { value: !0 }), qt.injectCssReset = void 0;
  const r = e(/* @__PURE__ */ Zl());
  function i() {
    const t = document.createElement("style");
    t.type = "text/css", t.appendChild(document.createTextNode(r.default)), document.documentElement.appendChild(t);
  }
  return qt.injectCssReset = i, qt;
}
var yr = {};
const We = /* @__PURE__ */ $r(Al);
var jt = {};
function Hc(e) {
  var r, i, t = "";
  if (typeof e == "string" || typeof e == "number") t += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (r = 0; r < e.length; r++) e[r] && (i = Hc(e[r])) && (t && (t += " "), t += i);
  else for (r in e) e[r] && (t && (t += " "), t += r);
  return t;
}
function Do() {
  for (var e, r, i = 0, t = ""; i < arguments.length; ) (e = arguments[i++]) && (r = Hc(e)) && (t && (t += " "), t += r);
  return t;
}
const Kl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: Do,
  default: Do
}, Symbol.toStringTag, { value: "Module" })), Ur = /* @__PURE__ */ $r(Kl), wn = /* @__PURE__ */ $r(Tl);
var rt = {}, br = {}, qo;
function Ql() {
  if (qo) return br;
  qo = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.CloseIcon = void 0;
  const e = We;
  function r(i) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i),
      (0, e.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
    );
  }
  return br.CloseIcon = r, br;
}
var vr = {}, jo;
function Yl() {
  if (jo) return vr;
  jo = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.CoinbaseWalletRound = void 0;
  const e = We;
  function r(i) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "28", height: "28", viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, i),
      (0, e.h)("circle", { cx: "14", cy: "14", r: "14", fill: "#0052FF" }),
      (0, e.h)("path", { d: "M23.8521 14.0003C23.8521 19.455 19.455 23.8521 14.0003 23.8521C8.54559 23.8521 4.14844 19.455 4.14844 14.0003C4.14844 8.54559 8.54559 4.14844 14.0003 4.14844C19.455 4.14844 23.8521 8.54559 23.8521 14.0003Z", fill: "white" }),
      (0, e.h)("path", { d: "M11.1855 12.5042C11.1855 12.0477 11.1855 11.7942 11.2835 11.642C11.3814 11.4899 11.4793 11.3377 11.6261 11.287C11.8219 11.1855 12.0178 11.1855 12.5073 11.1855H15.4934C15.983 11.1855 16.1788 11.1855 16.3746 11.287C16.5215 11.3884 16.6683 11.4899 16.7173 11.642C16.8152 11.8449 16.8152 12.0477 16.8152 12.5042V15.4965C16.8152 15.953 16.8152 16.2066 16.7173 16.3587C16.6194 16.5109 16.5215 16.663 16.3746 16.7137C16.1788 16.8152 15.983 16.8152 15.4934 16.8152H12.5073C12.0178 16.8152 11.8219 16.8152 11.6261 16.7137C11.4793 16.6123 11.3324 16.5109 11.2835 16.3587C11.1855 16.1558 11.1855 15.953 11.1855 15.4965V12.5042Z", fill: "#0052FF" })
    );
  }
  return vr.CoinbaseWalletRound = r, vr;
}
var _r = {}, $o;
function Xl() {
  if ($o) return _r;
  $o = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.QRCodeIcon = void 0;
  const e = We;
  function r(i) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "18", height: "18", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, i),
      (0, e.h)("path", { d: "M3 3V8.99939L5 8.99996V5H9V3H3Z" }),
      (0, e.h)("path", { d: "M15 21L21 21V15.0006L19 15V19L15 19V21Z" }),
      (0, e.h)("path", { d: "M21 9H19V5H15.0006L15 3H21V9Z" }),
      (0, e.h)("path", { d: "M3 15V21H8.99939L8.99996 19H5L5 15H3Z" })
    );
  }
  return _r.QRCodeIcon = r, _r;
}
var $t = {}, jn, Uo;
function eh() {
  if (Uo) return jn;
  Uo = 1;
  function e(s) {
    this.mode = i.MODE_8BIT_BYTE, this.data = s, this.parsedData = [];
    for (var f = 0, b = this.data.length; f < b; f++) {
      var v = [], a = this.data.charCodeAt(f);
      a > 65536 ? (v[0] = 240 | (a & 1835008) >>> 18, v[1] = 128 | (a & 258048) >>> 12, v[2] = 128 | (a & 4032) >>> 6, v[3] = 128 | a & 63) : a > 2048 ? (v[0] = 224 | (a & 61440) >>> 12, v[1] = 128 | (a & 4032) >>> 6, v[2] = 128 | a & 63) : a > 128 ? (v[0] = 192 | (a & 1984) >>> 6, v[1] = 128 | a & 63) : v[0] = a, this.parsedData.push(v);
    }
    this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
  }
  e.prototype = {
    getLength: function(s) {
      return this.parsedData.length;
    },
    write: function(s) {
      for (var f = 0, b = this.parsedData.length; f < b; f++)
        s.put(this.parsedData[f], 8);
    }
  };
  function r(s, f) {
    this.typeNumber = s, this.errorCorrectLevel = f, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
  }
  r.prototype = { addData: function(s) {
    var f = new e(s);
    this.dataList.push(f), this.dataCache = null;
  }, isDark: function(s, f) {
    if (s < 0 || this.moduleCount <= s || f < 0 || this.moduleCount <= f)
      throw new Error(s + "," + f);
    return this.modules[s][f];
  }, getModuleCount: function() {
    return this.moduleCount;
  }, make: function() {
    this.makeImpl(!1, this.getBestMaskPattern());
  }, makeImpl: function(s, f) {
    this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
    for (var b = 0; b < this.moduleCount; b++) {
      this.modules[b] = new Array(this.moduleCount);
      for (var v = 0; v < this.moduleCount; v++)
        this.modules[b][v] = null;
    }
    this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(s, f), this.typeNumber >= 7 && this.setupTypeNumber(s), this.dataCache == null && (this.dataCache = r.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, f);
  }, setupPositionProbePattern: function(s, f) {
    for (var b = -1; b <= 7; b++)
      if (!(s + b <= -1 || this.moduleCount <= s + b))
        for (var v = -1; v <= 7; v++)
          f + v <= -1 || this.moduleCount <= f + v || (0 <= b && b <= 6 && (v == 0 || v == 6) || 0 <= v && v <= 6 && (b == 0 || b == 6) || 2 <= b && b <= 4 && 2 <= v && v <= 4 ? this.modules[s + b][f + v] = !0 : this.modules[s + b][f + v] = !1);
  }, getBestMaskPattern: function() {
    for (var s = 0, f = 0, b = 0; b < 8; b++) {
      this.makeImpl(!0, b);
      var v = n.getLostPoint(this);
      (b == 0 || s > v) && (s = v, f = b);
    }
    return f;
  }, createMovieClip: function(s, f, b) {
    var v = s.createEmptyMovieClip(f, b), a = 1;
    this.make();
    for (var R = 0; R < this.modules.length; R++)
      for (var S = R * a, I = 0; I < this.modules[R].length; I++) {
        var T = I * a, q = this.modules[R][I];
        q && (v.beginFill(0, 100), v.moveTo(T, S), v.lineTo(T + a, S), v.lineTo(T + a, S + a), v.lineTo(T, S + a), v.endFill());
      }
    return v;
  }, setupTimingPattern: function() {
    for (var s = 8; s < this.moduleCount - 8; s++)
      this.modules[s][6] == null && (this.modules[s][6] = s % 2 == 0);
    for (var f = 8; f < this.moduleCount - 8; f++)
      this.modules[6][f] == null && (this.modules[6][f] = f % 2 == 0);
  }, setupPositionAdjustPattern: function() {
    for (var s = n.getPatternPosition(this.typeNumber), f = 0; f < s.length; f++)
      for (var b = 0; b < s.length; b++) {
        var v = s[f], a = s[b];
        if (this.modules[v][a] == null)
          for (var R = -2; R <= 2; R++)
            for (var S = -2; S <= 2; S++)
              R == -2 || R == 2 || S == -2 || S == 2 || R == 0 && S == 0 ? this.modules[v + R][a + S] = !0 : this.modules[v + R][a + S] = !1;
      }
  }, setupTypeNumber: function(s) {
    for (var f = n.getBCHTypeNumber(this.typeNumber), b = 0; b < 18; b++) {
      var v = !s && (f >> b & 1) == 1;
      this.modules[Math.floor(b / 3)][b % 3 + this.moduleCount - 8 - 3] = v;
    }
    for (var b = 0; b < 18; b++) {
      var v = !s && (f >> b & 1) == 1;
      this.modules[b % 3 + this.moduleCount - 8 - 3][Math.floor(b / 3)] = v;
    }
  }, setupTypeInfo: function(s, f) {
    for (var b = this.errorCorrectLevel << 3 | f, v = n.getBCHTypeInfo(b), a = 0; a < 15; a++) {
      var R = !s && (v >> a & 1) == 1;
      a < 6 ? this.modules[a][8] = R : a < 8 ? this.modules[a + 1][8] = R : this.modules[this.moduleCount - 15 + a][8] = R;
    }
    for (var a = 0; a < 15; a++) {
      var R = !s && (v >> a & 1) == 1;
      a < 8 ? this.modules[8][this.moduleCount - a - 1] = R : a < 9 ? this.modules[8][15 - a - 1 + 1] = R : this.modules[8][15 - a - 1] = R;
    }
    this.modules[this.moduleCount - 8][8] = !s;
  }, mapData: function(s, f) {
    for (var b = -1, v = this.moduleCount - 1, a = 7, R = 0, S = this.moduleCount - 1; S > 0; S -= 2)
      for (S == 6 && S--; ; ) {
        for (var I = 0; I < 2; I++)
          if (this.modules[v][S - I] == null) {
            var T = !1;
            R < s.length && (T = (s[R] >>> a & 1) == 1);
            var q = n.getMask(f, v, S - I);
            q && (T = !T), this.modules[v][S - I] = T, a--, a == -1 && (R++, a = 7);
          }
        if (v += b, v < 0 || this.moduleCount <= v) {
          v -= b, b = -b;
          break;
        }
      }
  } }, r.PAD0 = 236, r.PAD1 = 17, r.createData = function(s, f, b) {
    for (var v = m.getRSBlocks(s, f), a = new g(), R = 0; R < b.length; R++) {
      var S = b[R];
      a.put(S.mode, 4), a.put(S.getLength(), n.getLengthInBits(S.mode, s)), S.write(a);
    }
    for (var I = 0, R = 0; R < v.length; R++)
      I += v[R].dataCount;
    if (a.getLengthInBits() > I * 8)
      throw new Error("code length overflow. (" + a.getLengthInBits() + ">" + I * 8 + ")");
    for (a.getLengthInBits() + 4 <= I * 8 && a.put(0, 4); a.getLengthInBits() % 8 != 0; )
      a.putBit(!1);
    for (; !(a.getLengthInBits() >= I * 8 || (a.put(r.PAD0, 8), a.getLengthInBits() >= I * 8)); )
      a.put(r.PAD1, 8);
    return r.createBytes(a, v);
  }, r.createBytes = function(s, f) {
    for (var b = 0, v = 0, a = 0, R = new Array(f.length), S = new Array(f.length), I = 0; I < f.length; I++) {
      var T = f[I].dataCount, q = f[I].totalCount - T;
      v = Math.max(v, T), a = Math.max(a, q), R[I] = new Array(T);
      for (var D = 0; D < R[I].length; D++)
        R[I][D] = 255 & s.buffer[D + b];
      b += T;
      var H = n.getErrorCorrectPolynomial(q), G = new d(R[I], H.getLength() - 1), ee = G.mod(H);
      S[I] = new Array(H.getLength() - 1);
      for (var D = 0; D < S[I].length; D++) {
        var Y = D + ee.getLength() - S[I].length;
        S[I][D] = Y >= 0 ? ee.get(Y) : 0;
      }
    }
    for (var re = 0, D = 0; D < f.length; D++)
      re += f[D].totalCount;
    for (var F = new Array(re), l = 0, D = 0; D < v; D++)
      for (var I = 0; I < f.length; I++)
        D < R[I].length && (F[l++] = R[I][D]);
    for (var D = 0; D < a; D++)
      for (var I = 0; I < f.length; I++)
        D < S[I].length && (F[l++] = S[I][D]);
    return F;
  };
  for (var i = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, t = { L: 1, M: 0, Q: 3, H: 2 }, p = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 }, n = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(s) {
    for (var f = s << 10; n.getBCHDigit(f) - n.getBCHDigit(n.G15) >= 0; )
      f ^= n.G15 << n.getBCHDigit(f) - n.getBCHDigit(n.G15);
    return (s << 10 | f) ^ n.G15_MASK;
  }, getBCHTypeNumber: function(s) {
    for (var f = s << 12; n.getBCHDigit(f) - n.getBCHDigit(n.G18) >= 0; )
      f ^= n.G18 << n.getBCHDigit(f) - n.getBCHDigit(n.G18);
    return s << 12 | f;
  }, getBCHDigit: function(s) {
    for (var f = 0; s != 0; )
      f++, s >>>= 1;
    return f;
  }, getPatternPosition: function(s) {
    return n.PATTERN_POSITION_TABLE[s - 1];
  }, getMask: function(s, f, b) {
    switch (s) {
      case p.PATTERN000:
        return (f + b) % 2 == 0;
      case p.PATTERN001:
        return f % 2 == 0;
      case p.PATTERN010:
        return b % 3 == 0;
      case p.PATTERN011:
        return (f + b) % 3 == 0;
      case p.PATTERN100:
        return (Math.floor(f / 2) + Math.floor(b / 3)) % 2 == 0;
      case p.PATTERN101:
        return f * b % 2 + f * b % 3 == 0;
      case p.PATTERN110:
        return (f * b % 2 + f * b % 3) % 2 == 0;
      case p.PATTERN111:
        return (f * b % 3 + (f + b) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + s);
    }
  }, getErrorCorrectPolynomial: function(s) {
    for (var f = new d([1], 0), b = 0; b < s; b++)
      f = f.multiply(new d([1, u.gexp(b)], 0));
    return f;
  }, getLengthInBits: function(s, f) {
    if (1 <= f && f < 10)
      switch (s) {
        case i.MODE_NUMBER:
          return 10;
        case i.MODE_ALPHA_NUM:
          return 9;
        case i.MODE_8BIT_BYTE:
          return 8;
        case i.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + s);
      }
    else if (f < 27)
      switch (s) {
        case i.MODE_NUMBER:
          return 12;
        case i.MODE_ALPHA_NUM:
          return 11;
        case i.MODE_8BIT_BYTE:
          return 16;
        case i.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + s);
      }
    else if (f < 41)
      switch (s) {
        case i.MODE_NUMBER:
          return 14;
        case i.MODE_ALPHA_NUM:
          return 13;
        case i.MODE_8BIT_BYTE:
          return 16;
        case i.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + s);
      }
    else
      throw new Error("type:" + f);
  }, getLostPoint: function(s) {
    for (var f = s.getModuleCount(), b = 0, v = 0; v < f; v++)
      for (var a = 0; a < f; a++) {
        for (var R = 0, S = s.isDark(v, a), I = -1; I <= 1; I++)
          if (!(v + I < 0 || f <= v + I))
            for (var T = -1; T <= 1; T++)
              a + T < 0 || f <= a + T || I == 0 && T == 0 || S == s.isDark(v + I, a + T) && R++;
        R > 5 && (b += 3 + R - 5);
      }
    for (var v = 0; v < f - 1; v++)
      for (var a = 0; a < f - 1; a++) {
        var q = 0;
        s.isDark(v, a) && q++, s.isDark(v + 1, a) && q++, s.isDark(v, a + 1) && q++, s.isDark(v + 1, a + 1) && q++, (q == 0 || q == 4) && (b += 3);
      }
    for (var v = 0; v < f; v++)
      for (var a = 0; a < f - 6; a++)
        s.isDark(v, a) && !s.isDark(v, a + 1) && s.isDark(v, a + 2) && s.isDark(v, a + 3) && s.isDark(v, a + 4) && !s.isDark(v, a + 5) && s.isDark(v, a + 6) && (b += 40);
    for (var a = 0; a < f; a++)
      for (var v = 0; v < f - 6; v++)
        s.isDark(v, a) && !s.isDark(v + 1, a) && s.isDark(v + 2, a) && s.isDark(v + 3, a) && s.isDark(v + 4, a) && !s.isDark(v + 5, a) && s.isDark(v + 6, a) && (b += 40);
    for (var D = 0, a = 0; a < f; a++)
      for (var v = 0; v < f; v++)
        s.isDark(v, a) && D++;
    var H = Math.abs(100 * D / f / f - 50) / 5;
    return b += H * 10, b;
  } }, u = { glog: function(s) {
    if (s < 1)
      throw new Error("glog(" + s + ")");
    return u.LOG_TABLE[s];
  }, gexp: function(s) {
    for (; s < 0; )
      s += 255;
    for (; s >= 256; )
      s -= 255;
    return u.EXP_TABLE[s];
  }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }, o = 0; o < 8; o++)
    u.EXP_TABLE[o] = 1 << o;
  for (var o = 8; o < 256; o++)
    u.EXP_TABLE[o] = u.EXP_TABLE[o - 4] ^ u.EXP_TABLE[o - 5] ^ u.EXP_TABLE[o - 6] ^ u.EXP_TABLE[o - 8];
  for (var o = 0; o < 255; o++)
    u.LOG_TABLE[u.EXP_TABLE[o]] = o;
  function d(s, f) {
    if (s.length == null)
      throw new Error(s.length + "/" + f);
    for (var b = 0; b < s.length && s[b] == 0; )
      b++;
    this.num = new Array(s.length - b + f);
    for (var v = 0; v < s.length - b; v++)
      this.num[v] = s[v + b];
  }
  d.prototype = { get: function(s) {
    return this.num[s];
  }, getLength: function() {
    return this.num.length;
  }, multiply: function(s) {
    for (var f = new Array(this.getLength() + s.getLength() - 1), b = 0; b < this.getLength(); b++)
      for (var v = 0; v < s.getLength(); v++)
        f[b + v] ^= u.gexp(u.glog(this.get(b)) + u.glog(s.get(v)));
    return new d(f, 0);
  }, mod: function(s) {
    if (this.getLength() - s.getLength() < 0)
      return this;
    for (var f = u.glog(this.get(0)) - u.glog(s.get(0)), b = new Array(this.getLength()), v = 0; v < this.getLength(); v++)
      b[v] = this.get(v);
    for (var v = 0; v < s.getLength(); v++)
      b[v] ^= u.gexp(u.glog(s.get(v)) + f);
    return new d(b, 0).mod(s);
  } };
  function m(s, f) {
    this.totalCount = s, this.dataCount = f;
  }
  m.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], m.getRSBlocks = function(s, f) {
    var b = m.getRsBlockTable(s, f);
    if (b == null)
      throw new Error("bad rs block @ typeNumber:" + s + "/errorCorrectLevel:" + f);
    for (var v = b.length / 3, a = [], R = 0; R < v; R++)
      for (var S = b[R * 3 + 0], I = b[R * 3 + 1], T = b[R * 3 + 2], q = 0; q < S; q++)
        a.push(new m(I, T));
    return a;
  }, m.getRsBlockTable = function(s, f) {
    switch (f) {
      case t.L:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 0];
      case t.M:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 1];
      case t.Q:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 2];
      case t.H:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 3];
      default:
        return;
    }
  };
  function g() {
    this.buffer = [], this.length = 0;
  }
  g.prototype = { get: function(s) {
    var f = Math.floor(s / 8);
    return (this.buffer[f] >>> 7 - s % 8 & 1) == 1;
  }, put: function(s, f) {
    for (var b = 0; b < f; b++)
      this.putBit((s >>> f - b - 1 & 1) == 1);
  }, getLengthInBits: function() {
    return this.length;
  }, putBit: function(s) {
    var f = Math.floor(this.length / 8);
    this.buffer.length <= f && this.buffer.push(0), s && (this.buffer[f] |= 128 >>> this.length % 8), this.length++;
  } };
  var c = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
  function h(s) {
    if (this.options = {
      padding: 4,
      width: 256,
      height: 256,
      typeNumber: 4,
      color: "#000000",
      background: "#ffffff",
      ecl: "M",
      image: {
        svg: "",
        width: 0,
        height: 0
      }
    }, typeof s == "string" && (s = {
      content: s
    }), s)
      for (var f in s)
        this.options[f] = s[f];
    if (typeof this.options.content != "string")
      throw new Error("Expected 'content' as string!");
    if (this.options.content.length === 0)
      throw new Error("Expected 'content' to be non-empty!");
    if (!(this.options.padding >= 0))
      throw new Error("Expected 'padding' value to be non-negative!");
    if (!(this.options.width > 0) || !(this.options.height > 0))
      throw new Error("Expected 'width' or 'height' value to be higher than zero!");
    function b(T) {
      switch (T) {
        case "L":
          return t.L;
        case "M":
          return t.M;
        case "Q":
          return t.Q;
        case "H":
          return t.H;
        default:
          throw new Error("Unknwon error correction level: " + T);
      }
    }
    function v(T, q) {
      for (var D = a(T), H = 1, G = 0, ee = 0, Y = c.length; ee <= Y; ee++) {
        var re = c[ee];
        if (!re)
          throw new Error("Content too long: expected " + G + " but got " + D);
        switch (q) {
          case "L":
            G = re[0];
            break;
          case "M":
            G = re[1];
            break;
          case "Q":
            G = re[2];
            break;
          case "H":
            G = re[3];
            break;
          default:
            throw new Error("Unknwon error correction level: " + q);
        }
        if (D <= G)
          break;
        H++;
      }
      if (H > c.length)
        throw new Error("Content too long");
      return H;
    }
    function a(T) {
      var q = encodeURI(T).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
      return q.length + (q.length != T ? 3 : 0);
    }
    var R = this.options.content, S = v(R, this.options.ecl), I = b(this.options.ecl);
    this.qrcode = new r(S, I), this.qrcode.addData(R), this.qrcode.make();
  }
  return h.prototype.svg = function(s) {
    var f = this.options || {}, b = this.qrcode.modules;
    typeof s > "u" && (s = { container: f.container || "svg" });
    for (var v = typeof f.pretty < "u" ? !!f.pretty : !0, a = v ? "  " : "", R = v ? `\r
` : "", S = f.width, I = f.height, T = b.length, q = S / (T + 2 * f.padding), D = I / (T + 2 * f.padding), H = typeof f.join < "u" ? !!f.join : !1, G = typeof f.swap < "u" ? !!f.swap : !1, ee = typeof f.xmlDeclaration < "u" ? !!f.xmlDeclaration : !0, Y = typeof f.predefined < "u" ? !!f.predefined : !1, re = Y ? a + '<defs><path id="qrmodule" d="M0 0 h' + D + " v" + q + ' H0 z" style="fill:' + f.color + ';shape-rendering:crispEdges;" /></defs>' + R : "", F = a + '<rect x="0" y="0" width="' + S + '" height="' + I + '" style="fill:' + f.background + ';shape-rendering:crispEdges;"/>' + R, l = "", E = "", M = 0; M < T; M++)
      for (var k = 0; k < T; k++) {
        var x = b[k][M];
        if (x) {
          var B = k * q + f.padding * q, j = M * D + f.padding * D;
          if (G) {
            var A = B;
            B = j, j = A;
          }
          if (H) {
            var y = q + B, N = D + j;
            B = Number.isInteger(B) ? Number(B) : B.toFixed(2), j = Number.isInteger(j) ? Number(j) : j.toFixed(2), y = Number.isInteger(y) ? Number(y) : y.toFixed(2), N = Number.isInteger(N) ? Number(N) : N.toFixed(2), E += "M" + B + "," + j + " V" + N + " H" + y + " V" + j + " H" + B + " Z ";
          } else Y ? l += a + '<use x="' + B.toString() + '" y="' + j.toString() + '" href="#qrmodule" />' + R : l += a + '<rect x="' + B.toString() + '" y="' + j.toString() + '" width="' + q + '" height="' + D + '" style="fill:' + f.color + ';shape-rendering:crispEdges;"/>' + R;
        }
      }
    H && (l = a + '<path x="0" y="0" style="fill:' + f.color + ';shape-rendering:crispEdges;" d="' + E + '" />');
    let te = "";
    if (this.options.image !== void 0 && this.options.image.svg) {
      const $ = S * this.options.image.width / 100, W = I * this.options.image.height / 100, J = S / 2 - $ / 2, X = I / 2 - W / 2;
      te += `<svg x="${J}" y="${X}" width="${$}" height="${W}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`, te += this.options.image.svg + R, te += "</svg>";
    }
    var K = "";
    switch (s.container) {
      //Wrapped in SVG document
      case "svg":
        ee && (K += '<?xml version="1.0" standalone="yes"?>' + R), K += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + S + '" height="' + I + '">' + R, K += re + F + l, K += te, K += "</svg>";
        break;
      //Viewbox for responsive use in a browser, thanks to @danioso
      case "svg-viewbox":
        ee && (K += '<?xml version="1.0" standalone="yes"?>' + R), K += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + S + " " + I + '">' + R, K += re + F + l, K += te, K += "</svg>";
        break;
      //Wrapped in group element
      case "g":
        K += '<g width="' + S + '" height="' + I + '">' + R, K += re + F + l, K += te, K += "</g>";
        break;
      //Without a container
      default:
        K += (re + F + l + te).replace(/^\s+/, "");
        break;
    }
    return K;
  }, jn = h, jn;
}
var Ho;
function th() {
  if (Ho) return $t;
  Ho = 1;
  var e = $t.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty($t, "__esModule", { value: !0 }), $t.QRCode = void 0;
  const r = We, i = wn, t = e(/* @__PURE__ */ eh()), p = (n) => {
    const [u, o] = (0, i.useState)("");
    return (0, i.useEffect)(() => {
      var d, m;
      const g = new t.default({
        content: n.content,
        background: n.bgColor || "#ffffff",
        color: n.fgColor || "#000000",
        container: "svg",
        ecl: "M",
        width: (d = n.width) !== null && d !== void 0 ? d : 256,
        height: (m = n.height) !== null && m !== void 0 ? m : 256,
        padding: 0,
        image: n.image
      }), c = Buffer.from(g.svg(), "utf8").toString("base64");
      o(`data:image/svg+xml;base64,${c}`);
    }, [n.bgColor, n.content, n.fgColor, n.height, n.image, n.width]), u ? (0, r.h)("img", { src: u, alt: "QR Code" }) : null;
  };
  return $t.QRCode = p, $t;
}
var Ut = {}, Kr = {}, Wo;
function rh() {
  return Wo || (Wo = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.default = ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}"), Kr;
}
var Vo;
function nh() {
  if (Vo) return Ut;
  Vo = 1;
  var e = Ut.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(Ut, "__esModule", { value: !0 }), Ut.Spinner = void 0;
  const r = We, i = e(/* @__PURE__ */ rh()), t = (p) => {
    var n;
    const u = (n = p.size) !== null && n !== void 0 ? n : 64, o = p.color || "#000";
    return (0, r.h)(
      "div",
      { class: "-cbwsdk-spinner" },
      (0, r.h)("style", null, i.default),
      (0, r.h)(
        "svg",
        { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: u, height: u } },
        (0, r.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: o } })
      )
    );
  };
  return Ut.Spinner = t, Ut;
}
var Qr = {}, zo;
function ih() {
  return zo || (zo = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.default = ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer;border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}"), Qr;
}
var Jo;
function sh() {
  if (Jo) return rt;
  Jo = 1;
  var e = rt.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(rt, "__esModule", { value: !0 }), rt.CoinbaseWalletSteps = rt.ConnectContent = void 0;
  const r = e(Ur), i = We, t = /* @__PURE__ */ tt(), p = /* @__PURE__ */ Ps(), n = /* @__PURE__ */ Ql(), u = /* @__PURE__ */ Yl(), o = /* @__PURE__ */ Xl(), d = /* @__PURE__ */ th(), m = /* @__PURE__ */ nh(), g = e(/* @__PURE__ */ ih()), c = {
    title: "Coinbase Wallet app",
    description: "Connect with your self-custody wallet",
    steps: b
  }, h = (v) => v === "light" ? "#FFFFFF" : "#0A0B0D";
  function s(v) {
    const { theme: a } = v, R = (0, t.createQrUrl)(v.sessionId, v.sessionSecret, v.linkAPIUrl, v.isParentConnection, v.version, v.chainId), S = c.steps;
    return (0, i.h)(
      "div",
      { "data-testid": "connect-content", className: (0, r.default)("-cbwsdk-connect-content", a) },
      (0, i.h)("style", null, g.default),
      (0, i.h)(
        "div",
        { className: "-cbwsdk-connect-content-header" },
        (0, i.h)("h2", { className: (0, r.default)("-cbwsdk-connect-content-heading", a) }, "Scan to connect with our mobile app"),
        v.onCancel && (0, i.h)(
          "button",
          { type: "button", className: "-cbwsdk-cancel-button", onClick: v.onCancel },
          (0, i.h)(n.CloseIcon, { fill: a === "light" ? "#0A0B0D" : "#FFFFFF" })
        )
      ),
      (0, i.h)(
        "div",
        { className: "-cbwsdk-connect-content-layout" },
        (0, i.h)(
          "div",
          { className: "-cbwsdk-connect-content-column-left" },
          (0, i.h)(f, { title: c.title, description: c.description, theme: a })
        ),
        (0, i.h)(
          "div",
          { className: "-cbwsdk-connect-content-column-right" },
          (0, i.h)(
            "div",
            { className: "-cbwsdk-connect-content-qr-wrapper" },
            (0, i.h)(d.QRCode, { content: R, width: 200, height: 200, fgColor: "#000", bgColor: "transparent" }),
            (0, i.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: p.LIB_VERSION }),
            (0, i.h)("input", { type: "hidden", value: R })
          ),
          (0, i.h)(S, { theme: a }),
          !v.isConnected && (0, i.h)(
            "div",
            { "data-testid": "connecting-spinner", className: (0, r.default)("-cbwsdk-connect-content-qr-connecting", a) },
            (0, i.h)(m.Spinner, { size: 36, color: a === "dark" ? "#FFF" : "#000" }),
            (0, i.h)("p", null, "Connecting...")
          )
        )
      )
    );
  }
  rt.ConnectContent = s;
  function f({ title: v, description: a, theme: R }) {
    return (0, i.h)(
      "div",
      { className: (0, r.default)("-cbwsdk-connect-item", R) },
      (0, i.h)(
        "div",
        null,
        (0, i.h)(u.CoinbaseWalletRound, null)
      ),
      (0, i.h)(
        "div",
        { className: "-cbwsdk-connect-item-copy-wrapper" },
        (0, i.h)("h3", { className: "-cbwsdk-connect-item-title" }, v),
        (0, i.h)("p", { className: "-cbwsdk-connect-item-description" }, a)
      )
    );
  }
  function b({ theme: v }) {
    return (0, i.h)(
      "ol",
      { className: "-cbwsdk-wallet-steps" },
      (0, i.h)(
        "li",
        { className: (0, r.default)("-cbwsdk-wallet-steps-item", v) },
        (0, i.h)("div", { className: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
      ),
      (0, i.h)(
        "li",
        { className: (0, r.default)("-cbwsdk-wallet-steps-item", v) },
        (0, i.h)(
          "div",
          { className: "-cbwsdk-wallet-steps-item-wrapper" },
          (0, i.h)(
            "span",
            null,
            "Tap ",
            (0, i.h)("strong", null, "Scan"),
            " "
          ),
          (0, i.h)(
            "span",
            { className: (0, r.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", v) },
            (0, i.h)(o.QRCodeIcon, { fill: h(v) })
          )
        )
      )
    );
  }
  return rt.CoinbaseWalletSteps = b, rt;
}
var Ht = {}, Er = {}, Go;
function oh() {
  if (Go) return Er;
  Go = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.ArrowLeftIcon = void 0;
  const e = We;
  function r(i) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, i),
      (0, e.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
    );
  }
  return Er.ArrowLeftIcon = r, Er;
}
var Rr = {}, Zo;
function ah() {
  if (Zo) return Rr;
  Zo = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.LaptopIcon = void 0;
  const e = We;
  function r(i) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, i),
      (0, e.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
      (0, e.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
    );
  }
  return Rr.LaptopIcon = r, Rr;
}
var Sr = {}, Ko;
function uh() {
  if (Ko) return Sr;
  Ko = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.SafeIcon = void 0;
  const e = We;
  function r(i) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, i),
      (0, e.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
    );
  }
  return Sr.SafeIcon = r, Sr;
}
var Yr = {}, Qo;
function ch() {
  return Qo || (Qo = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.default = ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}"), Yr;
}
var Yo;
function lh() {
  if (Yo) return Ht;
  Yo = 1;
  var e = Ht.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.TryExtensionContent = void 0;
  const r = e(Ur), i = We, t = wn, p = /* @__PURE__ */ oh(), n = /* @__PURE__ */ ah(), u = /* @__PURE__ */ uh(), o = e(/* @__PURE__ */ ch());
  function d({ theme: m }) {
    const [g, c] = (0, t.useState)(!1), h = (0, t.useCallback)(() => {
      window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
    }, []), s = (0, t.useCallback)(() => {
      g ? window.location.reload() : (h(), c(!0));
    }, [h, g]);
    return (0, i.h)(
      "div",
      { class: (0, r.default)("-cbwsdk-try-extension", m) },
      (0, i.h)("style", null, o.default),
      (0, i.h)(
        "div",
        { class: "-cbwsdk-try-extension-column-half" },
        (0, i.h)("h3", { class: (0, r.default)("-cbwsdk-try-extension-heading", m) }, "Or try the Coinbase Wallet browser extension"),
        (0, i.h)(
          "div",
          { class: "-cbwsdk-try-extension-cta-wrapper" },
          (0, i.h)("button", { class: (0, r.default)("-cbwsdk-try-extension-cta", m), onClick: s }, g ? "Refresh" : "Install"),
          (0, i.h)("div", null, !g && (0, i.h)(p.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: m === "light" ? "#0052FF" : "#588AF5" }))
        )
      ),
      (0, i.h)(
        "div",
        { class: "-cbwsdk-try-extension-column-half" },
        (0, i.h)(
          "ul",
          { class: "-cbwsdk-try-extension-list" },
          (0, i.h)(
            "li",
            { class: "-cbwsdk-try-extension-list-item" },
            (0, i.h)(
              "div",
              { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
              (0, i.h)(
                "span",
                { class: (0, r.default)("-cbwsdk-try-extension-list-item-icon", m) },
                (0, i.h)(n.LaptopIcon, { fill: m === "light" ? "#0A0B0D" : "#FFFFFF" })
              )
            ),
            (0, i.h)("div", { class: (0, r.default)("-cbwsdk-try-extension-list-item-copy", m) }, "Connect with dapps with just one click on your desktop browser")
          ),
          (0, i.h)(
            "li",
            { class: "-cbwsdk-try-extension-list-item" },
            (0, i.h)(
              "div",
              { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
              (0, i.h)(
                "span",
                { class: (0, r.default)("-cbwsdk-try-extension-list-item-icon", m) },
                (0, i.h)(u.SafeIcon, { fill: m === "light" ? "#0A0B0D" : "#FFFFFF" })
              )
            ),
            (0, i.h)("div", { class: (0, r.default)("-cbwsdk-try-extension-list-item-copy", m) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
          )
        )
      )
    );
  }
  return Ht.TryExtensionContent = d, Ht;
}
var Xr = {}, Xo;
function hh() {
  return Xo || (Xo = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.default = ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}"), Xr;
}
var ea;
function dh() {
  if (ea) return jt;
  ea = 1;
  var e = jt.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(jt, "__esModule", { value: !0 }), jt.ConnectDialog = void 0;
  const r = e(Ur), i = We, t = wn, p = /* @__PURE__ */ sh(), n = /* @__PURE__ */ lh(), u = e(/* @__PURE__ */ hh()), o = (d) => {
    const { isOpen: m, darkMode: g } = d, [c, h] = (0, t.useState)(!m), [s, f] = (0, t.useState)(!m);
    (0, t.useEffect)(() => {
      const v = [
        window.setTimeout(() => {
          f(!m);
        }, 10)
      ];
      return m ? h(!1) : v.push(window.setTimeout(() => {
        h(!0);
      }, 360)), () => {
        v.forEach(window.clearTimeout);
      };
    }, [m]);
    const b = g ? "dark" : "light";
    return (0, i.h)(
      "div",
      { class: (0, r.default)("-cbwsdk-connect-dialog-container", c && "-cbwsdk-connect-dialog-container-hidden") },
      (0, i.h)("style", null, u.default),
      (0, i.h)("div", { class: (0, r.default)("-cbwsdk-connect-dialog-backdrop", b, s && "-cbwsdk-connect-dialog-backdrop-hidden") }),
      (0, i.h)(
        "div",
        { class: "-cbwsdk-connect-dialog" },
        (0, i.h)(
          "div",
          { class: (0, r.default)("-cbwsdk-connect-dialog-box", s && "-cbwsdk-connect-dialog-box-hidden") },
          d.connectDisabled ? null : (0, i.h)(p.ConnectContent, { theme: b, version: d.version, sessionId: d.sessionId, sessionSecret: d.sessionSecret, linkAPIUrl: d.linkAPIUrl, isConnected: d.isConnected, isParentConnection: d.isParentConnection, chainId: d.chainId, onCancel: d.onCancel }),
          (0, i.h)(n.TryExtensionContent, { theme: b })
        )
      )
    );
  };
  return jt.ConnectDialog = o, jt;
}
var ta;
function fh() {
  if (ta) return yr;
  ta = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.LinkFlow = void 0;
  const e = We, r = /* @__PURE__ */ dh();
  let i = class {
    constructor(p) {
      this.connected = !1, this.chainId = 1, this.isOpen = !1, this.onCancel = null, this.root = null, this.connectDisabled = !1, this.darkMode = p.darkMode, this.version = p.version, this.sessionId = p.sessionId, this.sessionSecret = p.sessionSecret, this.linkAPIUrl = p.linkAPIUrl, this.isParentConnection = p.isParentConnection;
    }
    attach(p) {
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-link-flow-root", p.appendChild(this.root), this.render();
    }
    setConnected(p) {
      this.connected !== p && (this.connected = p, this.render());
    }
    setChainId(p) {
      this.chainId !== p && (this.chainId = p, this.render());
    }
    detach() {
      var p;
      this.root && ((0, e.render)(null, this.root), (p = this.root.parentElement) === null || p === void 0 || p.removeChild(this.root));
    }
    setConnectDisabled(p) {
      this.connectDisabled = p;
    }
    open(p) {
      this.isOpen = !0, this.onCancel = p.onCancel, this.render();
    }
    close() {
      this.isOpen = !1, this.onCancel = null, this.render();
    }
    render() {
      this.root && (0, e.render)((0, e.h)(r.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.connected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
    }
  };
  return yr.LinkFlow = i, yr;
}
var en = {}, tn = {}, ra;
function ph() {
  return ra || (ra = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.default = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}"), tn;
}
var na;
function Wc() {
  return na || (na = 1, function(e) {
    var r = en.__importDefault || function(c) {
      return c && c.__esModule ? c : { default: c };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SnackbarInstance = e.SnackbarContainer = e.Snackbar = void 0;
    const i = r(Ur), t = We, p = wn, n = r(/* @__PURE__ */ ph()), u = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", o = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
    class d {
      constructor(h) {
        this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = h.darkMode;
      }
      attach(h) {
        this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", h.appendChild(this.root), this.render();
      }
      presentItem(h) {
        const s = this.nextItemKey++;
        return this.items.set(s, h), this.render(), () => {
          this.items.delete(s), this.render();
        };
      }
      clear() {
        this.items.clear(), this.render();
      }
      render() {
        this.root && (0, t.render)((0, t.h)(
          "div",
          null,
          (0, t.h)(e.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([h, s]) => (0, t.h)(e.SnackbarInstance, Object.assign({}, s, { key: h }))))
        ), this.root);
      }
    }
    e.Snackbar = d;
    const m = (c) => (0, t.h)(
      "div",
      { class: (0, i.default)("-cbwsdk-snackbar-container") },
      (0, t.h)("style", null, n.default),
      (0, t.h)("div", { class: "-cbwsdk-snackbar" }, c.children)
    );
    e.SnackbarContainer = m;
    const g = ({ autoExpand: c, message: h, menuItems: s }) => {
      const [f, b] = (0, p.useState)(!0), [v, a] = (0, p.useState)(c ?? !1);
      (0, p.useEffect)(() => {
        const S = [
          window.setTimeout(() => {
            b(!1);
          }, 1),
          window.setTimeout(() => {
            a(!0);
          }, 1e4)
        ];
        return () => {
          S.forEach(window.clearTimeout);
        };
      });
      const R = () => {
        a(!v);
      };
      return (0, t.h)(
        "div",
        { class: (0, i.default)("-cbwsdk-snackbar-instance", f && "-cbwsdk-snackbar-instance-hidden", v && "-cbwsdk-snackbar-instance-expanded") },
        (0, t.h)(
          "div",
          { class: "-cbwsdk-snackbar-instance-header", onClick: R },
          (0, t.h)("img", { src: u, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
          " ",
          (0, t.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, h),
          (0, t.h)(
            "div",
            { class: "-gear-container" },
            !v && (0, t.h)(
              "svg",
              { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              (0, t.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
            ),
            (0, t.h)("img", { src: o, class: "-gear-icon", title: "Expand" })
          )
        ),
        s && s.length > 0 && (0, t.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, s.map((S, I) => (0, t.h)(
          "div",
          { class: (0, i.default)("-cbwsdk-snackbar-instance-menu-item", S.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: S.onClick, key: I },
          (0, t.h)(
            "svg",
            { width: S.svgWidth, height: S.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, t.h)("path", { "fill-rule": S.defaultFillRule, "clip-rule": S.defaultClipRule, d: S.path, fill: "#AAAAAA" })
          ),
          (0, t.h)("span", { class: (0, i.default)("-cbwsdk-snackbar-instance-menu-item-info", S.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, S.info)
        )))
      );
    };
    e.SnackbarInstance = g;
  }(en)), en;
}
var ia;
function Vc() {
  if (ia) return wr;
  ia = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.WalletLinkRelayUI = void 0;
  const e = /* @__PURE__ */ Uc(), r = /* @__PURE__ */ fh(), i = /* @__PURE__ */ Wc();
  let t = class {
    constructor(n) {
      this.standalone = null, this.attached = !1, this.snackbar = new i.Snackbar({
        darkMode: n.darkMode
      }), this.linkFlow = new r.LinkFlow({
        darkMode: n.darkMode,
        version: n.version,
        sessionId: n.session.id,
        sessionSecret: n.session.secret,
        linkAPIUrl: n.linkAPIUrl,
        isParentConnection: !1
      });
    }
    attach() {
      if (this.attached)
        throw new Error("Coinbase Wallet SDK UI is already attached");
      const n = document.documentElement, u = document.createElement("div");
      u.className = "-cbwsdk-css-reset", n.appendChild(u), this.linkFlow.attach(u), this.snackbar.attach(u), this.attached = !0, (0, e.injectCssReset)();
    }
    setConnected(n) {
      this.linkFlow.setConnected(n);
    }
    setChainId(n) {
      this.linkFlow.setChainId(n);
    }
    setConnectDisabled(n) {
      this.linkFlow.setConnectDisabled(n);
    }
    /* istanbul ignore next */
    addEthereumChain() {
    }
    // no-op
    /* istanbul ignore next */
    watchAsset() {
    }
    // no-op
    /* istanbul ignore next */
    switchEthereumChain() {
    }
    // no-op
    requestEthereumAccounts(n) {
      this.linkFlow.open({ onCancel: n.onCancel });
    }
    hideRequestEthereumAccounts() {
      this.linkFlow.close();
    }
    /* istanbul ignore next */
    signEthereumMessage() {
    }
    // no-op
    /* istanbul ignore next */
    signEthereumTransaction() {
    }
    // no-op
    /* istanbul ignore next */
    submitEthereumTransaction() {
    }
    // no-op
    /* istanbul ignore next */
    ethereumAddressFromSignedMessage() {
    }
    // no-op
    showConnecting(n) {
      let u;
      return n.isUnlinkedErrorState ? u = {
        autoExpand: !0,
        message: "Connection lost",
        menuItems: [
          {
            isRed: !1,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: n.onResetConnection
          }
        ]
      } : u = {
        message: "Confirm on phone",
        menuItems: [
          {
            isRed: !0,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: n.onCancel
          },
          {
            isRed: !1,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: n.onResetConnection
          }
        ]
      }, this.snackbar.presentItem(u);
    }
    /* istanbul ignore next */
    reloadUI() {
      document.location.reload();
    }
    /* istanbul ignore next */
    inlineAccountsResponse() {
      return !1;
    }
    /* istanbul ignore next */
    inlineAddEthereumChain() {
      return !1;
    }
    /* istanbul ignore next */
    inlineWatchAsset() {
      return !1;
    }
    /* istanbul ignore next */
    inlineSwitchEthereumChain() {
      return !1;
    }
    /* istanbul ignore next */
    setStandalone(n) {
      this.standalone = n;
    }
    /* istanbul ignore next */
    isStandalone() {
      var n;
      return (n = this.standalone) !== null && n !== void 0 ? n : !1;
    }
  };
  return wr.WalletLinkRelayUI = t, wr;
}
var sa;
function zc() {
  if (sa) return lr;
  sa = 1, Object.defineProperty(lr, "__esModule", { value: !0 }), lr.WalletLinkRelay = void 0;
  const e = /* @__PURE__ */ pn(), r = /* @__PURE__ */ gn(), i = /* @__PURE__ */ tt(), t = /* @__PURE__ */ Os(), p = /* @__PURE__ */ Fs(), n = /* @__PURE__ */ Ds(), u = /* @__PURE__ */ Gl(), o = /* @__PURE__ */ Ns(), d = /* @__PURE__ */ Vc();
  let m = class Ct extends p.RelayAbstract {
    constructor(c) {
      var h;
      super(), this.accountsCallback = null, this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.chainCallback = null, this.dappDefaultChain = 1, this.appName = "", this.appLogoUrl = null, this.linkedUpdated = (v) => {
        var a;
        this.isLinked = v;
        const R = this.storage.getItem(p.LOCAL_STORAGE_ADDRESSES_KEY);
        if (v && (this.session.linked = v), this.isUnlinkedErrorState = !1, R) {
          const S = R.split(" "), I = this.storage.getItem("IsStandaloneSigning") === "true";
          if (S[0] !== "" && !v && this.session.linked && !I) {
            this.isUnlinkedErrorState = !0;
            const T = this.getSessionIdHash();
            (a = this.diagnostic) === null || a === void 0 || a.log(t.EVENTS.UNLINKED_ERROR_STATE, {
              sessionIdHash: T
            });
          }
        }
      }, this.metadataUpdated = (v, a) => {
        this.storage.setItem(v, a);
      }, this.chainUpdated = (v, a) => {
        this.chainCallbackParams.chainId === v && this.chainCallbackParams.jsonRpcUrl === a || (this.chainCallbackParams = {
          chainId: v,
          jsonRpcUrl: a
        }, this.chainCallback && this.chainCallback(v, a));
      }, this.accountUpdated = (v) => {
        this.accountsCallback && this.accountsCallback([v]), Ct.accountRequestCallbackIds.size > 0 && (Array.from(Ct.accountRequestCallbackIds.values()).forEach((a) => {
          const R = {
            type: "WEB3_RESPONSE",
            id: a,
            response: {
              method: "requestEthereumAccounts",
              result: [v]
            }
          };
          this.invokeCallback(Object.assign(Object.assign({}, R), { id: a }));
        }), Ct.accountRequestCallbackIds.clear());
      }, this.connectedUpdated = (v) => {
        this.ui.setConnected(v);
      }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = c.linkAPIUrl, this.storage = c.storage, this.options = c;
      const { session: s, ui: f, connection: b } = this.subscribe();
      this._session = s, this.connection = b, this.relayEventManager = c.relayEventManager, this.diagnostic = c.diagnosticLogger, this._reloadOnDisconnect = (h = c.reloadOnDisconnect) !== null && h !== void 0 ? h : !0, this.ui = f;
    }
    subscribe() {
      const c = n.Session.load(this.storage) || new n.Session(this.storage).save(), { linkAPIUrl: h, diagnostic: s } = this, f = new u.WalletLinkConnection({
        session: c,
        linkAPIUrl: h,
        diagnostic: s,
        listener: this
      }), { version: b, darkMode: v } = this.options, a = this.options.uiConstructor({
        linkAPIUrl: h,
        version: b,
        darkMode: v,
        session: c
      });
      return f.connect(), { session: c, ui: a, connection: f };
    }
    attachUI() {
      this.ui.attach();
    }
    resetAndReload() {
      Promise.race([
        this.connection.setSessionMetadata("__destroyed", "1"),
        new Promise((c) => setTimeout(() => c(null), 1e3))
      ]).then(() => {
        var c, h;
        const s = this.ui.isStandalone();
        (c = this.diagnostic) === null || c === void 0 || c.log(t.EVENTS.SESSION_STATE_CHANGE, {
          method: "relay::resetAndReload",
          sessionMetadataChange: "__destroyed, 1",
          sessionIdHash: this.getSessionIdHash()
        }), this.connection.destroy();
        const f = n.Session.load(this.storage);
        if ((f == null ? void 0 : f.id) === this._session.id ? this.storage.clear() : f && ((h = this.diagnostic) === null || h === void 0 || h.log(t.EVENTS.SKIPPED_CLEARING_SESSION, {
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: n.Session.hash(f.id)
        })), this._reloadOnDisconnect) {
          this.ui.reloadUI();
          return;
        }
        this.accountsCallback && this.accountsCallback([], !0);
        const { session: b, ui: v, connection: a } = this.subscribe();
        this._session = b, this.connection = a, this.ui = v, s && this.ui.setStandalone && this.ui.setStandalone(!0), this.options.headlessMode || this.attachUI();
      }).catch((c) => {
        var h;
        (h = this.diagnostic) === null || h === void 0 || h.log(t.EVENTS.FAILURE, {
          method: "relay::resetAndReload",
          message: `failed to reset and reload with ${c}`,
          sessionIdHash: this.getSessionIdHash()
        });
      });
    }
    setAppInfo(c, h) {
      this.appName = c, this.appLogoUrl = h;
    }
    getStorageItem(c) {
      return this.storage.getItem(c);
    }
    get session() {
      return this._session;
    }
    setStorageItem(c, h) {
      this.storage.setItem(c, h);
    }
    signEthereumMessage(c, h, s, f) {
      return this.sendRequest({
        method: "signEthereumMessage",
        params: {
          message: (0, i.hexStringFromBuffer)(c, !0),
          address: h,
          addPrefix: s,
          typedDataJson: f || null
        }
      });
    }
    ethereumAddressFromSignedMessage(c, h, s) {
      return this.sendRequest({
        method: "ethereumAddressFromSignedMessage",
        params: {
          message: (0, i.hexStringFromBuffer)(c, !0),
          signature: (0, i.hexStringFromBuffer)(h, !0),
          addPrefix: s
        }
      });
    }
    signEthereumTransaction(c) {
      return this.sendRequest({
        method: "signEthereumTransaction",
        params: {
          fromAddress: c.fromAddress,
          toAddress: c.toAddress,
          weiValue: (0, i.bigIntStringFromBN)(c.weiValue),
          data: (0, i.hexStringFromBuffer)(c.data, !0),
          nonce: c.nonce,
          gasPriceInWei: c.gasPriceInWei ? (0, i.bigIntStringFromBN)(c.gasPriceInWei) : null,
          maxFeePerGas: c.gasPriceInWei ? (0, i.bigIntStringFromBN)(c.gasPriceInWei) : null,
          maxPriorityFeePerGas: c.gasPriceInWei ? (0, i.bigIntStringFromBN)(c.gasPriceInWei) : null,
          gasLimit: c.gasLimit ? (0, i.bigIntStringFromBN)(c.gasLimit) : null,
          chainId: c.chainId,
          shouldSubmit: !1
        }
      });
    }
    signAndSubmitEthereumTransaction(c) {
      return this.sendRequest({
        method: "signEthereumTransaction",
        params: {
          fromAddress: c.fromAddress,
          toAddress: c.toAddress,
          weiValue: (0, i.bigIntStringFromBN)(c.weiValue),
          data: (0, i.hexStringFromBuffer)(c.data, !0),
          nonce: c.nonce,
          gasPriceInWei: c.gasPriceInWei ? (0, i.bigIntStringFromBN)(c.gasPriceInWei) : null,
          maxFeePerGas: c.maxFeePerGas ? (0, i.bigIntStringFromBN)(c.maxFeePerGas) : null,
          maxPriorityFeePerGas: c.maxPriorityFeePerGas ? (0, i.bigIntStringFromBN)(c.maxPriorityFeePerGas) : null,
          gasLimit: c.gasLimit ? (0, i.bigIntStringFromBN)(c.gasLimit) : null,
          chainId: c.chainId,
          shouldSubmit: !0
        }
      });
    }
    submitEthereumTransaction(c, h) {
      return this.sendRequest({
        method: "submitEthereumTransaction",
        params: {
          signedTransaction: (0, i.hexStringFromBuffer)(c, !0),
          chainId: h
        }
      });
    }
    scanQRCode(c) {
      return this.sendRequest({
        method: "scanQRCode",
        params: {
          regExp: c
        }
      });
    }
    getQRCodeUrl() {
      return (0, i.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, !1, this.options.version, this.dappDefaultChain);
    }
    genericRequest(c, h) {
      return this.sendRequest({
        method: "generic",
        params: {
          action: h,
          data: c
        }
      });
    }
    sendGenericMessage(c) {
      return this.sendRequest(c);
    }
    sendRequest(c) {
      let h = null;
      const s = (0, i.randomBytesHex)(8), f = (v) => {
        this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, c.method, v), h == null || h();
      };
      return { promise: new Promise((v, a) => {
        this.ui.isStandalone() || (h = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: f,
          onResetConnection: this.resetAndReload
          // eslint-disable-line @typescript-eslint/unbound-method
        })), this.relayEventManager.callbacks.set(s, (R) => {
          if (h == null || h(), (0, o.isErrorResponse)(R))
            return a(new Error(R.errorMessage));
          v(R);
        }), this.ui.isStandalone() ? this.sendRequestStandalone(s, c) : this.publishWeb3RequestEvent(s, c);
      }), cancel: f };
    }
    setConnectDisabled(c) {
      this.ui.setConnectDisabled(c);
    }
    setAccountsCallback(c) {
      this.accountsCallback = c;
    }
    setChainCallback(c) {
      this.chainCallback = c;
    }
    setDappDefaultChainCallback(c) {
      this.dappDefaultChain = c, this.ui instanceof d.WalletLinkRelayUI && this.ui.setChainId(c);
    }
    publishWeb3RequestEvent(c, h) {
      var s;
      const f = { type: "WEB3_REQUEST", id: c, request: h }, b = n.Session.load(this.storage);
      (s = this.diagnostic) === null || s === void 0 || s.log(t.EVENTS.WEB3_REQUEST, {
        eventId: f.id,
        method: `relay::${h.method}`,
        sessionIdHash: this.getSessionIdHash(),
        storedSessionIdHash: b ? n.Session.hash(b.id) : "",
        isSessionMismatched: ((b == null ? void 0 : b.id) !== this._session.id).toString()
      }), this.publishEvent("Web3Request", f, !0).then((v) => {
        var a;
        (a = this.diagnostic) === null || a === void 0 || a.log(t.EVENTS.WEB3_REQUEST_PUBLISHED, {
          eventId: f.id,
          method: `relay::${h.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: b ? n.Session.hash(b.id) : "",
          isSessionMismatched: ((b == null ? void 0 : b.id) !== this._session.id).toString()
        });
      }).catch((v) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: f.id,
          response: {
            method: h.method,
            errorMessage: v.message
          }
        });
      });
    }
    publishWeb3RequestCanceledEvent(c) {
      const h = {
        type: "WEB3_REQUEST_CANCELED",
        id: c
      };
      this.publishEvent("Web3RequestCanceled", h, !1).then();
    }
    publishEvent(c, h, s) {
      return this.connection.publishEvent(c, h, s);
    }
    handleWeb3ResponseMessage(c) {
      var h;
      const { response: s } = c;
      if ((h = this.diagnostic) === null || h === void 0 || h.log(t.EVENTS.WEB3_RESPONSE, {
        eventId: c.id,
        method: `relay::${s.method}`,
        sessionIdHash: this.getSessionIdHash()
      }), s.method === "requestEthereumAccounts") {
        Ct.accountRequestCallbackIds.forEach((f) => this.invokeCallback(Object.assign(Object.assign({}, c), { id: f }))), Ct.accountRequestCallbackIds.clear();
        return;
      }
      this.invokeCallback(c);
    }
    handleErrorResponse(c, h, s, f) {
      var b;
      const v = (b = s == null ? void 0 : s.message) !== null && b !== void 0 ? b : (0, e.getMessageFromCode)(f);
      this.handleWeb3ResponseMessage({
        type: "WEB3_RESPONSE",
        id: c,
        response: {
          method: h,
          errorMessage: v,
          errorCode: f
        }
      });
    }
    invokeCallback(c) {
      const h = this.relayEventManager.callbacks.get(c.id);
      h && (h(c.response), this.relayEventManager.callbacks.delete(c.id));
    }
    requestEthereumAccounts() {
      const c = {
        method: "requestEthereumAccounts",
        params: {
          appName: this.appName,
          appLogoUrl: this.appLogoUrl || null
        }
      }, h = (0, i.randomBytesHex)(8), s = (b) => {
        this.publishWeb3RequestCanceledEvent(h), this.handleErrorResponse(h, c.method, b);
      };
      return { promise: new Promise((b, v) => {
        if (this.relayEventManager.callbacks.set(h, (a) => {
          if (this.ui.hideRequestEthereumAccounts(), (0, o.isErrorResponse)(a))
            return v(new Error(a.errorMessage));
          b(a);
        }), this.ui.inlineAccountsResponse()) {
          const a = (R) => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: h,
              response: { method: "requestEthereumAccounts", result: R }
            });
          };
          this.ui.requestEthereumAccounts({
            onCancel: s,
            onAccounts: a
          });
        } else {
          const a = e.standardErrors.provider.userRejectedRequest("User denied account authorization");
          this.ui.requestEthereumAccounts({
            onCancel: () => s(a)
          });
        }
        Ct.accountRequestCallbackIds.add(h), !this.ui.inlineAccountsResponse() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(h, c);
      }), cancel: s };
    }
    selectProvider(c) {
      const h = {
        method: "selectProvider",
        params: {
          providerOptions: c
        }
      }, s = (0, i.randomBytesHex)(8), f = (v) => {
        this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, h.method, v);
      }, b = new Promise((v, a) => {
        this.relayEventManager.callbacks.set(s, (I) => {
          if ((0, o.isErrorResponse)(I))
            return a(new Error(I.errorMessage));
          v(I);
        });
        const R = (I) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: s,
            response: { method: "selectProvider", result: r.ProviderType.Unselected }
          });
        }, S = (I) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: s,
            response: { method: "selectProvider", result: I }
          });
        };
        this.ui.selectProvider && this.ui.selectProvider({
          onApprove: S,
          onCancel: R,
          providerOptions: c
        });
      });
      return { cancel: f, promise: b };
    }
    watchAsset(c, h, s, f, b, v) {
      const a = {
        method: "watchAsset",
        params: {
          type: c,
          options: {
            address: h,
            symbol: s,
            decimals: f,
            image: b
          },
          chainId: v
        }
      };
      let R = null;
      const S = (0, i.randomBytesHex)(8), I = (q) => {
        this.publishWeb3RequestCanceledEvent(S), this.handleErrorResponse(S, a.method, q), R == null || R();
      };
      this.ui.inlineWatchAsset() || (R = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: I,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      }));
      const T = new Promise((q, D) => {
        this.relayEventManager.callbacks.set(S, (ee) => {
          if (R == null || R(), (0, o.isErrorResponse)(ee))
            return D(new Error(ee.errorMessage));
          q(ee);
        });
        const H = (ee) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "watchAsset",
              result: !1
            }
          });
        }, G = () => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "watchAsset",
              result: !0
            }
          });
        };
        this.ui.inlineWatchAsset() && this.ui.watchAsset({
          onApprove: G,
          onCancel: H,
          type: c,
          address: h,
          symbol: s,
          decimals: f,
          image: b,
          chainId: v
        }), !this.ui.inlineWatchAsset() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(S, a);
      });
      return { cancel: I, promise: T };
    }
    addEthereumChain(c, h, s, f, b, v) {
      const a = {
        method: "addEthereumChain",
        params: {
          chainId: c,
          rpcUrls: h,
          blockExplorerUrls: f,
          chainName: b,
          iconUrls: s,
          nativeCurrency: v
        }
      };
      let R = null;
      const S = (0, i.randomBytesHex)(8), I = (q) => {
        this.publishWeb3RequestCanceledEvent(S), this.handleErrorResponse(S, a.method, q), R == null || R();
      };
      return this.ui.inlineAddEthereumChain(c) || (R = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: I,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      })), { promise: new Promise((q, D) => {
        this.relayEventManager.callbacks.set(S, (ee) => {
          if (R == null || R(), (0, o.isErrorResponse)(ee))
            return D(new Error(ee.errorMessage));
          q(ee);
        });
        const H = (ee) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "addEthereumChain",
              result: {
                isApproved: !1,
                rpcUrl: ""
              }
            }
          });
        }, G = (ee) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "addEthereumChain",
              result: {
                isApproved: !0,
                rpcUrl: ee
              }
            }
          });
        };
        this.ui.inlineAddEthereumChain(c) && this.ui.addEthereumChain({
          onCancel: H,
          onApprove: G,
          chainId: a.params.chainId,
          rpcUrls: a.params.rpcUrls,
          blockExplorerUrls: a.params.blockExplorerUrls,
          chainName: a.params.chainName,
          iconUrls: a.params.iconUrls,
          nativeCurrency: a.params.nativeCurrency
        }), !this.ui.inlineAddEthereumChain(c) && !this.ui.isStandalone() && this.publishWeb3RequestEvent(S, a);
      }), cancel: I };
    }
    switchEthereumChain(c, h) {
      const s = {
        method: "switchEthereumChain",
        params: Object.assign({ chainId: c }, { address: h })
      }, f = (0, i.randomBytesHex)(8), b = (a) => {
        this.publishWeb3RequestCanceledEvent(f), this.handleErrorResponse(f, s.method, a);
      };
      return { promise: new Promise((a, R) => {
        this.relayEventManager.callbacks.set(f, (T) => {
          if ((0, o.isErrorResponse)(T) && T.errorCode)
            return R(e.standardErrors.provider.custom({
              code: T.errorCode,
              message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
            }));
          if ((0, o.isErrorResponse)(T))
            return R(new Error(T.errorMessage));
          a(T);
        });
        const S = (T) => {
          var q;
          if (T) {
            const D = (q = (0, e.getErrorCode)(T)) !== null && q !== void 0 ? q : e.standardErrorCodes.provider.unsupportedChain;
            this.handleErrorResponse(f, "switchEthereumChain", T instanceof Error ? T : e.standardErrors.provider.unsupportedChain(c), D);
          } else
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: f,
              response: {
                method: "switchEthereumChain",
                result: {
                  isApproved: !1,
                  rpcUrl: ""
                }
              }
            });
        }, I = (T) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: f,
            response: {
              method: "switchEthereumChain",
              result: {
                isApproved: !0,
                rpcUrl: T
              }
            }
          });
        };
        this.ui.switchEthereumChain({
          onCancel: S,
          onApprove: I,
          chainId: s.params.chainId,
          address: s.params.address
        }), !this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(f, s);
      }), cancel: b };
    }
    inlineAddEthereumChain(c) {
      return this.ui.inlineAddEthereumChain(c);
    }
    getSessionIdHash() {
      return n.Session.hash(this._session.id);
    }
    sendRequestStandalone(c, h) {
      const s = (b) => {
        this.handleErrorResponse(c, h.method, b);
      }, f = (b) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: c,
          response: b
        });
      };
      switch (h.method) {
        case "signEthereumMessage":
          this.ui.signEthereumMessage({
            request: h,
            onSuccess: f,
            onCancel: s
          });
          break;
        case "signEthereumTransaction":
          this.ui.signEthereumTransaction({
            request: h,
            onSuccess: f,
            onCancel: s
          });
          break;
        case "submitEthereumTransaction":
          this.ui.submitEthereumTransaction({
            request: h,
            onSuccess: f,
            onCancel: s
          });
          break;
        case "ethereumAddressFromSignedMessage":
          this.ui.ethereumAddressFromSignedMessage({
            request: h,
            onSuccess: f
          });
          break;
        default:
          s();
          break;
      }
    }
  };
  return lr.WalletLinkRelay = m, m.accountRequestCallbackIds = /* @__PURE__ */ new Set(), lr;
}
var Mr = {}, Wt = {}, kr = {}, oa;
function gh() {
  return oa || (oa = 1, function(e) {
    var r = kr.__createBinding || (Object.create ? function(t, p, n, u) {
      u === void 0 && (u = n);
      var o = Object.getOwnPropertyDescriptor(p, n);
      (!o || ("get" in o ? !p.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return p[n];
      } }), Object.defineProperty(t, u, o);
    } : function(t, p, n, u) {
      u === void 0 && (u = n), t[u] = p[n];
    }), i = kr.__exportStar || function(t, p) {
      for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(p, n) && r(p, t, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), i(/* @__PURE__ */ Wc(), e);
  }(kr)), kr;
}
var rn = {}, aa;
function mh() {
  return aa || (aa = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.default = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}"), rn;
}
var ua;
function wh() {
  if (ua) return Wt;
  ua = 1;
  var e = Wt.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(Wt, "__esModule", { value: !0 }), Wt.RedirectDialog = void 0;
  const r = e(Ur), i = We, t = /* @__PURE__ */ Uc(), p = /* @__PURE__ */ gh(), n = e(/* @__PURE__ */ mh());
  let u = class {
    constructor() {
      this.root = null;
    }
    attach() {
      const m = document.documentElement;
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", m.appendChild(this.root), (0, t.injectCssReset)();
    }
    present(m) {
      this.render(m);
    }
    clear() {
      this.render(null);
    }
    render(m) {
      this.root && ((0, i.render)(null, this.root), m && (0, i.render)((0, i.h)(o, Object.assign({}, m, { onDismiss: () => {
        this.clear();
      } })), this.root));
    }
  };
  Wt.RedirectDialog = u;
  const o = ({ title: d, buttonText: m, darkMode: g, onButtonClick: c, onDismiss: h }) => {
    const s = g ? "dark" : "light";
    return (0, i.h)(
      p.SnackbarContainer,
      { darkMode: g },
      (0, i.h)(
        "div",
        { class: "-cbwsdk-redirect-dialog" },
        (0, i.h)("style", null, n.default),
        (0, i.h)("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: h }),
        (0, i.h)(
          "div",
          { class: (0, r.default)("-cbwsdk-redirect-dialog-box", s) },
          (0, i.h)("p", null, d),
          (0, i.h)("button", { onClick: c }, m)
        )
      )
    );
  };
  return Wt;
}
var ca;
function Jc() {
  if (ca) return Mr;
  ca = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.MobileRelayUI = void 0;
  const e = /* @__PURE__ */ wh();
  let r = class {
    constructor(t) {
      this.attached = !1, this.darkMode = !1, this.redirectDialog = new e.RedirectDialog(), this.darkMode = t.darkMode;
    }
    attach() {
      if (this.attached)
        throw new Error("Coinbase Wallet SDK UI is already attached");
      this.redirectDialog.attach(), this.attached = !0;
    }
    setConnected(t) {
    }
    // no-op
    redirectToCoinbaseWallet(t) {
      const p = new URL("https://go.cb-w.com/walletlink");
      p.searchParams.append("redirect_url", window.location.href), t && p.searchParams.append("wl_url", t);
      const n = document.createElement("a");
      n.target = "cbw-opener", n.href = p.href, n.rel = "noreferrer noopener", n.click();
    }
    openCoinbaseWalletDeeplink(t) {
      this.redirectDialog.present({
        title: "Redirecting to Coinbase Wallet...",
        buttonText: "Open",
        darkMode: this.darkMode,
        onButtonClick: () => {
          this.redirectToCoinbaseWallet(t);
        }
      }), setTimeout(() => {
        this.redirectToCoinbaseWallet(t);
      }, 99);
    }
    showConnecting(t) {
      return () => {
        this.redirectDialog.clear();
      };
    }
    hideRequestEthereumAccounts() {
      this.redirectDialog.clear();
    }
    // -- Methods below are not needed for mobile
    requestEthereumAccounts() {
    }
    // no-op
    addEthereumChain() {
    }
    // no-op
    watchAsset() {
    }
    // no-op
    selectProvider() {
    }
    // no-op
    switchEthereumChain() {
    }
    // no-op
    signEthereumMessage() {
    }
    // no-op
    signEthereumTransaction() {
    }
    // no-op
    submitEthereumTransaction() {
    }
    // no-op
    ethereumAddressFromSignedMessage() {
    }
    // no-op
    reloadUI() {
    }
    // no-op
    setStandalone() {
    }
    // no-op
    setConnectDisabled() {
    }
    // no-op
    inlineAccountsResponse() {
      return !1;
    }
    inlineAddEthereumChain() {
      return !1;
    }
    inlineWatchAsset() {
      return !1;
    }
    inlineSwitchEthereumChain() {
      return !1;
    }
    isStandalone() {
      return !1;
    }
  };
  return Mr.MobileRelayUI = r, Mr;
}
var la;
function Gc() {
  if (la) return cr;
  la = 1, Object.defineProperty(cr, "__esModule", { value: !0 }), cr.MobileRelay = void 0;
  const e = /* @__PURE__ */ tt(), r = /* @__PURE__ */ zc(), i = /* @__PURE__ */ Jc();
  let t = class extends r.WalletLinkRelay {
    constructor(n) {
      var u;
      super(n), this._enableMobileWalletLink = (u = n.enableMobileWalletLink) !== null && u !== void 0 ? u : !1;
    }
    // override
    requestEthereumAccounts() {
      return this._enableMobileWalletLink ? super.requestEthereumAccounts() : {
        promise: new Promise(() => {
          const n = (0, e.getLocation)();
          n.href = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(n.href)}`;
        }),
        cancel: () => {
        }
      };
    }
    // override
    publishWeb3RequestEvent(n, u) {
      if (super.publishWeb3RequestEvent(n, u), !(this._enableMobileWalletLink && this.ui instanceof i.MobileRelayUI))
        return;
      let o = !1;
      switch (u.method) {
        case "requestEthereumAccounts":
        case "connectAndSignIn":
          o = !0, this.ui.openCoinbaseWalletDeeplink(this.getQRCodeUrl());
          break;
        case "switchEthereumChain":
          return;
        default:
          o = !0, this.ui.openCoinbaseWalletDeeplink();
          break;
      }
      o && window.addEventListener("blur", () => {
        window.addEventListener("focus", () => {
          this.connection.checkUnseenEvents();
        }, { once: !0 });
      }, { once: !0 });
    }
    // override
    handleWeb3ResponseMessage(n) {
      super.handleWeb3ResponseMessage(n);
    }
    connectAndSignIn(n) {
      if (!this._enableMobileWalletLink)
        throw new Error("connectAndSignIn is supported only when enableMobileWalletLink is on");
      return this.sendRequest({
        method: "connectAndSignIn",
        params: {
          appName: this.appName,
          appLogoUrl: this.appLogoUrl,
          domain: window.location.hostname,
          aud: window.location.href,
          version: "1",
          type: "eip4361",
          nonce: n.nonce,
          iat: (/* @__PURE__ */ new Date()).toISOString(),
          chainId: `eip155:${this.dappDefaultChain}`,
          statement: n.statement,
          resources: n.resources
        }
      });
    }
  };
  return cr.MobileRelay = t, cr;
}
var nn = { exports: {} }, $n, ha;
function Zc() {
  return ha || (ha = 1, $n = hn().EventEmitter), $n;
}
var Un, da;
function yh() {
  if (da) return Un;
  da = 1;
  function e(f, b) {
    var v = Object.keys(f);
    if (Object.getOwnPropertySymbols) {
      var a = Object.getOwnPropertySymbols(f);
      b && (a = a.filter(function(R) {
        return Object.getOwnPropertyDescriptor(f, R).enumerable;
      })), v.push.apply(v, a);
    }
    return v;
  }
  function r(f) {
    for (var b = 1; b < arguments.length; b++) {
      var v = arguments[b] != null ? arguments[b] : {};
      b % 2 ? e(Object(v), !0).forEach(function(a) {
        i(f, a, v[a]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(f, Object.getOwnPropertyDescriptors(v)) : e(Object(v)).forEach(function(a) {
        Object.defineProperty(f, a, Object.getOwnPropertyDescriptor(v, a));
      });
    }
    return f;
  }
  function i(f, b, v) {
    return b = u(b), b in f ? Object.defineProperty(f, b, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : f[b] = v, f;
  }
  function t(f, b) {
    if (!(f instanceof b))
      throw new TypeError("Cannot call a class as a function");
  }
  function p(f, b) {
    for (var v = 0; v < b.length; v++) {
      var a = b[v];
      a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(f, u(a.key), a);
    }
  }
  function n(f, b, v) {
    return p(f.prototype, b), Object.defineProperty(f, "prototype", { writable: !1 }), f;
  }
  function u(f) {
    var b = o(f, "string");
    return typeof b == "symbol" ? b : String(b);
  }
  function o(f, b) {
    if (typeof f != "object" || f === null) return f;
    var v = f[Symbol.toPrimitive];
    if (v !== void 0) {
      var a = v.call(f, b);
      if (typeof a != "object") return a;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(f);
  }
  var d = mn(), m = d.Buffer, g = Ls, c = g.inspect, h = c && c.custom || "inspect";
  function s(f, b, v) {
    m.prototype.copy.call(f, b, v);
  }
  return Un = /* @__PURE__ */ function() {
    function f() {
      t(this, f), this.head = null, this.tail = null, this.length = 0;
    }
    return n(f, [{
      key: "push",
      value: function(v) {
        var a = {
          data: v,
          next: null
        };
        this.length > 0 ? this.tail.next = a : this.head = a, this.tail = a, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(v) {
        var a = {
          data: v,
          next: this.head
        };
        this.length === 0 && (this.tail = a), this.head = a, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var v = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, v;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(v) {
        if (this.length === 0) return "";
        for (var a = this.head, R = "" + a.data; a = a.next; ) R += v + a.data;
        return R;
      }
    }, {
      key: "concat",
      value: function(v) {
        if (this.length === 0) return m.alloc(0);
        for (var a = m.allocUnsafe(v >>> 0), R = this.head, S = 0; R; )
          s(R.data, a, S), S += R.data.length, R = R.next;
        return a;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(v, a) {
        var R;
        return v < this.head.data.length ? (R = this.head.data.slice(0, v), this.head.data = this.head.data.slice(v)) : v === this.head.data.length ? R = this.shift() : R = a ? this._getString(v) : this._getBuffer(v), R;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(v) {
        var a = this.head, R = 1, S = a.data;
        for (v -= S.length; a = a.next; ) {
          var I = a.data, T = v > I.length ? I.length : v;
          if (T === I.length ? S += I : S += I.slice(0, v), v -= T, v === 0) {
            T === I.length ? (++R, a.next ? this.head = a.next : this.head = this.tail = null) : (this.head = a, a.data = I.slice(T));
            break;
          }
          ++R;
        }
        return this.length -= R, S;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(v) {
        var a = m.allocUnsafe(v), R = this.head, S = 1;
        for (R.data.copy(a), v -= R.data.length; R = R.next; ) {
          var I = R.data, T = v > I.length ? I.length : v;
          if (I.copy(a, a.length - v, 0, T), v -= T, v === 0) {
            T === I.length ? (++S, R.next ? this.head = R.next : this.head = this.tail = null) : (this.head = R, R.data = I.slice(T));
            break;
          }
          ++S;
        }
        return this.length -= S, a;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: h,
      value: function(v, a) {
        return c(this, r(r({}, a), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), f;
  }(), Un;
}
var Hn, fa;
function Kc() {
  if (fa) return Hn;
  fa = 1;
  function e(u, o) {
    var d = this, m = this._readableState && this._readableState.destroyed, g = this._writableState && this._writableState.destroyed;
    return m || g ? (o ? o(u) : u && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(p, this, u)) : process.nextTick(p, this, u)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(u || null, function(c) {
      !o && c ? d._writableState ? d._writableState.errorEmitted ? process.nextTick(i, d) : (d._writableState.errorEmitted = !0, process.nextTick(r, d, c)) : process.nextTick(r, d, c) : o ? (process.nextTick(i, d), o(c)) : process.nextTick(i, d);
    }), this);
  }
  function r(u, o) {
    p(u, o), i(u);
  }
  function i(u) {
    u._writableState && !u._writableState.emitClose || u._readableState && !u._readableState.emitClose || u.emit("close");
  }
  function t() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function p(u, o) {
    u.emit("error", o);
  }
  function n(u, o) {
    var d = u._readableState, m = u._writableState;
    d && d.autoDestroy || m && m.autoDestroy ? u.destroy(o) : u.emit("error", o);
  }
  return Hn = {
    destroy: e,
    undestroy: t,
    errorOrDestroy: n
  }, Hn;
}
var Wn = {}, pa;
function Yt() {
  if (pa) return Wn;
  pa = 1;
  function e(o, d) {
    o.prototype = Object.create(d.prototype), o.prototype.constructor = o, o.__proto__ = d;
  }
  var r = {};
  function i(o, d, m) {
    m || (m = Error);
    function g(h, s, f) {
      return typeof d == "string" ? d : d(h, s, f);
    }
    var c = /* @__PURE__ */ function(h) {
      e(s, h);
      function s(f, b, v) {
        return h.call(this, g(f, b, v)) || this;
      }
      return s;
    }(m);
    c.prototype.name = m.name, c.prototype.code = o, r[o] = c;
  }
  function t(o, d) {
    if (Array.isArray(o)) {
      var m = o.length;
      return o = o.map(function(g) {
        return String(g);
      }), m > 2 ? "one of ".concat(d, " ").concat(o.slice(0, m - 1).join(", "), ", or ") + o[m - 1] : m === 2 ? "one of ".concat(d, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(d, " ").concat(o[0]);
    } else
      return "of ".concat(d, " ").concat(String(o));
  }
  function p(o, d, m) {
    return o.substr(0, d.length) === d;
  }
  function n(o, d, m) {
    return (m === void 0 || m > o.length) && (m = o.length), o.substring(m - d.length, m) === d;
  }
  function u(o, d, m) {
    return typeof m != "number" && (m = 0), m + d.length > o.length ? !1 : o.indexOf(d, m) !== -1;
  }
  return i("ERR_INVALID_OPT_VALUE", function(o, d) {
    return 'The value "' + d + '" is invalid for option "' + o + '"';
  }, TypeError), i("ERR_INVALID_ARG_TYPE", function(o, d, m) {
    var g;
    typeof d == "string" && p(d, "not ") ? (g = "must not be", d = d.replace(/^not /, "")) : g = "must be";
    var c;
    if (n(o, " argument"))
      c = "The ".concat(o, " ").concat(g, " ").concat(t(d, "type"));
    else {
      var h = u(o, ".") ? "property" : "argument";
      c = 'The "'.concat(o, '" ').concat(h, " ").concat(g, " ").concat(t(d, "type"));
    }
    return c += ". Received type ".concat(typeof m), c;
  }, TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
    return "The " + o + " method is not implemented";
  }), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", function(o) {
    return "Cannot call " + o + " after a stream was destroyed";
  }), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", function(o) {
    return "Unknown encoding: " + o;
  }, TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Wn.codes = r, Wn;
}
var Vn, ga;
function Qc() {
  if (ga) return Vn;
  ga = 1;
  var e = Yt().codes.ERR_INVALID_OPT_VALUE;
  function r(t, p, n) {
    return t.highWaterMark != null ? t.highWaterMark : p ? t[n] : null;
  }
  function i(t, p, n, u) {
    var o = r(p, u, n);
    if (o != null) {
      if (!(isFinite(o) && Math.floor(o) === o) || o < 0) {
        var d = u ? n : "highWaterMark";
        throw new e(d, o);
      }
      return Math.floor(o);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  return Vn = {
    getHighWaterMark: i
  }, Vn;
}
var zn, ma;
function bh() {
  if (ma) return zn;
  ma = 1, zn = e;
  function e(i, t) {
    if (r("noDeprecation"))
      return i;
    var p = !1;
    function n() {
      if (!p) {
        if (r("throwDeprecation"))
          throw new Error(t);
        r("traceDeprecation") ? console.trace(t) : console.warn(t), p = !0;
      }
      return i.apply(this, arguments);
    }
    return n;
  }
  function r(i) {
    try {
      if (!Zt.localStorage) return !1;
    } catch {
      return !1;
    }
    var t = Zt.localStorage[i];
    return t == null ? !1 : String(t).toLowerCase() === "true";
  }
  return zn;
}
var Jn, wa;
function Yc() {
  if (wa) return Jn;
  wa = 1, Jn = H;
  function e($) {
    var W = this;
    this.next = null, this.entry = null, this.finish = function() {
      K(W, $);
    };
  }
  var r;
  H.WritableState = q;
  var i = {
    deprecate: bh()
  }, t = Zc(), p = mn().Buffer, n = (typeof Zt < "u" ? Zt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function u($) {
    return p.from($);
  }
  function o($) {
    return p.isBuffer($) || $ instanceof n;
  }
  var d = Kc(), m = Qc(), g = m.getHighWaterMark, c = Yt().codes, h = c.ERR_INVALID_ARG_TYPE, s = c.ERR_METHOD_NOT_IMPLEMENTED, f = c.ERR_MULTIPLE_CALLBACK, b = c.ERR_STREAM_CANNOT_PIPE, v = c.ERR_STREAM_DESTROYED, a = c.ERR_STREAM_NULL_VALUES, R = c.ERR_STREAM_WRITE_AFTER_END, S = c.ERR_UNKNOWN_ENCODING, I = d.errorOrDestroy;
  Qe()(H, t);
  function T() {
  }
  function q($, W, J) {
    r = r || Kt(), $ = $ || {}, typeof J != "boolean" && (J = W instanceof r), this.objectMode = !!$.objectMode, J && (this.objectMode = this.objectMode || !!$.writableObjectMode), this.highWaterMark = g(this, $, "writableHighWaterMark", J), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var X = $.decodeStrings === !1;
    this.decodeStrings = !X, this.defaultEncoding = $.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(oe) {
      M(W, oe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = $.emitClose !== !1, this.autoDestroy = !!$.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  q.prototype.getBuffer = function() {
    for (var W = this.bufferedRequest, J = []; W; )
      J.push(W), W = W.next;
    return J;
  }, function() {
    try {
      Object.defineProperty(q.prototype, "buffer", {
        get: i.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var D;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (D = Function.prototype[Symbol.hasInstance], Object.defineProperty(H, Symbol.hasInstance, {
    value: function(W) {
      return D.call(this, W) ? !0 : this !== H ? !1 : W && W._writableState instanceof q;
    }
  })) : D = function(W) {
    return W instanceof this;
  };
  function H($) {
    r = r || Kt();
    var W = this instanceof r;
    if (!W && !D.call(H, this)) return new H($);
    this._writableState = new q($, this, W), this.writable = !0, $ && (typeof $.write == "function" && (this._write = $.write), typeof $.writev == "function" && (this._writev = $.writev), typeof $.destroy == "function" && (this._destroy = $.destroy), typeof $.final == "function" && (this._final = $.final)), t.call(this);
  }
  H.prototype.pipe = function() {
    I(this, new b());
  };
  function G($, W) {
    var J = new R();
    I($, J), process.nextTick(W, J);
  }
  function ee($, W, J, X) {
    var oe;
    return J === null ? oe = new a() : typeof J != "string" && !W.objectMode && (oe = new h("chunk", ["string", "Buffer"], J)), oe ? (I($, oe), process.nextTick(X, oe), !1) : !0;
  }
  H.prototype.write = function($, W, J) {
    var X = this._writableState, oe = !1, P = !X.objectMode && o($);
    return P && !p.isBuffer($) && ($ = u($)), typeof W == "function" && (J = W, W = null), P ? W = "buffer" : W || (W = X.defaultEncoding), typeof J != "function" && (J = T), X.ending ? G(this, J) : (P || ee(this, X, $, J)) && (X.pendingcb++, oe = re(this, X, P, $, W, J)), oe;
  }, H.prototype.cork = function() {
    this._writableState.corked++;
  }, H.prototype.uncork = function() {
    var $ = this._writableState;
    $.corked && ($.corked--, !$.writing && !$.corked && !$.bufferProcessing && $.bufferedRequest && B(this, $));
  }, H.prototype.setDefaultEncoding = function(W) {
    if (typeof W == "string" && (W = W.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((W + "").toLowerCase()) > -1)) throw new S(W);
    return this._writableState.defaultEncoding = W, this;
  }, Object.defineProperty(H.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Y($, W, J) {
    return !$.objectMode && $.decodeStrings !== !1 && typeof W == "string" && (W = p.from(W, J)), W;
  }
  Object.defineProperty(H.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function re($, W, J, X, oe, P) {
    if (!J) {
      var O = Y(W, X, oe);
      X !== O && (J = !0, oe = "buffer", X = O);
    }
    var Z = W.objectMode ? 1 : X.length;
    W.length += Z;
    var Q = W.length < W.highWaterMark;
    if (Q || (W.needDrain = !0), W.writing || W.corked) {
      var ae = W.lastBufferedRequest;
      W.lastBufferedRequest = {
        chunk: X,
        encoding: oe,
        isBuf: J,
        callback: P,
        next: null
      }, ae ? ae.next = W.lastBufferedRequest : W.bufferedRequest = W.lastBufferedRequest, W.bufferedRequestCount += 1;
    } else
      F($, W, !1, Z, X, oe, P);
    return Q;
  }
  function F($, W, J, X, oe, P, O) {
    W.writelen = X, W.writecb = O, W.writing = !0, W.sync = !0, W.destroyed ? W.onwrite(new v("write")) : J ? $._writev(oe, W.onwrite) : $._write(oe, P, W.onwrite), W.sync = !1;
  }
  function l($, W, J, X, oe) {
    --W.pendingcb, J ? (process.nextTick(oe, X), process.nextTick(N, $, W), $._writableState.errorEmitted = !0, I($, X)) : (oe(X), $._writableState.errorEmitted = !0, I($, X), N($, W));
  }
  function E($) {
    $.writing = !1, $.writecb = null, $.length -= $.writelen, $.writelen = 0;
  }
  function M($, W) {
    var J = $._writableState, X = J.sync, oe = J.writecb;
    if (typeof oe != "function") throw new f();
    if (E(J), W) l($, J, X, W, oe);
    else {
      var P = j(J) || $.destroyed;
      !P && !J.corked && !J.bufferProcessing && J.bufferedRequest && B($, J), X ? process.nextTick(k, $, J, P, oe) : k($, J, P, oe);
    }
  }
  function k($, W, J, X) {
    J || x($, W), W.pendingcb--, X(), N($, W);
  }
  function x($, W) {
    W.length === 0 && W.needDrain && (W.needDrain = !1, $.emit("drain"));
  }
  function B($, W) {
    W.bufferProcessing = !0;
    var J = W.bufferedRequest;
    if ($._writev && J && J.next) {
      var X = W.bufferedRequestCount, oe = new Array(X), P = W.corkedRequestsFree;
      P.entry = J;
      for (var O = 0, Z = !0; J; )
        oe[O] = J, J.isBuf || (Z = !1), J = J.next, O += 1;
      oe.allBuffers = Z, F($, W, !0, W.length, oe, "", P.finish), W.pendingcb++, W.lastBufferedRequest = null, P.next ? (W.corkedRequestsFree = P.next, P.next = null) : W.corkedRequestsFree = new e(W), W.bufferedRequestCount = 0;
    } else {
      for (; J; ) {
        var Q = J.chunk, ae = J.encoding, le = J.callback, ne = W.objectMode ? 1 : Q.length;
        if (F($, W, !1, ne, Q, ae, le), J = J.next, W.bufferedRequestCount--, W.writing)
          break;
      }
      J === null && (W.lastBufferedRequest = null);
    }
    W.bufferedRequest = J, W.bufferProcessing = !1;
  }
  H.prototype._write = function($, W, J) {
    J(new s("_write()"));
  }, H.prototype._writev = null, H.prototype.end = function($, W, J) {
    var X = this._writableState;
    return typeof $ == "function" ? (J = $, $ = null, W = null) : typeof W == "function" && (J = W, W = null), $ != null && this.write($, W), X.corked && (X.corked = 1, this.uncork()), X.ending || te(this, X, J), this;
  }, Object.defineProperty(H.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function j($) {
    return $.ending && $.length === 0 && $.bufferedRequest === null && !$.finished && !$.writing;
  }
  function A($, W) {
    $._final(function(J) {
      W.pendingcb--, J && I($, J), W.prefinished = !0, $.emit("prefinish"), N($, W);
    });
  }
  function y($, W) {
    !W.prefinished && !W.finalCalled && (typeof $._final == "function" && !W.destroyed ? (W.pendingcb++, W.finalCalled = !0, process.nextTick(A, $, W)) : (W.prefinished = !0, $.emit("prefinish")));
  }
  function N($, W) {
    var J = j(W);
    if (J && (y($, W), W.pendingcb === 0 && (W.finished = !0, $.emit("finish"), W.autoDestroy))) {
      var X = $._readableState;
      (!X || X.autoDestroy && X.endEmitted) && $.destroy();
    }
    return J;
  }
  function te($, W, J) {
    W.ending = !0, N($, W), J && (W.finished ? process.nextTick(J) : $.once("finish", J)), W.ended = !0, $.writable = !1;
  }
  function K($, W, J) {
    var X = $.entry;
    for ($.entry = null; X; ) {
      var oe = X.callback;
      W.pendingcb--, oe(J), X = X.next;
    }
    W.corkedRequestsFree.next = $;
  }
  return Object.defineProperty(H.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(W) {
      this._writableState && (this._writableState.destroyed = W);
    }
  }), H.prototype.destroy = d.destroy, H.prototype._undestroy = d.undestroy, H.prototype._destroy = function($, W) {
    W($);
  }, Jn;
}
var Gn, ya;
function Kt() {
  if (ya) return Gn;
  ya = 1;
  var e = Object.keys || function(m) {
    var g = [];
    for (var c in m) g.push(c);
    return g;
  };
  Gn = u;
  var r = Xc(), i = Yc();
  Qe()(u, r);
  for (var t = e(i.prototype), p = 0; p < t.length; p++) {
    var n = t[p];
    u.prototype[n] || (u.prototype[n] = i.prototype[n]);
  }
  function u(m) {
    if (!(this instanceof u)) return new u(m);
    r.call(this, m), i.call(this, m), this.allowHalfOpen = !0, m && (m.readable === !1 && (this.readable = !1), m.writable === !1 && (this.writable = !1), m.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", o)));
  }
  Object.defineProperty(u.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(u.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(u.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function o() {
    this._writableState.ended || process.nextTick(d, this);
  }
  function d(m) {
    m.end();
  }
  return Object.defineProperty(u.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(g) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = g, this._writableState.destroyed = g);
    }
  }), Gn;
}
var Zn = {}, ba;
function va() {
  if (ba) return Zn;
  ba = 1;
  var e = st().Buffer, r = e.isEncoding || function(a) {
    switch (a = "" + a, a && a.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function i(a) {
    if (!a) return "utf8";
    for (var R; ; )
      switch (a) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return a;
        default:
          if (R) return;
          a = ("" + a).toLowerCase(), R = !0;
      }
  }
  function t(a) {
    var R = i(a);
    if (typeof R != "string" && (e.isEncoding === r || !r(a))) throw new Error("Unknown encoding: " + a);
    return R || a;
  }
  Zn.StringDecoder = p;
  function p(a) {
    this.encoding = t(a);
    var R;
    switch (this.encoding) {
      case "utf16le":
        this.text = c, this.end = h, R = 4;
        break;
      case "utf8":
        this.fillLast = d, R = 4;
        break;
      case "base64":
        this.text = s, this.end = f, R = 3;
        break;
      default:
        this.write = b, this.end = v;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(R);
  }
  p.prototype.write = function(a) {
    if (a.length === 0) return "";
    var R, S;
    if (this.lastNeed) {
      if (R = this.fillLast(a), R === void 0) return "";
      S = this.lastNeed, this.lastNeed = 0;
    } else
      S = 0;
    return S < a.length ? R ? R + this.text(a, S) : this.text(a, S) : R || "";
  }, p.prototype.end = g, p.prototype.text = m, p.prototype.fillLast = function(a) {
    if (this.lastNeed <= a.length)
      return a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    a.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, a.length), this.lastNeed -= a.length;
  };
  function n(a) {
    return a <= 127 ? 0 : a >> 5 === 6 ? 2 : a >> 4 === 14 ? 3 : a >> 3 === 30 ? 4 : a >> 6 === 2 ? -1 : -2;
  }
  function u(a, R, S) {
    var I = R.length - 1;
    if (I < S) return 0;
    var T = n(R[I]);
    return T >= 0 ? (T > 0 && (a.lastNeed = T - 1), T) : --I < S || T === -2 ? 0 : (T = n(R[I]), T >= 0 ? (T > 0 && (a.lastNeed = T - 2), T) : --I < S || T === -2 ? 0 : (T = n(R[I]), T >= 0 ? (T > 0 && (T === 2 ? T = 0 : a.lastNeed = T - 3), T) : 0));
  }
  function o(a, R, S) {
    if ((R[0] & 192) !== 128)
      return a.lastNeed = 0, "�";
    if (a.lastNeed > 1 && R.length > 1) {
      if ((R[1] & 192) !== 128)
        return a.lastNeed = 1, "�";
      if (a.lastNeed > 2 && R.length > 2 && (R[2] & 192) !== 128)
        return a.lastNeed = 2, "�";
    }
  }
  function d(a) {
    var R = this.lastTotal - this.lastNeed, S = o(this, a);
    if (S !== void 0) return S;
    if (this.lastNeed <= a.length)
      return a.copy(this.lastChar, R, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    a.copy(this.lastChar, R, 0, a.length), this.lastNeed -= a.length;
  }
  function m(a, R) {
    var S = u(this, a, R);
    if (!this.lastNeed) return a.toString("utf8", R);
    this.lastTotal = S;
    var I = a.length - (S - this.lastNeed);
    return a.copy(this.lastChar, 0, I), a.toString("utf8", R, I);
  }
  function g(a) {
    var R = a && a.length ? this.write(a) : "";
    return this.lastNeed ? R + "�" : R;
  }
  function c(a, R) {
    if ((a.length - R) % 2 === 0) {
      var S = a.toString("utf16le", R);
      if (S) {
        var I = S.charCodeAt(S.length - 1);
        if (I >= 55296 && I <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1], S.slice(0, -1);
      }
      return S;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = a[a.length - 1], a.toString("utf16le", R, a.length - 1);
  }
  function h(a) {
    var R = a && a.length ? this.write(a) : "";
    if (this.lastNeed) {
      var S = this.lastTotal - this.lastNeed;
      return R + this.lastChar.toString("utf16le", 0, S);
    }
    return R;
  }
  function s(a, R) {
    var S = (a.length - R) % 3;
    return S === 0 ? a.toString("base64", R) : (this.lastNeed = 3 - S, this.lastTotal = 3, S === 1 ? this.lastChar[0] = a[a.length - 1] : (this.lastChar[0] = a[a.length - 2], this.lastChar[1] = a[a.length - 1]), a.toString("base64", R, a.length - S));
  }
  function f(a) {
    var R = a && a.length ? this.write(a) : "";
    return this.lastNeed ? R + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : R;
  }
  function b(a) {
    return a.toString(this.encoding);
  }
  function v(a) {
    return a && a.length ? this.write(a) : "";
  }
  return Zn;
}
var Kn, _a;
function qs() {
  if (_a) return Kn;
  _a = 1;
  var e = Yt().codes.ERR_STREAM_PREMATURE_CLOSE;
  function r(n) {
    var u = !1;
    return function() {
      if (!u) {
        u = !0;
        for (var o = arguments.length, d = new Array(o), m = 0; m < o; m++)
          d[m] = arguments[m];
        n.apply(this, d);
      }
    };
  }
  function i() {
  }
  function t(n) {
    return n.setHeader && typeof n.abort == "function";
  }
  function p(n, u, o) {
    if (typeof u == "function") return p(n, null, u);
    u || (u = {}), o = r(o || i);
    var d = u.readable || u.readable !== !1 && n.readable, m = u.writable || u.writable !== !1 && n.writable, g = function() {
      n.writable || h();
    }, c = n._writableState && n._writableState.finished, h = function() {
      m = !1, c = !0, d || o.call(n);
    }, s = n._readableState && n._readableState.endEmitted, f = function() {
      d = !1, s = !0, m || o.call(n);
    }, b = function(S) {
      o.call(n, S);
    }, v = function() {
      var S;
      if (d && !s)
        return (!n._readableState || !n._readableState.ended) && (S = new e()), o.call(n, S);
      if (m && !c)
        return (!n._writableState || !n._writableState.ended) && (S = new e()), o.call(n, S);
    }, a = function() {
      n.req.on("finish", h);
    };
    return t(n) ? (n.on("complete", h), n.on("abort", v), n.req ? a() : n.on("request", a)) : m && !n._writableState && (n.on("end", g), n.on("close", g)), n.on("end", f), n.on("finish", h), u.error !== !1 && n.on("error", b), n.on("close", v), function() {
      n.removeListener("complete", h), n.removeListener("abort", v), n.removeListener("request", a), n.req && n.req.removeListener("finish", h), n.removeListener("end", g), n.removeListener("close", g), n.removeListener("finish", h), n.removeListener("end", f), n.removeListener("error", b), n.removeListener("close", v);
    };
  }
  return Kn = p, Kn;
}
var Qn, Ea;
function vh() {
  if (Ea) return Qn;
  Ea = 1;
  var e;
  function r(S, I, T) {
    return I = i(I), I in S ? Object.defineProperty(S, I, { value: T, enumerable: !0, configurable: !0, writable: !0 }) : S[I] = T, S;
  }
  function i(S) {
    var I = t(S, "string");
    return typeof I == "symbol" ? I : String(I);
  }
  function t(S, I) {
    if (typeof S != "object" || S === null) return S;
    var T = S[Symbol.toPrimitive];
    if (T !== void 0) {
      var q = T.call(S, I || "default");
      if (typeof q != "object") return q;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (I === "string" ? String : Number)(S);
  }
  var p = qs(), n = Symbol("lastResolve"), u = Symbol("lastReject"), o = Symbol("error"), d = Symbol("ended"), m = Symbol("lastPromise"), g = Symbol("handlePromise"), c = Symbol("stream");
  function h(S, I) {
    return {
      value: S,
      done: I
    };
  }
  function s(S) {
    var I = S[n];
    if (I !== null) {
      var T = S[c].read();
      T !== null && (S[m] = null, S[n] = null, S[u] = null, I(h(T, !1)));
    }
  }
  function f(S) {
    process.nextTick(s, S);
  }
  function b(S, I) {
    return function(T, q) {
      S.then(function() {
        if (I[d]) {
          T(h(void 0, !0));
          return;
        }
        I[g](T, q);
      }, q);
    };
  }
  var v = Object.getPrototypeOf(function() {
  }), a = Object.setPrototypeOf((e = {
    get stream() {
      return this[c];
    },
    next: function() {
      var I = this, T = this[o];
      if (T !== null)
        return Promise.reject(T);
      if (this[d])
        return Promise.resolve(h(void 0, !0));
      if (this[c].destroyed)
        return new Promise(function(G, ee) {
          process.nextTick(function() {
            I[o] ? ee(I[o]) : G(h(void 0, !0));
          });
        });
      var q = this[m], D;
      if (q)
        D = new Promise(b(q, this));
      else {
        var H = this[c].read();
        if (H !== null)
          return Promise.resolve(h(H, !1));
        D = new Promise(this[g]);
      }
      return this[m] = D, D;
    }
  }, r(e, Symbol.asyncIterator, function() {
    return this;
  }), r(e, "return", function() {
    var I = this;
    return new Promise(function(T, q) {
      I[c].destroy(null, function(D) {
        if (D) {
          q(D);
          return;
        }
        T(h(void 0, !0));
      });
    });
  }), e), v), R = function(I) {
    var T, q = Object.create(a, (T = {}, r(T, c, {
      value: I,
      writable: !0
    }), r(T, n, {
      value: null,
      writable: !0
    }), r(T, u, {
      value: null,
      writable: !0
    }), r(T, o, {
      value: null,
      writable: !0
    }), r(T, d, {
      value: I._readableState.endEmitted,
      writable: !0
    }), r(T, g, {
      value: function(H, G) {
        var ee = q[c].read();
        ee ? (q[m] = null, q[n] = null, q[u] = null, H(h(ee, !1))) : (q[n] = H, q[u] = G);
      },
      writable: !0
    }), T));
    return q[m] = null, p(I, function(D) {
      if (D && D.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var H = q[u];
        H !== null && (q[m] = null, q[n] = null, q[u] = null, H(D)), q[o] = D;
        return;
      }
      var G = q[n];
      G !== null && (q[m] = null, q[n] = null, q[u] = null, G(h(void 0, !0))), q[d] = !0;
    }), I.on("readable", f.bind(null, q)), q;
  };
  return Qn = R, Qn;
}
var Yn, Ra;
function _h() {
  return Ra || (Ra = 1, Yn = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Yn;
}
var Xn, Sa;
function Xc() {
  if (Sa) return Xn;
  Sa = 1, Xn = G;
  var e;
  G.ReadableState = H, hn().EventEmitter;
  var r = function(O, Z) {
    return O.listeners(Z).length;
  }, i = Zc(), t = mn().Buffer, p = (typeof Zt < "u" ? Zt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function n(P) {
    return t.from(P);
  }
  function u(P) {
    return t.isBuffer(P) || P instanceof p;
  }
  var o = Ls, d;
  o && o.debuglog ? d = o.debuglog("stream") : d = function() {
  };
  var m = yh(), g = Kc(), c = Qc(), h = c.getHighWaterMark, s = Yt().codes, f = s.ERR_INVALID_ARG_TYPE, b = s.ERR_STREAM_PUSH_AFTER_EOF, v = s.ERR_METHOD_NOT_IMPLEMENTED, a = s.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, R, S, I;
  Qe()(G, i);
  var T = g.errorOrDestroy, q = ["error", "close", "destroy", "pause", "resume"];
  function D(P, O, Z) {
    if (typeof P.prependListener == "function") return P.prependListener(O, Z);
    !P._events || !P._events[O] ? P.on(O, Z) : Array.isArray(P._events[O]) ? P._events[O].unshift(Z) : P._events[O] = [Z, P._events[O]];
  }
  function H(P, O, Z) {
    e = e || Kt(), P = P || {}, typeof Z != "boolean" && (Z = O instanceof e), this.objectMode = !!P.objectMode, Z && (this.objectMode = this.objectMode || !!P.readableObjectMode), this.highWaterMark = h(this, P, "readableHighWaterMark", Z), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = P.emitClose !== !1, this.autoDestroy = !!P.autoDestroy, this.destroyed = !1, this.defaultEncoding = P.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, P.encoding && (R || (R = va().StringDecoder), this.decoder = new R(P.encoding), this.encoding = P.encoding);
  }
  function G(P) {
    if (e = e || Kt(), !(this instanceof G)) return new G(P);
    var O = this instanceof e;
    this._readableState = new H(P, this, O), this.readable = !0, P && (typeof P.read == "function" && (this._read = P.read), typeof P.destroy == "function" && (this._destroy = P.destroy)), i.call(this);
  }
  Object.defineProperty(G.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), G.prototype.destroy = g.destroy, G.prototype._undestroy = g.undestroy, G.prototype._destroy = function(P, O) {
    O(P);
  }, G.prototype.push = function(P, O) {
    var Z = this._readableState, Q;
    return Z.objectMode ? Q = !0 : typeof P == "string" && (O = O || Z.defaultEncoding, O !== Z.encoding && (P = t.from(P, O), O = ""), Q = !0), ee(this, P, O, !1, Q);
  }, G.prototype.unshift = function(P) {
    return ee(this, P, null, !0, !1);
  };
  function ee(P, O, Z, Q, ae) {
    d("readableAddChunk", O);
    var le = P._readableState;
    if (O === null)
      le.reading = !1, M(P, le);
    else {
      var ne;
      if (ae || (ne = re(le, O)), ne)
        T(P, ne);
      else if (le.objectMode || O && O.length > 0)
        if (typeof O != "string" && !le.objectMode && Object.getPrototypeOf(O) !== t.prototype && (O = n(O)), Q)
          le.endEmitted ? T(P, new a()) : Y(P, le, O, !0);
        else if (le.ended)
          T(P, new b());
        else {
          if (le.destroyed)
            return !1;
          le.reading = !1, le.decoder && !Z ? (O = le.decoder.write(O), le.objectMode || O.length !== 0 ? Y(P, le, O, !1) : B(P, le)) : Y(P, le, O, !1);
        }
      else Q || (le.reading = !1, B(P, le));
    }
    return !le.ended && (le.length < le.highWaterMark || le.length === 0);
  }
  function Y(P, O, Z, Q) {
    O.flowing && O.length === 0 && !O.sync ? (O.awaitDrain = 0, P.emit("data", Z)) : (O.length += O.objectMode ? 1 : Z.length, Q ? O.buffer.unshift(Z) : O.buffer.push(Z), O.needReadable && k(P)), B(P, O);
  }
  function re(P, O) {
    var Z;
    return !u(O) && typeof O != "string" && O !== void 0 && !P.objectMode && (Z = new f("chunk", ["string", "Buffer", "Uint8Array"], O)), Z;
  }
  G.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, G.prototype.setEncoding = function(P) {
    R || (R = va().StringDecoder);
    var O = new R(P);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Z = this._readableState.buffer.head, Q = ""; Z !== null; )
      Q += O.write(Z.data), Z = Z.next;
    return this._readableState.buffer.clear(), Q !== "" && this._readableState.buffer.push(Q), this._readableState.length = Q.length, this;
  };
  var F = 1073741824;
  function l(P) {
    return P >= F ? P = F : (P--, P |= P >>> 1, P |= P >>> 2, P |= P >>> 4, P |= P >>> 8, P |= P >>> 16, P++), P;
  }
  function E(P, O) {
    return P <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : P !== P ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (P > O.highWaterMark && (O.highWaterMark = l(P)), P <= O.length ? P : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  G.prototype.read = function(P) {
    d("read", P), P = parseInt(P, 10);
    var O = this._readableState, Z = P;
    if (P !== 0 && (O.emittedReadable = !1), P === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return d("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? J(this) : k(this), null;
    if (P = E(P, O), P === 0 && O.ended)
      return O.length === 0 && J(this), null;
    var Q = O.needReadable;
    d("need readable", Q), (O.length === 0 || O.length - P < O.highWaterMark) && (Q = !0, d("length less than watermark", Q)), O.ended || O.reading ? (Q = !1, d("reading or ended", Q)) : Q && (d("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (P = E(Z, O)));
    var ae;
    return P > 0 ? ae = W(P, O) : ae = null, ae === null ? (O.needReadable = O.length <= O.highWaterMark, P = 0) : (O.length -= P, O.awaitDrain = 0), O.length === 0 && (O.ended || (O.needReadable = !0), Z !== P && O.ended && J(this)), ae !== null && this.emit("data", ae), ae;
  };
  function M(P, O) {
    if (d("onEofChunk"), !O.ended) {
      if (O.decoder) {
        var Z = O.decoder.end();
        Z && Z.length && (O.buffer.push(Z), O.length += O.objectMode ? 1 : Z.length);
      }
      O.ended = !0, O.sync ? k(P) : (O.needReadable = !1, O.emittedReadable || (O.emittedReadable = !0, x(P)));
    }
  }
  function k(P) {
    var O = P._readableState;
    d("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (d("emitReadable", O.flowing), O.emittedReadable = !0, process.nextTick(x, P));
  }
  function x(P) {
    var O = P._readableState;
    d("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && (O.length || O.ended) && (P.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, $(P);
  }
  function B(P, O) {
    O.readingMore || (O.readingMore = !0, process.nextTick(j, P, O));
  }
  function j(P, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      var Z = O.length;
      if (d("maybeReadMore read 0"), P.read(0), Z === O.length)
        break;
    }
    O.readingMore = !1;
  }
  G.prototype._read = function(P) {
    T(this, new v("_read()"));
  }, G.prototype.pipe = function(P, O) {
    var Z = this, Q = this._readableState;
    switch (Q.pipesCount) {
      case 0:
        Q.pipes = P;
        break;
      case 1:
        Q.pipes = [Q.pipes, P];
        break;
      default:
        Q.pipes.push(P);
        break;
    }
    Q.pipesCount += 1, d("pipe count=%d opts=%j", Q.pipesCount, O);
    var ae = (!O || O.end !== !1) && P !== process.stdout && P !== process.stderr, le = ae ? fe : ye;
    Q.endEmitted ? process.nextTick(le) : Z.once("end", le), P.on("unpipe", ne);
    function ne(C, w) {
      d("onunpipe"), C === Z && w && w.hasUnpiped === !1 && (w.hasUnpiped = !0, he());
    }
    function fe() {
      d("onend"), P.end();
    }
    var He = A(Z);
    P.on("drain", He);
    var me = !1;
    function he() {
      d("cleanup"), P.removeListener("close", we), P.removeListener("finish", je), P.removeListener("drain", He), P.removeListener("error", pe), P.removeListener("unpipe", ne), Z.removeListener("end", fe), Z.removeListener("end", ye), Z.removeListener("data", ve), me = !0, Q.awaitDrain && (!P._writableState || P._writableState.needDrain) && He();
    }
    Z.on("data", ve);
    function ve(C) {
      d("ondata");
      var w = P.write(C);
      d("dest.write", w), w === !1 && ((Q.pipesCount === 1 && Q.pipes === P || Q.pipesCount > 1 && oe(Q.pipes, P) !== -1) && !me && (d("false write response, pause", Q.awaitDrain), Q.awaitDrain++), Z.pause());
    }
    function pe(C) {
      d("onerror", C), ye(), P.removeListener("error", pe), r(P, "error") === 0 && T(P, C);
    }
    D(P, "error", pe);
    function we() {
      P.removeListener("finish", je), ye();
    }
    P.once("close", we);
    function je() {
      d("onfinish"), P.removeListener("close", we), ye();
    }
    P.once("finish", je);
    function ye() {
      d("unpipe"), Z.unpipe(P);
    }
    return P.emit("pipe", Z), Q.flowing || (d("pipe resume"), Z.resume()), P;
  };
  function A(P) {
    return function() {
      var Z = P._readableState;
      d("pipeOnDrain", Z.awaitDrain), Z.awaitDrain && Z.awaitDrain--, Z.awaitDrain === 0 && r(P, "data") && (Z.flowing = !0, $(P));
    };
  }
  G.prototype.unpipe = function(P) {
    var O = this._readableState, Z = {
      hasUnpiped: !1
    };
    if (O.pipesCount === 0) return this;
    if (O.pipesCount === 1)
      return P && P !== O.pipes ? this : (P || (P = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, P && P.emit("unpipe", this, Z), this);
    if (!P) {
      var Q = O.pipes, ae = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var le = 0; le < ae; le++) Q[le].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ne = oe(O.pipes, P);
    return ne === -1 ? this : (O.pipes.splice(ne, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), P.emit("unpipe", this, Z), this);
  }, G.prototype.on = function(P, O) {
    var Z = i.prototype.on.call(this, P, O), Q = this._readableState;
    return P === "data" ? (Q.readableListening = this.listenerCount("readable") > 0, Q.flowing !== !1 && this.resume()) : P === "readable" && !Q.endEmitted && !Q.readableListening && (Q.readableListening = Q.needReadable = !0, Q.flowing = !1, Q.emittedReadable = !1, d("on readable", Q.length, Q.reading), Q.length ? k(this) : Q.reading || process.nextTick(N, this)), Z;
  }, G.prototype.addListener = G.prototype.on, G.prototype.removeListener = function(P, O) {
    var Z = i.prototype.removeListener.call(this, P, O);
    return P === "readable" && process.nextTick(y, this), Z;
  }, G.prototype.removeAllListeners = function(P) {
    var O = i.prototype.removeAllListeners.apply(this, arguments);
    return (P === "readable" || P === void 0) && process.nextTick(y, this), O;
  };
  function y(P) {
    var O = P._readableState;
    O.readableListening = P.listenerCount("readable") > 0, O.resumeScheduled && !O.paused ? O.flowing = !0 : P.listenerCount("data") > 0 && P.resume();
  }
  function N(P) {
    d("readable nexttick read 0"), P.read(0);
  }
  G.prototype.resume = function() {
    var P = this._readableState;
    return P.flowing || (d("resume"), P.flowing = !P.readableListening, te(this, P)), P.paused = !1, this;
  };
  function te(P, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, process.nextTick(K, P, O));
  }
  function K(P, O) {
    d("resume", O.reading), O.reading || P.read(0), O.resumeScheduled = !1, P.emit("resume"), $(P), O.flowing && !O.reading && P.read(0);
  }
  G.prototype.pause = function() {
    return d("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (d("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function $(P) {
    var O = P._readableState;
    for (d("flow", O.flowing); O.flowing && P.read() !== null; ) ;
  }
  G.prototype.wrap = function(P) {
    var O = this, Z = this._readableState, Q = !1;
    P.on("end", function() {
      if (d("wrapped end"), Z.decoder && !Z.ended) {
        var ne = Z.decoder.end();
        ne && ne.length && O.push(ne);
      }
      O.push(null);
    }), P.on("data", function(ne) {
      if (d("wrapped data"), Z.decoder && (ne = Z.decoder.write(ne)), !(Z.objectMode && ne == null) && !(!Z.objectMode && (!ne || !ne.length))) {
        var fe = O.push(ne);
        fe || (Q = !0, P.pause());
      }
    });
    for (var ae in P)
      this[ae] === void 0 && typeof P[ae] == "function" && (this[ae] = /* @__PURE__ */ function(fe) {
        return function() {
          return P[fe].apply(P, arguments);
        };
      }(ae));
    for (var le = 0; le < q.length; le++)
      P.on(q[le], this.emit.bind(this, q[le]));
    return this._read = function(ne) {
      d("wrapped _read", ne), Q && (Q = !1, P.resume());
    }, this;
  }, typeof Symbol == "function" && (G.prototype[Symbol.asyncIterator] = function() {
    return S === void 0 && (S = vh()), S(this);
  }), Object.defineProperty(G.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(G.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(G.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(O) {
      this._readableState && (this._readableState.flowing = O);
    }
  }), G._fromList = W, Object.defineProperty(G.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function W(P, O) {
    if (O.length === 0) return null;
    var Z;
    return O.objectMode ? Z = O.buffer.shift() : !P || P >= O.length ? (O.decoder ? Z = O.buffer.join("") : O.buffer.length === 1 ? Z = O.buffer.first() : Z = O.buffer.concat(O.length), O.buffer.clear()) : Z = O.buffer.consume(P, O.decoder), Z;
  }
  function J(P) {
    var O = P._readableState;
    d("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, process.nextTick(X, O, P));
  }
  function X(P, O) {
    if (d("endReadableNT", P.endEmitted, P.length), !P.endEmitted && P.length === 0 && (P.endEmitted = !0, O.readable = !1, O.emit("end"), P.autoDestroy)) {
      var Z = O._writableState;
      (!Z || Z.autoDestroy && Z.finished) && O.destroy();
    }
  }
  typeof Symbol == "function" && (G.from = function(P, O) {
    return I === void 0 && (I = _h()), I(G, P, O);
  });
  function oe(P, O) {
    for (var Z = 0, Q = P.length; Z < Q; Z++)
      if (P[Z] === O) return Z;
    return -1;
  }
  return Xn;
}
var ei, Ma;
function el() {
  if (Ma) return ei;
  Ma = 1, ei = o;
  var e = Yt().codes, r = e.ERR_METHOD_NOT_IMPLEMENTED, i = e.ERR_MULTIPLE_CALLBACK, t = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, p = e.ERR_TRANSFORM_WITH_LENGTH_0, n = Kt();
  Qe()(o, n);
  function u(g, c) {
    var h = this._transformState;
    h.transforming = !1;
    var s = h.writecb;
    if (s === null)
      return this.emit("error", new i());
    h.writechunk = null, h.writecb = null, c != null && this.push(c), s(g);
    var f = this._readableState;
    f.reading = !1, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
  }
  function o(g) {
    if (!(this instanceof o)) return new o(g);
    n.call(this, g), this._transformState = {
      afterTransform: u.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, g && (typeof g.transform == "function" && (this._transform = g.transform), typeof g.flush == "function" && (this._flush = g.flush)), this.on("prefinish", d);
  }
  function d() {
    var g = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(c, h) {
      m(g, c, h);
    }) : m(this, null, null);
  }
  o.prototype.push = function(g, c) {
    return this._transformState.needTransform = !1, n.prototype.push.call(this, g, c);
  }, o.prototype._transform = function(g, c, h) {
    h(new r("_transform()"));
  }, o.prototype._write = function(g, c, h) {
    var s = this._transformState;
    if (s.writecb = h, s.writechunk = g, s.writeencoding = c, !s.transforming) {
      var f = this._readableState;
      (s.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
  }, o.prototype._read = function(g) {
    var c = this._transformState;
    c.writechunk !== null && !c.transforming ? (c.transforming = !0, this._transform(c.writechunk, c.writeencoding, c.afterTransform)) : c.needTransform = !0;
  }, o.prototype._destroy = function(g, c) {
    n.prototype._destroy.call(this, g, function(h) {
      c(h);
    });
  };
  function m(g, c, h) {
    if (c) return g.emit("error", c);
    if (h != null && g.push(h), g._writableState.length) throw new p();
    if (g._transformState.transforming) throw new t();
    return g.push(null);
  }
  return ei;
}
var ti, ka;
function Eh() {
  if (ka) return ti;
  ka = 1, ti = r;
  var e = el();
  Qe()(r, e);
  function r(i) {
    if (!(this instanceof r)) return new r(i);
    e.call(this, i);
  }
  return r.prototype._transform = function(i, t, p) {
    p(null, i);
  }, ti;
}
var ri, Ca;
function Rh() {
  if (Ca) return ri;
  Ca = 1;
  var e;
  function r(h) {
    var s = !1;
    return function() {
      s || (s = !0, h.apply(void 0, arguments));
    };
  }
  var i = Yt().codes, t = i.ERR_MISSING_ARGS, p = i.ERR_STREAM_DESTROYED;
  function n(h) {
    if (h) throw h;
  }
  function u(h) {
    return h.setHeader && typeof h.abort == "function";
  }
  function o(h, s, f, b) {
    b = r(b);
    var v = !1;
    h.on("close", function() {
      v = !0;
    }), e === void 0 && (e = qs()), e(h, {
      readable: s,
      writable: f
    }, function(R) {
      if (R) return b(R);
      v = !0, b();
    });
    var a = !1;
    return function(R) {
      if (!v && !a) {
        if (a = !0, u(h)) return h.abort();
        if (typeof h.destroy == "function") return h.destroy();
        b(R || new p("pipe"));
      }
    };
  }
  function d(h) {
    h();
  }
  function m(h, s) {
    return h.pipe(s);
  }
  function g(h) {
    return !h.length || typeof h[h.length - 1] != "function" ? n : h.pop();
  }
  function c() {
    for (var h = arguments.length, s = new Array(h), f = 0; f < h; f++)
      s[f] = arguments[f];
    var b = g(s);
    if (Array.isArray(s[0]) && (s = s[0]), s.length < 2)
      throw new t("streams");
    var v, a = s.map(function(R, S) {
      var I = S < s.length - 1, T = S > 0;
      return o(R, I, T, function(q) {
        v || (v = q), q && a.forEach(d), !I && (a.forEach(d), b(v));
      });
    });
    return s.reduce(m);
  }
  return ri = c, ri;
}
var Ia;
function tl() {
  return Ia || (Ia = 1, function(e, r) {
    r = e.exports = Xc(), r.Stream = r, r.Readable = r, r.Writable = Yc(), r.Duplex = Kt(), r.Transform = el(), r.PassThrough = Eh(), r.finished = qs(), r.pipeline = Rh();
  }(nn, nn.exports)), nn.exports;
}
var ni, xa;
function Sh() {
  if (xa) return ni;
  xa = 1;
  const { Transform: e } = tl();
  return ni = (r) => class rl extends e {
    constructor(t, p, n, u, o) {
      super(o), this._rate = t, this._capacity = p, this._delimitedSuffix = n, this._hashBitLength = u, this._options = o, this._state = new r(), this._state.initialize(t, p), this._finalized = !1;
    }
    _transform(t, p, n) {
      let u = null;
      try {
        this.update(t, p);
      } catch (o) {
        u = o;
      }
      n(u);
    }
    _flush(t) {
      let p = null;
      try {
        this.push(this.digest());
      } catch (n) {
        p = n;
      }
      t(p);
    }
    update(t, p) {
      if (!Buffer.isBuffer(t) && typeof t != "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Digest already called");
      return Buffer.isBuffer(t) || (t = Buffer.from(t, p)), this._state.absorb(t), this;
    }
    digest(t) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
      let p = this._state.squeeze(this._hashBitLength / 8);
      return t !== void 0 && (p = p.toString(t)), this._resetState(), p;
    }
    // remove result from memory
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    // because sometimes we need hash right now and little later
    _clone() {
      const t = new rl(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
      return this._state.copy(t._state), t._finalized = this._finalized, t;
    }
  }, ni;
}
var ii, Aa;
function Mh() {
  if (Aa) return ii;
  Aa = 1;
  const { Transform: e } = tl();
  return ii = (r) => class nl extends e {
    constructor(t, p, n, u) {
      super(u), this._rate = t, this._capacity = p, this._delimitedSuffix = n, this._options = u, this._state = new r(), this._state.initialize(t, p), this._finalized = !1;
    }
    _transform(t, p, n) {
      let u = null;
      try {
        this.update(t, p);
      } catch (o) {
        u = o;
      }
      n(u);
    }
    _flush() {
    }
    _read(t) {
      this.push(this.squeeze(t));
    }
    update(t, p) {
      if (!Buffer.isBuffer(t) && typeof t != "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Squeeze already called");
      return Buffer.isBuffer(t) || (t = Buffer.from(t, p)), this._state.absorb(t), this;
    }
    squeeze(t, p) {
      this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
      let n = this._state.squeeze(t);
      return p !== void 0 && (n = n.toString(p)), n;
    }
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    _clone() {
      const t = new nl(this._rate, this._capacity, this._delimitedSuffix, this._options);
      return this._state.copy(t._state), t._finalized = this._finalized, t;
    }
  }, ii;
}
var si, Ta;
function kh() {
  if (Ta) return si;
  Ta = 1;
  const e = Sh(), r = Mh();
  return si = function(i) {
    const t = e(i), p = r(i);
    return function(n, u) {
      switch (typeof n == "string" ? n.toLowerCase() : n) {
        case "keccak224":
          return new t(1152, 448, null, 224, u);
        case "keccak256":
          return new t(1088, 512, null, 256, u);
        case "keccak384":
          return new t(832, 768, null, 384, u);
        case "keccak512":
          return new t(576, 1024, null, 512, u);
        case "sha3-224":
          return new t(1152, 448, 6, 224, u);
        case "sha3-256":
          return new t(1088, 512, 6, 256, u);
        case "sha3-384":
          return new t(832, 768, 6, 384, u);
        case "sha3-512":
          return new t(576, 1024, 6, 512, u);
        case "shake128":
          return new p(1344, 256, 31, u);
        case "shake256":
          return new p(1088, 512, 31, u);
        default:
          throw new Error("Invald algorithm: " + n);
      }
    };
  }, si;
}
var oi = {}, La;
function Ch() {
  if (La) return oi;
  La = 1;
  const e = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  return oi.p1600 = function(r) {
    for (let i = 0; i < 24; ++i) {
      const t = r[0] ^ r[10] ^ r[20] ^ r[30] ^ r[40], p = r[1] ^ r[11] ^ r[21] ^ r[31] ^ r[41], n = r[2] ^ r[12] ^ r[22] ^ r[32] ^ r[42], u = r[3] ^ r[13] ^ r[23] ^ r[33] ^ r[43], o = r[4] ^ r[14] ^ r[24] ^ r[34] ^ r[44], d = r[5] ^ r[15] ^ r[25] ^ r[35] ^ r[45], m = r[6] ^ r[16] ^ r[26] ^ r[36] ^ r[46], g = r[7] ^ r[17] ^ r[27] ^ r[37] ^ r[47], c = r[8] ^ r[18] ^ r[28] ^ r[38] ^ r[48], h = r[9] ^ r[19] ^ r[29] ^ r[39] ^ r[49];
      let s = c ^ (n << 1 | u >>> 31), f = h ^ (u << 1 | n >>> 31);
      const b = r[0] ^ s, v = r[1] ^ f, a = r[10] ^ s, R = r[11] ^ f, S = r[20] ^ s, I = r[21] ^ f, T = r[30] ^ s, q = r[31] ^ f, D = r[40] ^ s, H = r[41] ^ f;
      s = t ^ (o << 1 | d >>> 31), f = p ^ (d << 1 | o >>> 31);
      const G = r[2] ^ s, ee = r[3] ^ f, Y = r[12] ^ s, re = r[13] ^ f, F = r[22] ^ s, l = r[23] ^ f, E = r[32] ^ s, M = r[33] ^ f, k = r[42] ^ s, x = r[43] ^ f;
      s = n ^ (m << 1 | g >>> 31), f = u ^ (g << 1 | m >>> 31);
      const B = r[4] ^ s, j = r[5] ^ f, A = r[14] ^ s, y = r[15] ^ f, N = r[24] ^ s, te = r[25] ^ f, K = r[34] ^ s, $ = r[35] ^ f, W = r[44] ^ s, J = r[45] ^ f;
      s = o ^ (c << 1 | h >>> 31), f = d ^ (h << 1 | c >>> 31);
      const X = r[6] ^ s, oe = r[7] ^ f, P = r[16] ^ s, O = r[17] ^ f, Z = r[26] ^ s, Q = r[27] ^ f, ae = r[36] ^ s, le = r[37] ^ f, ne = r[46] ^ s, fe = r[47] ^ f;
      s = m ^ (t << 1 | p >>> 31), f = g ^ (p << 1 | t >>> 31);
      const He = r[8] ^ s, me = r[9] ^ f, he = r[18] ^ s, ve = r[19] ^ f, pe = r[28] ^ s, we = r[29] ^ f, je = r[38] ^ s, ye = r[39] ^ f, C = r[48] ^ s, w = r[49] ^ f, _ = b, L = v, U = R << 4 | a >>> 28, V = a << 4 | R >>> 28, z = S << 3 | I >>> 29, de = I << 3 | S >>> 29, ce = q << 9 | T >>> 23, ue = T << 9 | q >>> 23, be = D << 18 | H >>> 14, se = H << 18 | D >>> 14, _e = G << 1 | ee >>> 31, At = ee << 1 | G >>> 31, Ee = re << 12 | Y >>> 20, Re = Y << 12 | re >>> 20, Tt = F << 10 | l >>> 22, Se = l << 10 | F >>> 22, Me = M << 13 | E >>> 19, Lt = E << 13 | M >>> 19, ke = k << 2 | x >>> 30, Ce = x << 2 | k >>> 30, Bt = j << 30 | B >>> 2, Ie = B << 30 | j >>> 2, xe = A << 6 | y >>> 26, Nt = y << 6 | A >>> 26, Ae = te << 11 | N >>> 21, Te = N << 11 | te >>> 21, Pt = K << 15 | $ >>> 17, Le = $ << 15 | K >>> 17, Be = J << 29 | W >>> 3, Ot = W << 29 | J >>> 3, Ne = X << 28 | oe >>> 4, Pe = oe << 28 | X >>> 4, Ft = O << 23 | P >>> 9, Oe = P << 23 | O >>> 9, Fe = Z << 25 | Q >>> 7, at = Q << 25 | Z >>> 7, ut = ae << 21 | le >>> 11, ct = le << 21 | ae >>> 11, lt = fe << 24 | ne >>> 8, ht = ne << 24 | fe >>> 8, dt = He << 27 | me >>> 5, ft = me << 27 | He >>> 5, pt = he << 20 | ve >>> 12, gt = ve << 20 | he >>> 12, mt = we << 7 | pe >>> 25, wt = pe << 7 | we >>> 25, yt = je << 8 | ye >>> 24, bt = ye << 8 | je >>> 24, vt = C << 14 | w >>> 18, _t = w << 14 | C >>> 18;
      r[0] = _ ^ ~Ee & Ae, r[1] = L ^ ~Re & Te, r[10] = Ne ^ ~pt & z, r[11] = Pe ^ ~gt & de, r[20] = _e ^ ~xe & Fe, r[21] = At ^ ~Nt & at, r[30] = dt ^ ~U & Tt, r[31] = ft ^ ~V & Se, r[40] = Bt ^ ~Ft & mt, r[41] = Ie ^ ~Oe & wt, r[2] = Ee ^ ~Ae & ut, r[3] = Re ^ ~Te & ct, r[12] = pt ^ ~z & Me, r[13] = gt ^ ~de & Lt, r[22] = xe ^ ~Fe & yt, r[23] = Nt ^ ~at & bt, r[32] = U ^ ~Tt & Pt, r[33] = V ^ ~Se & Le, r[42] = Ft ^ ~mt & ce, r[43] = Oe ^ ~wt & ue, r[4] = Ae ^ ~ut & vt, r[5] = Te ^ ~ct & _t, r[14] = z ^ ~Me & Be, r[15] = de ^ ~Lt & Ot, r[24] = Fe ^ ~yt & be, r[25] = at ^ ~bt & se, r[34] = Tt ^ ~Pt & lt, r[35] = Se ^ ~Le & ht, r[44] = mt ^ ~ce & ke, r[45] = wt ^ ~ue & Ce, r[6] = ut ^ ~vt & _, r[7] = ct ^ ~_t & L, r[16] = Me ^ ~Be & Ne, r[17] = Lt ^ ~Ot & Pe, r[26] = yt ^ ~be & _e, r[27] = bt ^ ~se & At, r[36] = Pt ^ ~lt & dt, r[37] = Le ^ ~ht & ft, r[46] = ce ^ ~ke & Bt, r[47] = ue ^ ~Ce & Ie, r[8] = vt ^ ~_ & Ee, r[9] = _t ^ ~L & Re, r[18] = Be ^ ~Ne & pt, r[19] = Ot ^ ~Pe & gt, r[28] = be ^ ~_e & xe, r[29] = se ^ ~At & Nt, r[38] = lt ^ ~dt & U, r[39] = ht ^ ~ft & V, r[48] = ke ^ ~Bt & Ft, r[49] = Ce ^ ~Ie & Oe, r[0] ^= e[i * 2], r[1] ^= e[i * 2 + 1];
    }
  }, oi;
}
var ai, Ba;
function Ih() {
  if (Ba) return ai;
  Ba = 1;
  const e = Ch();
  function r() {
    this.state = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.blockSize = null, this.count = 0, this.squeezing = !1;
  }
  return r.prototype.initialize = function(i, t) {
    for (let p = 0; p < 50; ++p) this.state[p] = 0;
    this.blockSize = i / 8, this.count = 0, this.squeezing = !1;
  }, r.prototype.absorb = function(i) {
    for (let t = 0; t < i.length; ++t)
      this.state[~~(this.count / 4)] ^= i[t] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (e.p1600(this.state), this.count = 0);
  }, r.prototype.absorbLastFewBits = function(i) {
    this.state[~~(this.count / 4)] ^= i << 8 * (this.count % 4), i & 128 && this.count === this.blockSize - 1 && e.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), e.p1600(this.state), this.count = 0, this.squeezing = !0;
  }, r.prototype.squeeze = function(i) {
    this.squeezing || this.absorbLastFewBits(1);
    const t = Buffer.alloc(i);
    for (let p = 0; p < i; ++p)
      t[p] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (e.p1600(this.state), this.count = 0);
    return t;
  }, r.prototype.copy = function(i) {
    for (let t = 0; t < 50; ++t) i.state[t] = this.state[t];
    i.blockSize = this.blockSize, i.count = this.count, i.squeezing = this.squeezing;
  }, ai = r, ai;
}
var ui, Na;
function xh() {
  return Na || (Na = 1, ui = kh()(Ih())), ui;
}
var ci, Pa;
function il() {
  if (Pa) return ci;
  Pa = 1;
  const e = xh(), r = dn();
  function i(c) {
    return Buffer.allocUnsafe(c).fill(0);
  }
  function t(c, h, s) {
    const f = i(h);
    return c = n(c), s ? c.length < h ? (c.copy(f), f) : c.slice(0, h) : c.length < h ? (c.copy(f, h - c.length), f) : c.slice(-h);
  }
  function p(c, h) {
    return t(c, h, !0);
  }
  function n(c) {
    if (!Buffer.isBuffer(c))
      if (Array.isArray(c))
        c = Buffer.from(c);
      else if (typeof c == "string")
        m(c) ? c = Buffer.from(d(g(c)), "hex") : c = Buffer.from(c);
      else if (typeof c == "number")
        c = intToBuffer(c);
      else if (c == null)
        c = Buffer.allocUnsafe(0);
      else if (r.isBN(c))
        c = c.toArrayLike(Buffer);
      else if (c.toArray)
        c = Buffer.from(c.toArray());
      else
        throw new Error("invalid type");
    return c;
  }
  function u(c) {
    return c = n(c), "0x" + c.toString("hex");
  }
  function o(c, h) {
    return c = n(c), h || (h = 256), e("keccak" + h).update(c).digest();
  }
  function d(c) {
    return c.length % 2 ? "0" + c : c;
  }
  function m(c) {
    return typeof c == "string" && c.match(/^0x[0-9A-Fa-f]*$/);
  }
  function g(c) {
    return typeof c == "string" && c.startsWith("0x") ? c.slice(2) : c;
  }
  return ci = {
    zeros: i,
    setLength: t,
    setLengthRight: p,
    isHexString: m,
    stripHexPrefix: g,
    toBuffer: n,
    bufferToHex: u,
    keccak: o
  }, ci;
}
var li, Oa;
function Ah() {
  if (Oa) return li;
  Oa = 1;
  const e = /* @__PURE__ */ il(), r = dn();
  function i(s) {
    return s.startsWith("int[") ? "int256" + s.slice(3) : s === "int" ? "int256" : s.startsWith("uint[") ? "uint256" + s.slice(4) : s === "uint" ? "uint256" : s.startsWith("fixed[") ? "fixed128x128" + s.slice(5) : s === "fixed" ? "fixed128x128" : s.startsWith("ufixed[") ? "ufixed128x128" + s.slice(6) : s === "ufixed" ? "ufixed128x128" : s;
  }
  function t(s) {
    return parseInt(/^\D+(\d+)$/.exec(s)[1], 10);
  }
  function p(s) {
    var f = /^\D+(\d+)x(\d+)$/.exec(s);
    return [parseInt(f[1], 10), parseInt(f[2], 10)];
  }
  function n(s) {
    var f = s.match(/(.*)\[(.*?)\]$/);
    return f ? f[2] === "" ? "dynamic" : parseInt(f[2], 10) : null;
  }
  function u(s) {
    var f = typeof s;
    if (f === "string")
      return e.isHexString(s) ? new r(e.stripHexPrefix(s), 16) : new r(s, 10);
    if (f === "number")
      return new r(s);
    if (s.toArray)
      return s;
    throw new Error("Argument is not a number");
  }
  function o(s, f) {
    var b, v, a, R;
    if (s === "address")
      return o("uint160", u(f));
    if (s === "bool")
      return o("uint8", f ? 1 : 0);
    if (s === "string")
      return o("bytes", new Buffer(f, "utf8"));
    if (m(s)) {
      if (typeof f.length > "u")
        throw new Error("Not an array?");
      if (b = n(s), b !== "dynamic" && b !== 0 && f.length > b)
        throw new Error("Elements exceed array size: " + b);
      a = [], s = s.slice(0, s.lastIndexOf("[")), typeof f == "string" && (f = JSON.parse(f));
      for (R in f)
        a.push(o(s, f[R]));
      if (b === "dynamic") {
        var S = o("uint256", f.length);
        a.unshift(S);
      }
      return Buffer.concat(a);
    } else {
      if (s === "bytes")
        return f = new Buffer(f), a = Buffer.concat([o("uint256", f.length), f]), f.length % 32 !== 0 && (a = Buffer.concat([a, e.zeros(32 - f.length % 32)])), a;
      if (s.startsWith("bytes")) {
        if (b = t(s), b < 1 || b > 32)
          throw new Error("Invalid bytes<N> width: " + b);
        return e.setLengthRight(f, 32);
      } else if (s.startsWith("uint")) {
        if (b = t(s), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid uint<N> width: " + b);
        if (v = u(f), v.bitLength() > b)
          throw new Error("Supplied uint exceeds width: " + b + " vs " + v.bitLength());
        if (v < 0)
          throw new Error("Supplied uint is negative");
        return v.toArrayLike(Buffer, "be", 32);
      } else if (s.startsWith("int")) {
        if (b = t(s), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid int<N> width: " + b);
        if (v = u(f), v.bitLength() > b)
          throw new Error("Supplied int exceeds width: " + b + " vs " + v.bitLength());
        return v.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (s.startsWith("ufixed")) {
        if (b = p(s), v = u(f), v < 0)
          throw new Error("Supplied ufixed is negative");
        return o("uint256", v.mul(new r(2).pow(new r(b[1]))));
      } else if (s.startsWith("fixed"))
        return b = p(s), o("int256", u(f).mul(new r(2).pow(new r(b[1]))));
    }
    throw new Error("Unsupported or invalid type: " + s);
  }
  function d(s) {
    return s === "string" || s === "bytes" || n(s) === "dynamic";
  }
  function m(s) {
    return s.lastIndexOf("]") === s.length - 1;
  }
  function g(s, f) {
    var b = [], v = [], a = 32 * s.length;
    for (var R in s) {
      var S = i(s[R]), I = f[R], T = o(S, I);
      d(S) ? (b.push(o("uint256", a)), v.push(T), a += T.length) : b.push(T);
    }
    return Buffer.concat(b.concat(v));
  }
  function c(s, f) {
    if (s.length !== f.length)
      throw new Error("Number of types are not matching the values");
    for (var b, v, a = [], R = 0; R < s.length; R++) {
      var S = i(s[R]), I = f[R];
      if (S === "bytes")
        a.push(I);
      else if (S === "string")
        a.push(new Buffer(I, "utf8"));
      else if (S === "bool")
        a.push(new Buffer(I ? "01" : "00", "hex"));
      else if (S === "address")
        a.push(e.setLength(I, 20));
      else if (S.startsWith("bytes")) {
        if (b = t(S), b < 1 || b > 32)
          throw new Error("Invalid bytes<N> width: " + b);
        a.push(e.setLengthRight(I, b));
      } else if (S.startsWith("uint")) {
        if (b = t(S), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid uint<N> width: " + b);
        if (v = u(I), v.bitLength() > b)
          throw new Error("Supplied uint exceeds width: " + b + " vs " + v.bitLength());
        a.push(v.toArrayLike(Buffer, "be", b / 8));
      } else if (S.startsWith("int")) {
        if (b = t(S), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid int<N> width: " + b);
        if (v = u(I), v.bitLength() > b)
          throw new Error("Supplied int exceeds width: " + b + " vs " + v.bitLength());
        a.push(v.toTwos(b).toArrayLike(Buffer, "be", b / 8));
      } else
        throw new Error("Unsupported or invalid type: " + S);
    }
    return Buffer.concat(a);
  }
  function h(s, f) {
    return e.keccak(c(s, f));
  }
  return li = {
    rawEncode: g,
    solidityPack: c,
    soliditySHA3: h
  }, li;
}
var hi, Fa;
function Th() {
  if (Fa) return hi;
  Fa = 1;
  const e = /* @__PURE__ */ il(), r = /* @__PURE__ */ Ah(), i = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  }, t = {
    /**
     * Encodes an object by encoding and concatenating each of its members
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to encode
     * @param {Object} types - Type definitions
     * @returns {string} - Encoded representation of an object
     */
    encodeData(n, u, o, d = !0) {
      const m = ["bytes32"], g = [this.hashType(n, o)];
      if (d) {
        const c = (h, s, f) => {
          if (o[s] !== void 0)
            return ["bytes32", f == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : e.keccak(this.encodeData(s, f, o, d))];
          if (f === void 0)
            throw new Error(`missing value for field ${h} of type ${s}`);
          if (s === "bytes")
            return ["bytes32", e.keccak(f)];
          if (s === "string")
            return typeof f == "string" && (f = Buffer.from(f, "utf8")), ["bytes32", e.keccak(f)];
          if (s.lastIndexOf("]") === s.length - 1) {
            const b = s.slice(0, s.lastIndexOf("[")), v = f.map((a) => c(h, b, a));
            return ["bytes32", e.keccak(r.rawEncode(
              v.map(([a]) => a),
              v.map(([, a]) => a)
            ))];
          }
          return [s, f];
        };
        for (const h of o[n]) {
          const [s, f] = c(h.name, h.type, u[h.name]);
          m.push(s), g.push(f);
        }
      } else
        for (const c of o[n]) {
          let h = u[c.name];
          if (h !== void 0)
            if (c.type === "bytes")
              m.push("bytes32"), h = e.keccak(h), g.push(h);
            else if (c.type === "string")
              m.push("bytes32"), typeof h == "string" && (h = Buffer.from(h, "utf8")), h = e.keccak(h), g.push(h);
            else if (o[c.type] !== void 0)
              m.push("bytes32"), h = e.keccak(this.encodeData(c.type, h, o, d)), g.push(h);
            else {
              if (c.type.lastIndexOf("]") === c.type.length - 1)
                throw new Error("Arrays currently unimplemented in encodeData");
              m.push(c.type), g.push(h);
            }
        }
      return r.rawEncode(m, g);
    },
    /**
     * Encodes the type of an object by encoding a comma delimited list of its members
     *
     * @param {string} primaryType - Root type to encode
     * @param {Object} types - Type definitions
     * @returns {string} - Encoded representation of the type of an object
     */
    encodeType(n, u) {
      let o = "", d = this.findTypeDependencies(n, u).filter((m) => m !== n);
      d = [n].concat(d.sort());
      for (const m of d) {
        if (!u[m])
          throw new Error("No type definition specified: " + m);
        o += m + "(" + u[m].map(({ name: c, type: h }) => h + " " + c).join(",") + ")";
      }
      return o;
    },
    /**
     * Finds all types within a type defintion object
     *
     * @param {string} primaryType - Root type
     * @param {Object} types - Type definitions
     * @param {Array} results - current set of accumulated types
     * @returns {Array} - Set of all types found in the type definition
     */
    findTypeDependencies(n, u, o = []) {
      if (n = n.match(/^\w*/)[0], o.includes(n) || u[n] === void 0)
        return o;
      o.push(n);
      for (const d of u[n])
        for (const m of this.findTypeDependencies(d.type, u, o))
          !o.includes(m) && o.push(m);
      return o;
    },
    /**
     * Hashes an object
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to hash
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Hash of an object
     */
    hashStruct(n, u, o, d = !0) {
      return e.keccak(this.encodeData(n, u, o, d));
    },
    /**
     * Hashes the type of an object
     *
     * @param {string} primaryType - Root type to hash
     * @param {Object} types - Type definitions
     * @returns {string} - Hash of an object
     */
    hashType(n, u) {
      return e.keccak(this.encodeType(n, u));
    },
    /**
     * Removes properties from a message object that are not defined per EIP-712
     *
     * @param {Object} data - typed message object
     * @returns {Object} - typed message object with only allowed fields
     */
    sanitizeData(n) {
      const u = {};
      for (const o in i.properties)
        n[o] && (u[o] = n[o]);
      return u.types && (u.types = Object.assign({ EIP712Domain: [] }, u.types)), u;
    },
    /**
     * Returns the hash of a typed message as per EIP-712 for signing
     *
     * @param {Object} typedData - Types message data to sign
     * @returns {string} - sha3 hash for signing
     */
    hash(n, u = !0) {
      const o = this.sanitizeData(n), d = [Buffer.from("1901", "hex")];
      return d.push(this.hashStruct("EIP712Domain", o.domain, o.types, u)), o.primaryType !== "EIP712Domain" && d.push(this.hashStruct(o.primaryType, o.message, o.types, u)), e.keccak(Buffer.concat(d));
    }
  };
  hi = {
    TYPED_MESSAGE_SCHEMA: i,
    TypedDataUtils: t,
    hashForSignTypedDataLegacy: function(n) {
      return p(n.data);
    },
    hashForSignTypedData_v3: function(n) {
      return t.hash(n.data, !1);
    },
    hashForSignTypedData_v4: function(n) {
      return t.hash(n.data);
    }
  };
  function p(n) {
    const u = new Error("Expect argument to be non-empty array");
    if (typeof n != "object" || !n.length) throw u;
    const o = n.map(function(g) {
      return g.type === "bytes" ? e.toBuffer(g.value) : g.value;
    }), d = n.map(function(g) {
      return g.type;
    }), m = n.map(function(g) {
      if (!g.name) throw u;
      return g.type + " " + g.name;
    });
    return r.soliditySHA3(
      ["bytes32", "bytes32"],
      [
        r.soliditySHA3(new Array(n.length).fill("string"), m),
        r.soliditySHA3(d, o)
      ]
    );
  }
  return hi;
}
var St = {}, Da;
function Lh() {
  if (Da) return St;
  Da = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.filterFromParam = St.FilterPolyfill = void 0;
  const e = /* @__PURE__ */ gn(), r = /* @__PURE__ */ tt(), i = 5 * 60 * 1e3, t = {
    jsonrpc: "2.0",
    id: 0
  };
  let p = class {
    constructor(h) {
      this.logFilters = /* @__PURE__ */ new Map(), this.blockFilters = /* @__PURE__ */ new Set(), this.pendingTransactionFilters = /* @__PURE__ */ new Set(), this.cursors = /* @__PURE__ */ new Map(), this.timeouts = /* @__PURE__ */ new Map(), this.nextFilterId = (0, e.IntNumber)(1), this.REQUEST_THROTTLE_INTERVAL = 1e3, this.lastFetchTimestamp = /* @__PURE__ */ new Date(0), this.resolvers = [], this.provider = h;
    }
    async newFilter(h) {
      const s = n(h), f = this.makeFilterId(), b = await this.setInitialCursorPosition(f, s.fromBlock);
      return console.info(`Installing new log filter(${f}):`, s, "initial cursor position:", b), this.logFilters.set(f, s), this.setFilterTimeout(f), (0, r.hexStringFromIntNumber)(f);
    }
    async newBlockFilter() {
      const h = this.makeFilterId(), s = await this.setInitialCursorPosition(h, "latest");
      return console.info(`Installing new block filter (${h}) with initial cursor position:`, s), this.blockFilters.add(h), this.setFilterTimeout(h), (0, r.hexStringFromIntNumber)(h);
    }
    async newPendingTransactionFilter() {
      const h = this.makeFilterId(), s = await this.setInitialCursorPosition(h, "latest");
      return console.info(`Installing new block filter (${h}) with initial cursor position:`, s), this.pendingTransactionFilters.add(h), this.setFilterTimeout(h), (0, r.hexStringFromIntNumber)(h);
    }
    uninstallFilter(h) {
      const s = (0, r.intNumberFromHexString)(h);
      return console.info(`Uninstalling filter (${s})`), this.deleteFilter(s), !0;
    }
    getFilterChanges(h) {
      const s = (0, r.intNumberFromHexString)(h);
      return this.timeouts.has(s) && this.setFilterTimeout(s), this.logFilters.has(s) ? this.getLogFilterChanges(s) : this.blockFilters.has(s) ? this.getBlockFilterChanges(s) : this.pendingTransactionFilters.has(s) ? this.getPendingTransactionFilterChanges(s) : Promise.resolve(m());
    }
    async getFilterLogs(h) {
      const s = (0, r.intNumberFromHexString)(h), f = this.logFilters.get(s);
      return f ? this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_getLogs", params: [u(f)] })) : m();
    }
    makeFilterId() {
      return (0, e.IntNumber)(++this.nextFilterId);
    }
    sendAsyncPromise(h) {
      return new Promise((s, f) => {
        this.provider.sendAsync(h, (b, v) => {
          if (b)
            return f(b);
          if (Array.isArray(v) || v == null)
            return f(new Error(`unexpected response received: ${JSON.stringify(v)}`));
          s(v);
        });
      });
    }
    deleteFilter(h) {
      console.info(`Deleting filter (${h})`), this.logFilters.delete(h), this.blockFilters.delete(h), this.pendingTransactionFilters.delete(h), this.cursors.delete(h), this.timeouts.delete(h);
    }
    async getLogFilterChanges(h) {
      const s = this.logFilters.get(h), f = this.cursors.get(h);
      if (!f || !s)
        return m();
      const b = await this.getCurrentBlockHeight(), v = s.toBlock === "latest" ? b : s.toBlock;
      if (f > b || f > Number(s.toBlock))
        return g();
      console.info(`Fetching logs from ${f} to ${v} for filter ${h}`);
      const a = await this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_getLogs", params: [
        u(Object.assign(Object.assign({}, s), { fromBlock: f, toBlock: v }))
      ] }));
      if (Array.isArray(a.result)) {
        const R = a.result.map((I) => (0, r.intNumberFromHexString)(I.blockNumber || "0x0")), S = Math.max(...R);
        if (S && S > f) {
          const I = (0, e.IntNumber)(S + 1);
          console.info(`Moving cursor position for filter (${h}) from ${f} to ${I}`), this.cursors.set(h, I);
        }
      }
      return a;
    }
    async getBlockFilterChanges(h) {
      const s = this.cursors.get(h);
      if (!s)
        return m();
      const f = await this.getCurrentBlockHeight();
      if (s > f)
        return g();
      console.info(`Fetching blocks from ${s} to ${f} for filter (${h})`);
      const b = (await Promise.all(
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        (0, r.range)(s, f + 1).map((a) => this.getBlockHashByNumber((0, e.IntNumber)(a)))
      )).filter((a) => !!a), v = (0, e.IntNumber)(s + b.length);
      return console.info(`Moving cursor position for filter (${h}) from ${s} to ${v}`), this.cursors.set(h, v), Object.assign(Object.assign({}, t), { result: b });
    }
    async getPendingTransactionFilterChanges(h) {
      return Promise.resolve(g());
    }
    async setInitialCursorPosition(h, s) {
      const f = await this.getCurrentBlockHeight(), b = typeof s == "number" && s > f ? s : f;
      return this.cursors.set(h, b), b;
    }
    setFilterTimeout(h) {
      const s = this.timeouts.get(h);
      s && window.clearTimeout(s);
      const f = window.setTimeout(() => {
        console.info(`Filter (${h}) timed out`), this.deleteFilter(h);
      }, i);
      this.timeouts.set(h, f);
    }
    // throttle eth_blockNumber requests
    async getCurrentBlockHeight() {
      const h = /* @__PURE__ */ new Date();
      if (h.getTime() - this.lastFetchTimestamp.getTime() > this.REQUEST_THROTTLE_INTERVAL) {
        this.lastFetchTimestamp = h;
        const s = await this._getCurrentBlockHeight();
        this.currentBlockHeight = s, this.resolvers.forEach((f) => f(s)), this.resolvers = [];
      }
      return this.currentBlockHeight ? this.currentBlockHeight : new Promise((s) => this.resolvers.push(s));
    }
    async _getCurrentBlockHeight() {
      const { result: h } = await this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_blockNumber", params: [] }));
      return (0, r.intNumberFromHexString)((0, r.ensureHexString)(h));
    }
    async getBlockHashByNumber(h) {
      const s = await this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_getBlockByNumber", params: [(0, r.hexStringFromIntNumber)(h), !1] }));
      return s.result && typeof s.result.hash == "string" ? (0, r.ensureHexString)(s.result.hash) : null;
    }
  };
  St.FilterPolyfill = p;
  function n(c) {
    return {
      fromBlock: o(c.fromBlock),
      toBlock: o(c.toBlock),
      addresses: c.address === void 0 ? null : Array.isArray(c.address) ? c.address : [c.address],
      topics: c.topics || []
    };
  }
  St.filterFromParam = n;
  function u(c) {
    const h = {
      fromBlock: d(c.fromBlock),
      toBlock: d(c.toBlock),
      topics: c.topics
    };
    return c.addresses !== null && (h.address = c.addresses), h;
  }
  function o(c) {
    if (c === void 0 || c === "latest" || c === "pending")
      return "latest";
    if (c === "earliest")
      return (0, e.IntNumber)(0);
    if ((0, r.isHexString)(c))
      return (0, r.intNumberFromHexString)(c);
    throw new Error(`Invalid block option: ${String(c)}`);
  }
  function d(c) {
    return c === "latest" ? c : (0, r.hexStringFromIntNumber)(c);
  }
  function m() {
    return Object.assign(Object.assign({}, t), { error: { code: -32e3, message: "filter not found" } });
  }
  function g() {
    return Object.assign(Object.assign({}, t), { result: [] });
  }
  return St;
}
var Cr = {}, Ir = {}, Vt = {}, di, qa;
function js() {
  if (qa) return di;
  qa = 1, di = e;
  function e(r) {
    r = r || {};
    var i = r.max || Number.MAX_SAFE_INTEGER, t = typeof r.start < "u" ? r.start : Math.floor(Math.random() * i);
    return function() {
      return t = t % i, t++;
    };
  }
  return di;
}
var fi, ja;
function Bh() {
  if (ja) return fi;
  ja = 1;
  const e = (r, i) => function() {
    const t = i.promiseModule, p = new Array(arguments.length);
    for (let n = 0; n < arguments.length; n++)
      p[n] = arguments[n];
    return new t((n, u) => {
      i.errorFirst ? p.push(function(o, d) {
        if (i.multiArgs) {
          const m = new Array(arguments.length - 1);
          for (let g = 1; g < arguments.length; g++)
            m[g - 1] = arguments[g];
          o ? (m.unshift(o), u(m)) : n(m);
        } else o ? u(o) : n(d);
      }) : p.push(function(o) {
        if (i.multiArgs) {
          const d = new Array(arguments.length - 1);
          for (let m = 0; m < arguments.length; m++)
            d[m] = arguments[m];
          n(d);
        } else
          n(o);
      }), r.apply(this, p);
    });
  };
  return fi = (r, i) => {
    i = Object.assign({
      exclude: [/.+(Sync|Stream)$/],
      errorFirst: !0,
      promiseModule: Promise
    }, i);
    const t = (n) => {
      const u = (o) => typeof o == "string" ? n === o : o.test(n);
      return i.include ? i.include.some(u) : !i.exclude.some(u);
    };
    let p;
    typeof r == "function" ? p = function() {
      return i.excludeMain ? r.apply(this, arguments) : e(r, i).apply(this, arguments);
    } : p = Object.create(Object.getPrototypeOf(r));
    for (const n in r) {
      const u = r[n];
      p[n] = typeof u == "function" && t(n) ? e(u, i) : u;
    }
    return p;
  }, fi;
}
var zt = {}, sn = {}, $a;
function $s() {
  if ($a) return sn;
  $a = 1, Object.defineProperty(sn, "__esModule", { value: !0 });
  const e = hn();
  function r(p, n, u) {
    try {
      Reflect.apply(p, n, u);
    } catch (o) {
      setTimeout(() => {
        throw o;
      });
    }
  }
  function i(p) {
    const n = p.length, u = new Array(n);
    for (let o = 0; o < n; o += 1)
      u[o] = p[o];
    return u;
  }
  class t extends e.EventEmitter {
    emit(n, ...u) {
      let o = n === "error";
      const d = this._events;
      if (d !== void 0)
        o = o && d.error === void 0;
      else if (!o)
        return !1;
      if (o) {
        let g;
        if (u.length > 0 && ([g] = u), g instanceof Error)
          throw g;
        const c = new Error(`Unhandled error.${g ? ` (${g.message})` : ""}`);
        throw c.context = g, c;
      }
      const m = d[n];
      if (m === void 0)
        return !1;
      if (typeof m == "function")
        r(m, this, u);
      else {
        const g = m.length, c = i(m);
        for (let h = 0; h < g; h += 1)
          r(c[h], this, u);
      }
      return !0;
    }
  }
  return sn.default = t, sn;
}
var Ua;
function sl() {
  if (Ua) return zt;
  Ua = 1;
  var e = zt.__importDefault || function(o) {
    return o && o.__esModule ? o : { default: o };
  };
  Object.defineProperty(zt, "__esModule", { value: !0 }), zt.BaseBlockTracker = void 0;
  const r = e($s()), i = 1e3, t = (o, d) => o + d, p = ["sync", "latest"];
  let n = class extends r.default {
    constructor(d) {
      super(), this._blockResetDuration = d.blockResetDuration || 20 * i, this._usePastBlocks = d.usePastBlocks || !1, this._currentBlock = null, this._isRunning = !1, this._onNewListener = this._onNewListener.bind(this), this._onRemoveListener = this._onRemoveListener.bind(this), this._resetCurrentBlock = this._resetCurrentBlock.bind(this), this._setupInternalEvents();
    }
    async destroy() {
      this._cancelBlockResetTimeout(), await this._maybeEnd(), super.removeAllListeners();
    }
    isRunning() {
      return this._isRunning;
    }
    getCurrentBlock() {
      return this._currentBlock;
    }
    async getLatestBlock() {
      return this._currentBlock ? this._currentBlock : await new Promise((m) => this.once("latest", m));
    }
    // dont allow module consumer to remove our internal event listeners
    removeAllListeners(d) {
      return d ? super.removeAllListeners(d) : super.removeAllListeners(), this._setupInternalEvents(), this._onRemoveListener(), this;
    }
    _setupInternalEvents() {
      this.removeListener("newListener", this._onNewListener), this.removeListener("removeListener", this._onRemoveListener), this.on("newListener", this._onNewListener), this.on("removeListener", this._onRemoveListener);
    }
    _onNewListener(d) {
      p.includes(d) && this._maybeStart();
    }
    _onRemoveListener() {
      this._getBlockTrackerEventCount() > 0 || this._maybeEnd();
    }
    async _maybeStart() {
      this._isRunning || (this._isRunning = !0, this._cancelBlockResetTimeout(), await this._start(), this.emit("_started"));
    }
    async _maybeEnd() {
      this._isRunning && (this._isRunning = !1, this._setupBlockResetTimeout(), await this._end(), this.emit("_ended"));
    }
    _getBlockTrackerEventCount() {
      return p.map((d) => this.listenerCount(d)).reduce(t);
    }
    _shouldUseNewBlock(d) {
      const m = this._currentBlock;
      if (!m)
        return !0;
      const g = u(d), c = u(m);
      return this._usePastBlocks && g < c || g > c;
    }
    _newPotentialLatest(d) {
      this._shouldUseNewBlock(d) && this._setCurrentBlock(d);
    }
    _setCurrentBlock(d) {
      const m = this._currentBlock;
      this._currentBlock = d, this.emit("latest", d), this.emit("sync", { oldBlock: m, newBlock: d });
    }
    _setupBlockResetTimeout() {
      this._cancelBlockResetTimeout(), this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration), this._blockResetTimeout.unref && this._blockResetTimeout.unref();
    }
    _cancelBlockResetTimeout() {
      this._blockResetTimeout && clearTimeout(this._blockResetTimeout);
    }
    _resetCurrentBlock() {
      this._currentBlock = null;
    }
  };
  zt.BaseBlockTracker = n;
  function u(o) {
    return Number.parseInt(o, 16);
  }
  return zt;
}
var pi = {}, xr = {}, Ge = {};
class ol extends TypeError {
  constructor(r, i) {
    let t;
    const { message: p, explanation: n, ...u } = r, { path: o } = r, d = o.length === 0 ? p : `At path: ${o.join(".")} -- ${p}`;
    super(n ?? d), n != null && (this.cause = d), Object.assign(this, u), this.name = this.constructor.name, this.failures = () => t ?? (t = [r, ...i()]);
  }
}
function Nh(e) {
  return ze(e) && typeof e[Symbol.iterator] == "function";
}
function ze(e) {
  return typeof e == "object" && e != null;
}
function Ha(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const r = Object.getPrototypeOf(e);
  return r === null || r === Object.prototype;
}
function qe(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function Ph(e) {
  const { done: r, value: i } = e.next();
  return r ? void 0 : i;
}
function Oh(e, r, i, t) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: p, branch: n } = r, { type: u } = i, { refinement: o, message: d = `Expected a value of type \`${u}\`${o ? ` with refinement \`${o}\`` : ""}, but received: \`${qe(t)}\`` } = e;
  return {
    value: t,
    type: u,
    refinement: o,
    key: p[p.length - 1],
    path: p,
    branch: n,
    ...e,
    message: d
  };
}
function* As(e, r, i, t) {
  Nh(e) || (e = [e]);
  for (const p of e) {
    const n = Oh(p, r, i, t);
    n && (yield n);
  }
}
function* Us(e, r, i = {}) {
  const { path: t = [], branch: p = [e], coerce: n = !1, mask: u = !1 } = i, o = { path: t, branch: p };
  if (n && (e = r.coercer(e, o), u && r.type !== "type" && ze(r.schema) && ze(e) && !Array.isArray(e)))
    for (const m in e)
      r.schema[m] === void 0 && delete e[m];
  let d = "valid";
  for (const m of r.validator(e, o))
    m.explanation = i.message, d = "not_valid", yield [m, void 0];
  for (let [m, g, c] of r.entries(e, o)) {
    const h = Us(g, c, {
      path: m === void 0 ? t : [...t, m],
      branch: m === void 0 ? p : [...p, g],
      coerce: n,
      mask: u,
      message: i.message
    });
    for (const s of h)
      s[0] ? (d = s[0].refinement != null ? "not_refined" : "not_valid", yield [s[0], void 0]) : n && (g = s[1], m === void 0 ? e = g : e instanceof Map ? e.set(m, g) : e instanceof Set ? e.add(g) : ze(e) && (g !== void 0 || m in e) && (e[m] = g));
  }
  if (d !== "not_valid")
    for (const m of r.refiner(e, o))
      m.explanation = i.message, d = "not_refined", yield [m, void 0];
  d === "valid" && (yield [void 0, e]);
}
class De {
  constructor(r) {
    const { type: i, schema: t, validator: p, refiner: n, coercer: u = (d) => d, entries: o = function* () {
    } } = r;
    this.type = i, this.schema = t, this.entries = o, this.coercer = u, p ? this.validator = (d, m) => {
      const g = p(d, m);
      return As(g, m, this, d);
    } : this.validator = () => [], n ? this.refiner = (d, m) => {
      const g = n(d, m);
      return As(g, m, this, d);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(r, i) {
    return al(r, this, i);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(r, i) {
    return ul(r, this, i);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(r) {
    return Hs(r, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(r, i) {
    return cl(r, this, i);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(r, i = {}) {
    return Xt(r, this, i);
  }
}
function al(e, r, i) {
  const t = Xt(e, r, { message: i });
  if (t[0])
    throw t[0];
}
function ul(e, r, i) {
  const t = Xt(e, r, { coerce: !0, message: i });
  if (t[0])
    throw t[0];
  return t[1];
}
function cl(e, r, i) {
  const t = Xt(e, r, { coerce: !0, mask: !0, message: i });
  if (t[0])
    throw t[0];
  return t[1];
}
function Hs(e, r) {
  return !Xt(e, r)[0];
}
function Xt(e, r, i = {}) {
  const t = Us(e, r, i), p = Ph(t);
  return p[0] ? [new ol(p[0], function* () {
    for (const u of t)
      u[0] && (yield u[0]);
  }), void 0] : [void 0, p[1]];
}
function Fh(...e) {
  const r = e[0].type === "type", i = e.map((p) => p.schema), t = Object.assign({}, ...i);
  return r ? Wr(t) : Hr(t);
}
function Ve(e, r) {
  return new De({ type: e, schema: null, validator: r });
}
function Dh(e, r) {
  return new De({
    ...e,
    refiner: (i, t) => i === void 0 || e.refiner(i, t),
    validator(i, t) {
      return i === void 0 ? !0 : (r(i, t), e.validator(i, t));
    }
  });
}
function qh(e) {
  return new De({
    type: "dynamic",
    schema: null,
    *entries(r, i) {
      yield* e(r, i).entries(r, i);
    },
    validator(r, i) {
      return e(r, i).validator(r, i);
    },
    coercer(r, i) {
      return e(r, i).coercer(r, i);
    },
    refiner(r, i) {
      return e(r, i).refiner(r, i);
    }
  });
}
function jh(e) {
  let r;
  return new De({
    type: "lazy",
    schema: null,
    *entries(i, t) {
      r ?? (r = e()), yield* r.entries(i, t);
    },
    validator(i, t) {
      return r ?? (r = e()), r.validator(i, t);
    },
    coercer(i, t) {
      return r ?? (r = e()), r.coercer(i, t);
    },
    refiner(i, t) {
      return r ?? (r = e()), r.refiner(i, t);
    }
  });
}
function $h(e, r) {
  const { schema: i } = e, t = { ...i };
  for (const p of r)
    delete t[p];
  switch (e.type) {
    case "type":
      return Wr(t);
    default:
      return Hr(t);
  }
}
function Uh(e) {
  const r = e instanceof De, i = r ? { ...e.schema } : { ...e };
  for (const t in i)
    i[t] = ll(i[t]);
  return r && e.type === "type" ? Wr(i) : Hr(i);
}
function Hh(e, r) {
  const { schema: i } = e, t = {};
  for (const p of r)
    t[p] = i[p];
  switch (e.type) {
    case "type":
      return Wr(t);
    default:
      return Hr(t);
  }
}
function Wh(e, r) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), Ve(e, r);
}
function Vh() {
  return Ve("any", () => !0);
}
function zh(e) {
  return new De({
    type: "array",
    schema: e,
    *entries(r) {
      if (e && Array.isArray(r))
        for (const [i, t] of r.entries())
          yield [i, t, e];
    },
    coercer(r) {
      return Array.isArray(r) ? r.slice() : r;
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array value, but received: ${qe(r)}`;
    }
  });
}
function Jh() {
  return Ve("bigint", (e) => typeof e == "bigint");
}
function Gh() {
  return Ve("boolean", (e) => typeof e == "boolean");
}
function Zh() {
  return Ve("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${qe(e)}`);
}
function Kh(e) {
  const r = {}, i = e.map((t) => qe(t)).join();
  for (const t of e)
    r[t] = t;
  return new De({
    type: "enums",
    schema: r,
    validator(t) {
      return e.includes(t) || `Expected one of \`${i}\`, but received: ${qe(t)}`;
    }
  });
}
function Qh() {
  return Ve("func", (e) => typeof e == "function" || `Expected a function, but received: ${qe(e)}`);
}
function Yh(e) {
  return Ve("instance", (r) => r instanceof e || `Expected a \`${e.name}\` instance, but received: ${qe(r)}`);
}
function Xh() {
  return Ve("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${qe(e)}`);
}
function ed(e) {
  return new De({
    type: "intersection",
    schema: null,
    *entries(r, i) {
      for (const t of e)
        yield* t.entries(r, i);
    },
    *validator(r, i) {
      for (const t of e)
        yield* t.validator(r, i);
    },
    *refiner(r, i) {
      for (const t of e)
        yield* t.refiner(r, i);
    }
  });
}
function td(e) {
  const r = qe(e), i = typeof e;
  return new De({
    type: "literal",
    schema: i === "string" || i === "number" || i === "boolean" ? e : null,
    validator(t) {
      return t === e || `Expected the literal \`${r}\`, but received: ${qe(t)}`;
    }
  });
}
function rd(e, r) {
  return new De({
    type: "map",
    schema: null,
    *entries(i) {
      if (e && r && i instanceof Map)
        for (const [t, p] of i.entries())
          yield [t, t, e], yield [t, p, r];
    },
    coercer(i) {
      return i instanceof Map ? new Map(i) : i;
    },
    validator(i) {
      return i instanceof Map || `Expected a \`Map\` object, but received: ${qe(i)}`;
    }
  });
}
function Ws() {
  return Ve("never", () => !1);
}
function nd(e) {
  return new De({
    ...e,
    validator: (r, i) => r === null || e.validator(r, i),
    refiner: (r, i) => r === null || e.refiner(r, i)
  });
}
function id() {
  return Ve("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${qe(e)}`);
}
function Hr(e) {
  const r = e ? Object.keys(e) : [], i = Ws();
  return new De({
    type: "object",
    schema: e || null,
    *entries(t) {
      if (e && ze(t)) {
        const p = new Set(Object.keys(t));
        for (const n of r)
          p.delete(n), yield [n, t[n], e[n]];
        for (const n of p)
          yield [n, t[n], i];
      }
    },
    validator(t) {
      return ze(t) || `Expected an object, but received: ${qe(t)}`;
    },
    coercer(t) {
      return ze(t) ? { ...t } : t;
    }
  });
}
function ll(e) {
  return new De({
    ...e,
    validator: (r, i) => r === void 0 || e.validator(r, i),
    refiner: (r, i) => r === void 0 || e.refiner(r, i)
  });
}
function sd(e, r) {
  return new De({
    type: "record",
    schema: null,
    *entries(i) {
      if (ze(i))
        for (const t in i) {
          const p = i[t];
          yield [t, t, e], yield [t, p, r];
        }
    },
    validator(i) {
      return ze(i) || `Expected an object, but received: ${qe(i)}`;
    }
  });
}
function od() {
  return Ve("regexp", (e) => e instanceof RegExp);
}
function ad(e) {
  return new De({
    type: "set",
    schema: null,
    *entries(r) {
      if (e && r instanceof Set)
        for (const i of r)
          yield [i, i, e];
    },
    coercer(r) {
      return r instanceof Set ? new Set(r) : r;
    },
    validator(r) {
      return r instanceof Set || `Expected a \`Set\` object, but received: ${qe(r)}`;
    }
  });
}
function hl() {
  return Ve("string", (e) => typeof e == "string" || `Expected a string, but received: ${qe(e)}`);
}
function ud(e) {
  const r = Ws();
  return new De({
    type: "tuple",
    schema: null,
    *entries(i) {
      if (Array.isArray(i)) {
        const t = Math.max(e.length, i.length);
        for (let p = 0; p < t; p++)
          yield [p, i[p], e[p] || r];
      }
    },
    validator(i) {
      return Array.isArray(i) || `Expected an array, but received: ${qe(i)}`;
    }
  });
}
function Wr(e) {
  const r = Object.keys(e);
  return new De({
    type: "type",
    schema: e,
    *entries(i) {
      if (ze(i))
        for (const t of r)
          yield [t, i[t], e[t]];
    },
    validator(i) {
      return ze(i) || `Expected an object, but received: ${qe(i)}`;
    },
    coercer(i) {
      return ze(i) ? { ...i } : i;
    }
  });
}
function cd(e) {
  const r = e.map((i) => i.type).join(" | ");
  return new De({
    type: "union",
    schema: null,
    coercer(i) {
      for (const t of e) {
        const [p, n] = t.validate(i, { coerce: !0 });
        if (!p)
          return n;
      }
      return i;
    },
    validator(i, t) {
      const p = [];
      for (const n of e) {
        const [...u] = Us(i, n, t), [o] = u;
        if (o[0])
          for (const [d] of u)
            d && p.push(d);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${r}\`, but received: ${qe(i)}`,
        ...p
      ];
    }
  });
}
function dl() {
  return Ve("unknown", () => !0);
}
function Vs(e, r, i) {
  return new De({
    ...e,
    coercer: (t, p) => Hs(t, r) ? e.coercer(i(t, p), p) : e.coercer(t, p)
  });
}
function ld(e, r, i = {}) {
  return Vs(e, dl(), (t) => {
    const p = typeof r == "function" ? r() : r;
    if (t === void 0)
      return p;
    if (!i.strict && Ha(t) && Ha(p)) {
      const n = { ...t };
      let u = !1;
      for (const o in p)
        n[o] === void 0 && (n[o] = p[o], u = !0);
      if (u)
        return n;
    }
    return t;
  });
}
function hd(e) {
  return Vs(e, hl(), (r) => r.trim());
}
function dd(e) {
  return It(e, "empty", (r) => {
    const i = fl(r);
    return i === 0 || `Expected an empty ${e.type} but received one with a size of \`${i}\``;
  });
}
function fl(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function fd(e, r, i = {}) {
  const { exclusive: t } = i;
  return It(e, "max", (p) => t ? p < r : p <= r || `Expected a ${e.type} less than ${t ? "" : "or equal to "}${r} but received \`${p}\``);
}
function pd(e, r, i = {}) {
  const { exclusive: t } = i;
  return It(e, "min", (p) => t ? p > r : p >= r || `Expected a ${e.type} greater than ${t ? "" : "or equal to "}${r} but received \`${p}\``);
}
function gd(e) {
  return It(e, "nonempty", (r) => fl(r) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function md(e, r) {
  return It(e, "pattern", (i) => r.test(i) || `Expected a ${e.type} matching \`/${r.source}/\` but received "${i}"`);
}
function wd(e, r, i = r) {
  const t = `Expected a ${e.type}`, p = r === i ? `of \`${r}\`` : `between \`${r}\` and \`${i}\``;
  return It(e, "size", (n) => {
    if (typeof n == "number" || n instanceof Date)
      return r <= n && n <= i || `${t} ${p} but received \`${n}\``;
    if (n instanceof Map || n instanceof Set) {
      const { size: u } = n;
      return r <= u && u <= i || `${t} with a size ${p} but received one with a size of \`${u}\``;
    } else {
      const { length: u } = n;
      return r <= u && u <= i || `${t} with a length ${p} but received one with a length of \`${u}\``;
    }
  });
}
function It(e, r, i) {
  return new De({
    ...e,
    *refiner(t, p) {
      yield* e.refiner(t, p);
      const n = i(t, p), u = As(n, p, e, t);
      for (const o of u)
        yield { ...o, refinement: r };
    }
  });
}
const yd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: De,
  StructError: ol,
  any: Vh,
  array: zh,
  assert: al,
  assign: Fh,
  bigint: Jh,
  boolean: Gh,
  coerce: Vs,
  create: ul,
  date: Zh,
  defaulted: ld,
  define: Ve,
  deprecated: Dh,
  dynamic: qh,
  empty: dd,
  enums: Kh,
  func: Qh,
  instance: Yh,
  integer: Xh,
  intersection: ed,
  is: Hs,
  lazy: jh,
  literal: td,
  map: rd,
  mask: cl,
  max: fd,
  min: pd,
  never: Ws,
  nonempty: gd,
  nullable: nd,
  number: id,
  object: Hr,
  omit: $h,
  optional: ll,
  partial: Uh,
  pattern: md,
  pick: Hh,
  record: sd,
  refine: It,
  regexp: od,
  set: ad,
  size: wd,
  string: hl,
  struct: Wh,
  trimmed: hd,
  tuple: ud,
  type: Wr,
  union: cd,
  unknown: dl,
  validate: Xt
}, Symbol.toStringTag, { value: "Module" })), xt = /* @__PURE__ */ $r(yd);
var Wa;
function ot() {
  if (Wa) return Ge;
  Wa = 1, Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.assertExhaustive = Ge.assertStruct = Ge.assert = Ge.AssertionError = void 0;
  const e = xt;
  function r(m) {
    return typeof m == "object" && m !== null && "message" in m;
  }
  function i(m) {
    var g, c;
    return typeof ((c = (g = m == null ? void 0 : m.prototype) === null || g === void 0 ? void 0 : g.constructor) === null || c === void 0 ? void 0 : c.name) == "string";
  }
  function t(m) {
    const g = r(m) ? m.message : String(m);
    return g.endsWith(".") ? g.slice(0, -1) : g;
  }
  function p(m, g) {
    return i(m) ? new m({
      message: g
    }) : m({
      message: g
    });
  }
  class n extends Error {
    constructor(g) {
      super(g.message), this.code = "ERR_ASSERTION";
    }
  }
  Ge.AssertionError = n;
  function u(m, g = "Assertion failed.", c = n) {
    if (!m)
      throw g instanceof Error ? g : p(c, g);
  }
  Ge.assert = u;
  function o(m, g, c = "Assertion failed", h = n) {
    try {
      (0, e.assert)(m, g);
    } catch (s) {
      throw p(h, `${c}: ${t(s)}.`);
    }
  }
  Ge.assertStruct = o;
  function d(m) {
    throw new Error("Invalid branch reached. Should be detected during compilation.");
  }
  return Ge.assertExhaustive = d, Ge;
}
var Ar = {}, Va;
function pl() {
  if (Va) return Ar;
  Va = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.base64 = void 0;
  const e = xt, r = ot(), i = (t, p = {}) => {
    var n, u;
    const o = (n = p.paddingRequired) !== null && n !== void 0 ? n : !1, d = (u = p.characterSet) !== null && u !== void 0 ? u : "base64";
    let m;
    d === "base64" ? m = String.raw`[A-Za-z0-9+\/]` : ((0, r.assert)(d === "base64url"), m = String.raw`[-_A-Za-z0-9]`);
    let g;
    return o ? g = new RegExp(`^(?:${m}{4})*(?:${m}{3}=|${m}{2}==)?$`, "u") : g = new RegExp(`^(?:${m}{4})*(?:${m}{2,3}|${m}{3}=|${m}{2}==)?$`, "u"), (0, e.pattern)(t, g);
  };
  return Ar.base64 = i, Ar;
}
var ge = {}, gi = {}, za;
function yn() {
  return za || (za = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
    const r = xt, i = ot();
    e.HexStruct = (0, r.pattern)((0, r.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, r.pattern)((0, r.string)(), /^0x[0-9a-f]+$/iu);
    function t(m) {
      return (0, r.is)(m, e.HexStruct);
    }
    e.isHexString = t;
    function p(m) {
      return (0, r.is)(m, e.StrictHexStruct);
    }
    e.isStrictHexString = p;
    function n(m) {
      (0, i.assert)(t(m), "Value must be a hexadecimal string.");
    }
    e.assertIsHexString = n;
    function u(m) {
      (0, i.assert)(p(m), 'Value must be a hexadecimal string, starting with "0x".');
    }
    e.assertIsStrictHexString = u;
    function o(m) {
      return m.startsWith("0x") ? m : m.startsWith("0X") ? `0x${m.substring(2)}` : `0x${m}`;
    }
    e.add0x = o;
    function d(m) {
      return m.startsWith("0x") || m.startsWith("0X") ? m.substring(2) : m;
    }
    e.remove0x = d;
  }(gi)), gi;
}
var Ja;
function gl() {
  if (Ja) return ge;
  Ja = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.createDataView = ge.concatBytes = ge.valueToBytes = ge.stringToBytes = ge.numberToBytes = ge.signedBigIntToBytes = ge.bigIntToBytes = ge.hexToBytes = ge.bytesToString = ge.bytesToNumber = ge.bytesToSignedBigInt = ge.bytesToBigInt = ge.bytesToHex = ge.assertIsBytes = ge.isBytes = void 0;
  const e = ot(), r = yn(), i = 48, t = 58, p = 87;
  function n() {
    const D = [];
    return () => {
      if (D.length === 0)
        for (let H = 0; H < 256; H++)
          D.push(H.toString(16).padStart(2, "0"));
      return D;
    };
  }
  const u = n();
  function o(D) {
    return D instanceof Uint8Array;
  }
  ge.isBytes = o;
  function d(D) {
    (0, e.assert)(o(D), "Value must be a Uint8Array.");
  }
  ge.assertIsBytes = d;
  function m(D) {
    if (d(D), D.length === 0)
      return "0x";
    const H = u(), G = new Array(D.length);
    for (let ee = 0; ee < D.length; ee++)
      G[ee] = H[D[ee]];
    return (0, r.add0x)(G.join(""));
  }
  ge.bytesToHex = m;
  function g(D) {
    d(D);
    const H = m(D);
    return BigInt(H);
  }
  ge.bytesToBigInt = g;
  function c(D) {
    d(D);
    let H = BigInt(0);
    for (const G of D)
      H = (H << BigInt(8)) + BigInt(G);
    return BigInt.asIntN(D.length * 8, H);
  }
  ge.bytesToSignedBigInt = c;
  function h(D) {
    d(D);
    const H = g(D);
    return (0, e.assert)(H <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(H);
  }
  ge.bytesToNumber = h;
  function s(D) {
    return d(D), new TextDecoder().decode(D);
  }
  ge.bytesToString = s;
  function f(D) {
    var H;
    if (((H = D == null ? void 0 : D.toLowerCase) === null || H === void 0 ? void 0 : H.call(D)) === "0x")
      return new Uint8Array();
    (0, r.assertIsHexString)(D);
    const G = (0, r.remove0x)(D).toLowerCase(), ee = G.length % 2 === 0 ? G : `0${G}`, Y = new Uint8Array(ee.length / 2);
    for (let re = 0; re < Y.length; re++) {
      const F = ee.charCodeAt(re * 2), l = ee.charCodeAt(re * 2 + 1), E = F - (F < t ? i : p), M = l - (l < t ? i : p);
      Y[re] = E * 16 + M;
    }
    return Y;
  }
  ge.hexToBytes = f;
  function b(D) {
    (0, e.assert)(typeof D == "bigint", "Value must be a bigint."), (0, e.assert)(D >= BigInt(0), "Value must be a non-negative bigint.");
    const H = D.toString(16);
    return f(H);
  }
  ge.bigIntToBytes = b;
  function v(D, H) {
    (0, e.assert)(H > 0);
    const G = D >> BigInt(31);
    return !((~D & G) + (D & ~G) >> BigInt(H * 8 + -1));
  }
  function a(D, H) {
    (0, e.assert)(typeof D == "bigint", "Value must be a bigint."), (0, e.assert)(typeof H == "number", "Byte length must be a number."), (0, e.assert)(H > 0, "Byte length must be greater than 0."), (0, e.assert)(v(D, H), "Byte length is too small to represent the given value.");
    let G = D;
    const ee = new Uint8Array(H);
    for (let Y = 0; Y < ee.length; Y++)
      ee[Y] = Number(BigInt.asUintN(8, G)), G >>= BigInt(8);
    return ee.reverse();
  }
  ge.signedBigIntToBytes = a;
  function R(D) {
    (0, e.assert)(typeof D == "number", "Value must be a number."), (0, e.assert)(D >= 0, "Value must be a non-negative number."), (0, e.assert)(Number.isSafeInteger(D), "Value is not a safe integer. Use `bigIntToBytes` instead.");
    const H = D.toString(16);
    return f(H);
  }
  ge.numberToBytes = R;
  function S(D) {
    return (0, e.assert)(typeof D == "string", "Value must be a string."), new TextEncoder().encode(D);
  }
  ge.stringToBytes = S;
  function I(D) {
    if (typeof D == "bigint")
      return b(D);
    if (typeof D == "number")
      return R(D);
    if (typeof D == "string")
      return D.startsWith("0x") ? f(D) : S(D);
    if (o(D))
      return D;
    throw new TypeError(`Unsupported value type: "${typeof D}".`);
  }
  ge.valueToBytes = I;
  function T(D) {
    const H = new Array(D.length);
    let G = 0;
    for (let Y = 0; Y < D.length; Y++) {
      const re = I(D[Y]);
      H[Y] = re, G += re.length;
    }
    const ee = new Uint8Array(G);
    for (let Y = 0, re = 0; Y < H.length; Y++)
      ee.set(H[Y], re), re += H[Y].length;
    return ee;
  }
  ge.concatBytes = T;
  function q(D) {
    if (typeof Buffer < "u" && D instanceof Buffer) {
      const H = D.buffer.slice(D.byteOffset, D.byteOffset + D.byteLength);
      return new DataView(H);
    }
    return new DataView(D.buffer, D.byteOffset, D.byteLength);
  }
  return ge.createDataView = q, ge;
}
var Tr = {}, Ga;
function bd() {
  if (Ga) return Tr;
  Ga = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.ChecksumStruct = void 0;
  const e = xt, r = pl();
  return Tr.ChecksumStruct = (0, e.size)((0, r.base64)((0, e.string)(), { paddingRequired: !0 }), 44, 44), Tr;
}
var Ze = {}, Za;
function vd() {
  if (Za) return Ze;
  Za = 1, Object.defineProperty(Ze, "__esModule", { value: !0 }), Ze.createHex = Ze.createBytes = Ze.createBigInt = Ze.createNumber = void 0;
  const e = xt, r = ot(), i = gl(), t = yn(), p = (0, e.union)([(0, e.number)(), (0, e.bigint)(), (0, e.string)(), t.StrictHexStruct]), n = (0, e.coerce)((0, e.number)(), p, Number), u = (0, e.coerce)((0, e.bigint)(), p, BigInt);
  (0, e.union)([t.StrictHexStruct, (0, e.instance)(Uint8Array)]);
  const o = (0, e.coerce)((0, e.instance)(Uint8Array), (0, e.union)([t.StrictHexStruct]), i.hexToBytes), d = (0, e.coerce)(t.StrictHexStruct, (0, e.instance)(Uint8Array), i.bytesToHex);
  function m(s) {
    try {
      const f = (0, e.create)(s, n);
      return (0, r.assert)(Number.isFinite(f), `Expected a number-like value, got "${s}".`), f;
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a number-like value, got "${s}".`) : f;
    }
  }
  Ze.createNumber = m;
  function g(s) {
    try {
      return (0, e.create)(s, u);
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a number-like value, got "${String(f.value)}".`) : f;
    }
  }
  Ze.createBigInt = g;
  function c(s) {
    if (typeof s == "string" && s.toLowerCase() === "0x")
      return new Uint8Array();
    try {
      return (0, e.create)(s, o);
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a bytes-like value, got "${String(f.value)}".`) : f;
    }
  }
  Ze.createBytes = c;
  function h(s) {
    if (s instanceof Uint8Array && s.length === 0 || typeof s == "string" && s.toLowerCase() === "0x")
      return "0x";
    try {
      return (0, e.create)(s, d);
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a bytes-like value, got "${String(f.value)}".`) : f;
    }
  }
  return Ze.createHex = h, Ze;
}
var et = {}, Ka;
function _d() {
  if (Ka) return et;
  Ka = 1;
  var e = et.__classPrivateFieldSet || function(u, o, d, m, g) {
    if (m === "m") throw new TypeError("Private method is not writable");
    if (m === "a" && !g) throw new TypeError("Private accessor was defined without a setter");
    if (typeof o == "function" ? u !== o || !g : !o.has(u)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return m === "a" ? g.call(u, d) : g ? g.value = d : o.set(u, d), d;
  }, r = et.__classPrivateFieldGet || function(u, o, d, m) {
    if (d === "a" && !m) throw new TypeError("Private accessor was defined without a getter");
    if (typeof o == "function" ? u !== o || !m : !o.has(u)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return d === "m" ? m : d === "a" ? m.call(u) : m ? m.value : o.get(u);
  }, i, t;
  Object.defineProperty(et, "__esModule", { value: !0 }), et.FrozenSet = et.FrozenMap = void 0;
  class p {
    constructor(o) {
      i.set(this, void 0), e(this, i, new Map(o), "f"), Object.freeze(this);
    }
    get size() {
      return r(this, i, "f").size;
    }
    [(i = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      return r(this, i, "f")[Symbol.iterator]();
    }
    entries() {
      return r(this, i, "f").entries();
    }
    forEach(o, d) {
      return r(this, i, "f").forEach((m, g, c) => o.call(d, m, g, this));
    }
    get(o) {
      return r(this, i, "f").get(o);
    }
    has(o) {
      return r(this, i, "f").has(o);
    }
    keys() {
      return r(this, i, "f").keys();
    }
    values() {
      return r(this, i, "f").values();
    }
    toString() {
      return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([o, d]) => `${String(o)} => ${String(d)}`).join(", ")} ` : ""}}`;
    }
  }
  et.FrozenMap = p;
  class n {
    constructor(o) {
      t.set(this, void 0), e(this, t, new Set(o), "f"), Object.freeze(this);
    }
    get size() {
      return r(this, t, "f").size;
    }
    [(t = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      return r(this, t, "f")[Symbol.iterator]();
    }
    entries() {
      return r(this, t, "f").entries();
    }
    forEach(o, d) {
      return r(this, t, "f").forEach((m, g, c) => o.call(d, m, g, this));
    }
    has(o) {
      return r(this, t, "f").has(o);
    }
    keys() {
      return r(this, t, "f").keys();
    }
    values() {
      return r(this, t, "f").values();
    }
    toString() {
      return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((o) => String(o)).join(", ")} ` : ""}}`;
    }
  }
  return et.FrozenSet = n, Object.freeze(p), Object.freeze(p.prototype), Object.freeze(n), Object.freeze(n.prototype), et;
}
var mi = {}, Qa;
function Ed() {
  return Qa || (Qa = 1, Object.defineProperty(mi, "__esModule", { value: !0 })), mi;
}
var wi = {}, Ya;
function Rd() {
  return Ya || (Ya = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.getJsonSize = e.isValidJson = e.JsonStruct = e.UnsafeJsonStruct = void 0;
    const r = xt, i = ot(), t = () => (0, r.define)("finite number", (T) => (0, r.is)(T, (0, r.number)()) && Number.isFinite(T));
    e.UnsafeJsonStruct = (0, r.union)([
      (0, r.literal)(null),
      (0, r.boolean)(),
      t(),
      (0, r.string)(),
      (0, r.array)((0, r.lazy)(() => e.UnsafeJsonStruct)),
      (0, r.record)((0, r.string)(), (0, r.lazy)(() => e.UnsafeJsonStruct))
    ]), e.JsonStruct = (0, r.define)("Json", (T, q) => {
      function D(H, G) {
        const Y = [...G.validator(H, q)];
        return Y.length > 0 ? Y : !0;
      }
      try {
        const H = D(T, e.UnsafeJsonStruct);
        return H !== !0 ? H : D(JSON.parse(JSON.stringify(T)), e.UnsafeJsonStruct);
      } catch (H) {
        return H instanceof RangeError ? "Circular reference detected" : !1;
      }
    });
    function p(T) {
      return (0, r.is)(T, e.JsonStruct);
    }
    e.isValidJson = p;
    function n(T) {
      (0, i.assertStruct)(T, e.JsonStruct, "Invalid JSON value");
      const q = JSON.stringify(T);
      return new TextEncoder().encode(q).byteLength;
    }
    e.getJsonSize = n, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, r.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, r.nullable)((0, r.union)([(0, r.number)(), (0, r.string)()])), e.JsonRpcErrorStruct = (0, r.object)({
      code: (0, r.integer)(),
      message: (0, r.string)(),
      data: (0, r.optional)(e.JsonStruct),
      stack: (0, r.optional)((0, r.string)())
    }), e.JsonRpcParamsStruct = (0, r.optional)((0, r.union)([(0, r.record)((0, r.string)(), e.JsonStruct), (0, r.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      method: (0, r.string)(),
      params: e.JsonRpcParamsStruct
    }), e.JsonRpcNotificationStruct = (0, r.omit)(e.JsonRpcRequestStruct, ["id"]);
    function u(T) {
      return (0, r.is)(T, e.JsonRpcNotificationStruct);
    }
    e.isJsonRpcNotification = u;
    function o(T, q) {
      (0, i.assertStruct)(T, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", q);
    }
    e.assertIsJsonRpcNotification = o;
    function d(T) {
      return (0, r.is)(T, e.JsonRpcRequestStruct);
    }
    e.isJsonRpcRequest = d;
    function m(T, q) {
      (0, i.assertStruct)(T, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", q);
    }
    e.assertIsJsonRpcRequest = m, e.PendingJsonRpcResponseStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      result: (0, r.optional)((0, r.unknown)()),
      error: (0, r.optional)(e.JsonRpcErrorStruct)
    }), e.JsonRpcSuccessStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      result: e.JsonStruct
    }), e.JsonRpcFailureStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      error: e.JsonRpcErrorStruct
    }), e.JsonRpcResponseStruct = (0, r.union)([
      e.JsonRpcSuccessStruct,
      e.JsonRpcFailureStruct
    ]);
    function g(T) {
      return (0, r.is)(T, e.PendingJsonRpcResponseStruct);
    }
    e.isPendingJsonRpcResponse = g;
    function c(T, q) {
      (0, i.assertStruct)(T, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", q);
    }
    e.assertIsPendingJsonRpcResponse = c;
    function h(T) {
      return (0, r.is)(T, e.JsonRpcResponseStruct);
    }
    e.isJsonRpcResponse = h;
    function s(T, q) {
      (0, i.assertStruct)(T, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", q);
    }
    e.assertIsJsonRpcResponse = s;
    function f(T) {
      return (0, r.is)(T, e.JsonRpcSuccessStruct);
    }
    e.isJsonRpcSuccess = f;
    function b(T, q) {
      (0, i.assertStruct)(T, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", q);
    }
    e.assertIsJsonRpcSuccess = b;
    function v(T) {
      return (0, r.is)(T, e.JsonRpcFailureStruct);
    }
    e.isJsonRpcFailure = v;
    function a(T, q) {
      (0, i.assertStruct)(T, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", q);
    }
    e.assertIsJsonRpcFailure = a;
    function R(T) {
      return (0, r.is)(T, e.JsonRpcErrorStruct);
    }
    e.isJsonRpcError = R;
    function S(T, q) {
      (0, i.assertStruct)(T, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", q);
    }
    e.assertIsJsonRpcError = S;
    function I(T) {
      const { permitEmptyString: q, permitFractions: D, permitNull: H } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, T);
      return (ee) => !!(typeof ee == "number" && (D || Number.isInteger(ee)) || typeof ee == "string" && (q || ee.length > 0) || H && ee === null);
    }
    e.getJsonRpcIdValidator = I;
  }(wi)), wi;
}
var yi = {}, Xa;
function Sd() {
  return Xa || (Xa = 1, Object.defineProperty(yi, "__esModule", { value: !0 })), yi;
}
var nt = {}, eu;
function Md() {
  if (eu) return nt;
  eu = 1;
  var e = nt.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty(nt, "__esModule", { value: !0 }), nt.createModuleLogger = nt.createProjectLogger = void 0;
  const i = (0, e(kl()).default)("metamask");
  function t(n) {
    return i.extend(n);
  }
  nt.createProjectLogger = t;
  function p(n, u) {
    return n.extend(u);
  }
  return nt.createModuleLogger = p, nt;
}
var bi = {}, tu;
function kd() {
  return tu || (tu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
    function r(m) {
      return Array.isArray(m) && m.length > 0;
    }
    e.isNonEmptyArray = r;
    function i(m) {
      return m == null;
    }
    e.isNullOrUndefined = i;
    function t(m) {
      return !!m && typeof m == "object" && !Array.isArray(m);
    }
    e.isObject = t;
    const p = (m, g) => Object.hasOwnProperty.call(m, g);
    e.hasProperty = p, function(m) {
      m[m.Null = 4] = "Null", m[m.Comma = 1] = "Comma", m[m.Wrapper = 1] = "Wrapper", m[m.True = 4] = "True", m[m.False = 5] = "False", m[m.Quote = 1] = "Quote", m[m.Colon = 1] = "Colon", m[m.Date = 24] = "Date";
    }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
    function n(m) {
      if (typeof m != "object" || m === null)
        return !1;
      try {
        let g = m;
        for (; Object.getPrototypeOf(g) !== null; )
          g = Object.getPrototypeOf(g);
        return Object.getPrototypeOf(m) === g;
      } catch {
        return !1;
      }
    }
    e.isPlainObject = n;
    function u(m) {
      return m.charCodeAt(0) <= 127;
    }
    e.isASCII = u;
    function o(m) {
      var g;
      return m.split("").reduce((h, s) => u(s) ? h + 1 : h + 2, 0) + ((g = m.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && g !== void 0 ? g : []).length;
    }
    e.calculateStringSize = o;
    function d(m) {
      return m.toString().length;
    }
    e.calculateNumberSize = d;
  }(bi)), bi;
}
var Ke = {}, ru;
function Cd() {
  if (ru) return Ke;
  ru = 1, Object.defineProperty(Ke, "__esModule", { value: !0 }), Ke.hexToBigInt = Ke.hexToNumber = Ke.bigIntToHex = Ke.numberToHex = void 0;
  const e = ot(), r = yn(), i = (u) => ((0, e.assert)(typeof u == "number", "Value must be a number."), (0, e.assert)(u >= 0, "Value must be a non-negative number."), (0, e.assert)(Number.isSafeInteger(u), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, r.add0x)(u.toString(16)));
  Ke.numberToHex = i;
  const t = (u) => ((0, e.assert)(typeof u == "bigint", "Value must be a bigint."), (0, e.assert)(u >= 0, "Value must be a non-negative bigint."), (0, r.add0x)(u.toString(16)));
  Ke.bigIntToHex = t;
  const p = (u) => {
    (0, r.assertIsHexString)(u);
    const o = parseInt(u, 16);
    return (0, e.assert)(Number.isSafeInteger(o), "Value is not a safe integer. Use `hexToBigInt` instead."), o;
  };
  Ke.hexToNumber = p;
  const n = (u) => ((0, r.assertIsHexString)(u), BigInt((0, r.add0x)(u)));
  return Ke.hexToBigInt = n, Ke;
}
var vi = {}, nu;
function Id() {
  return nu || (nu = 1, Object.defineProperty(vi, "__esModule", { value: !0 })), vi;
}
var _i = {}, iu;
function xd() {
  return iu || (iu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(n) {
      n[n.Millisecond = 1] = "Millisecond", n[n.Second = 1e3] = "Second", n[n.Minute = 6e4] = "Minute", n[n.Hour = 36e5] = "Hour", n[n.Day = 864e5] = "Day", n[n.Week = 6048e5] = "Week", n[n.Year = 31536e6] = "Year";
    }(e.Duration || (e.Duration = {}));
    const r = (n) => Number.isInteger(n) && n >= 0, i = (n, u) => {
      if (!r(n))
        throw new Error(`"${u}" must be a non-negative integer. Received: "${n}".`);
    };
    function t(n, u) {
      return i(n, "count"), n * u;
    }
    e.inMilliseconds = t;
    function p(n) {
      return i(n, "timestamp"), Date.now() - n;
    }
    e.timeSince = p;
  }(_i)), _i;
}
var Ei = {}, su;
function Ad() {
  return su || (su = 1, Object.defineProperty(Ei, "__esModule", { value: !0 })), Ei;
}
var Ri = {}, on = { exports: {} }, Si, ou;
function bn() {
  if (ou) return Si;
  ou = 1;
  const e = "2.0.0", r = 256, i = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, t = 16, p = r - 6;
  return Si = {
    MAX_LENGTH: r,
    MAX_SAFE_COMPONENT_LENGTH: t,
    MAX_SAFE_BUILD_LENGTH: p,
    MAX_SAFE_INTEGER: i,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: e,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, Si;
}
var Mi, au;
function vn() {
  return au || (au = 1, Mi = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {
  }), Mi;
}
var uu;
function Vr() {
  return uu || (uu = 1, function(e, r) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: i,
      MAX_SAFE_BUILD_LENGTH: t,
      MAX_LENGTH: p
    } = bn(), n = vn();
    r = e.exports = {};
    const u = r.re = [], o = r.safeRe = [], d = r.src = [], m = r.safeSrc = [], g = r.t = {};
    let c = 0;
    const h = "[a-zA-Z0-9-]", s = [
      ["\\s", 1],
      ["\\d", p],
      [h, t]
    ], f = (v) => {
      for (const [a, R] of s)
        v = v.split(`${a}*`).join(`${a}{0,${R}}`).split(`${a}+`).join(`${a}{1,${R}}`);
      return v;
    }, b = (v, a, R) => {
      const S = f(a), I = c++;
      n(v, I, a), g[v] = I, d[I] = a, m[I] = S, u[I] = new RegExp(a, R ? "g" : void 0), o[I] = new RegExp(S, R ? "g" : void 0);
    };
    b("NUMERICIDENTIFIER", "0|[1-9]\\d*"), b("NUMERICIDENTIFIERLOOSE", "\\d+"), b("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${h}*`), b("MAINVERSION", `(${d[g.NUMERICIDENTIFIER]})\\.(${d[g.NUMERICIDENTIFIER]})\\.(${d[g.NUMERICIDENTIFIER]})`), b("MAINVERSIONLOOSE", `(${d[g.NUMERICIDENTIFIERLOOSE]})\\.(${d[g.NUMERICIDENTIFIERLOOSE]})\\.(${d[g.NUMERICIDENTIFIERLOOSE]})`), b("PRERELEASEIDENTIFIER", `(?:${d[g.NUMERICIDENTIFIER]}|${d[g.NONNUMERICIDENTIFIER]})`), b("PRERELEASEIDENTIFIERLOOSE", `(?:${d[g.NUMERICIDENTIFIERLOOSE]}|${d[g.NONNUMERICIDENTIFIER]})`), b("PRERELEASE", `(?:-(${d[g.PRERELEASEIDENTIFIER]}(?:\\.${d[g.PRERELEASEIDENTIFIER]})*))`), b("PRERELEASELOOSE", `(?:-?(${d[g.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${d[g.PRERELEASEIDENTIFIERLOOSE]})*))`), b("BUILDIDENTIFIER", `${h}+`), b("BUILD", `(?:\\+(${d[g.BUILDIDENTIFIER]}(?:\\.${d[g.BUILDIDENTIFIER]})*))`), b("FULLPLAIN", `v?${d[g.MAINVERSION]}${d[g.PRERELEASE]}?${d[g.BUILD]}?`), b("FULL", `^${d[g.FULLPLAIN]}$`), b("LOOSEPLAIN", `[v=\\s]*${d[g.MAINVERSIONLOOSE]}${d[g.PRERELEASELOOSE]}?${d[g.BUILD]}?`), b("LOOSE", `^${d[g.LOOSEPLAIN]}$`), b("GTLT", "((?:<|>)?=?)"), b("XRANGEIDENTIFIERLOOSE", `${d[g.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), b("XRANGEIDENTIFIER", `${d[g.NUMERICIDENTIFIER]}|x|X|\\*`), b("XRANGEPLAIN", `[v=\\s]*(${d[g.XRANGEIDENTIFIER]})(?:\\.(${d[g.XRANGEIDENTIFIER]})(?:\\.(${d[g.XRANGEIDENTIFIER]})(?:${d[g.PRERELEASE]})?${d[g.BUILD]}?)?)?`), b("XRANGEPLAINLOOSE", `[v=\\s]*(${d[g.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[g.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[g.XRANGEIDENTIFIERLOOSE]})(?:${d[g.PRERELEASELOOSE]})?${d[g.BUILD]}?)?)?`), b("XRANGE", `^${d[g.GTLT]}\\s*${d[g.XRANGEPLAIN]}$`), b("XRANGELOOSE", `^${d[g.GTLT]}\\s*${d[g.XRANGEPLAINLOOSE]}$`), b("COERCEPLAIN", `(^|[^\\d])(\\d{1,${i}})(?:\\.(\\d{1,${i}}))?(?:\\.(\\d{1,${i}}))?`), b("COERCE", `${d[g.COERCEPLAIN]}(?:$|[^\\d])`), b("COERCEFULL", d[g.COERCEPLAIN] + `(?:${d[g.PRERELEASE]})?(?:${d[g.BUILD]})?(?:$|[^\\d])`), b("COERCERTL", d[g.COERCE], !0), b("COERCERTLFULL", d[g.COERCEFULL], !0), b("LONETILDE", "(?:~>?)"), b("TILDETRIM", `(\\s*)${d[g.LONETILDE]}\\s+`, !0), r.tildeTrimReplace = "$1~", b("TILDE", `^${d[g.LONETILDE]}${d[g.XRANGEPLAIN]}$`), b("TILDELOOSE", `^${d[g.LONETILDE]}${d[g.XRANGEPLAINLOOSE]}$`), b("LONECARET", "(?:\\^)"), b("CARETTRIM", `(\\s*)${d[g.LONECARET]}\\s+`, !0), r.caretTrimReplace = "$1^", b("CARET", `^${d[g.LONECARET]}${d[g.XRANGEPLAIN]}$`), b("CARETLOOSE", `^${d[g.LONECARET]}${d[g.XRANGEPLAINLOOSE]}$`), b("COMPARATORLOOSE", `^${d[g.GTLT]}\\s*(${d[g.LOOSEPLAIN]})$|^$`), b("COMPARATOR", `^${d[g.GTLT]}\\s*(${d[g.FULLPLAIN]})$|^$`), b("COMPARATORTRIM", `(\\s*)${d[g.GTLT]}\\s*(${d[g.LOOSEPLAIN]}|${d[g.XRANGEPLAIN]})`, !0), r.comparatorTrimReplace = "$1$2$3", b("HYPHENRANGE", `^\\s*(${d[g.XRANGEPLAIN]})\\s+-\\s+(${d[g.XRANGEPLAIN]})\\s*$`), b("HYPHENRANGELOOSE", `^\\s*(${d[g.XRANGEPLAINLOOSE]})\\s+-\\s+(${d[g.XRANGEPLAINLOOSE]})\\s*$`), b("STAR", "(<|>)?=?\\s*\\*"), b("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), b("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }(on, on.exports)), on.exports;
}
var ki, cu;
function zs() {
  if (cu) return ki;
  cu = 1;
  const e = Object.freeze({ loose: !0 }), r = Object.freeze({});
  return ki = (t) => t ? typeof t != "object" ? e : t : r, ki;
}
var Ci, lu;
function ml() {
  if (lu) return Ci;
  lu = 1;
  const e = /^[0-9]+$/, r = (t, p) => {
    const n = e.test(t), u = e.test(p);
    return n && u && (t = +t, p = +p), t === p ? 0 : n && !u ? -1 : u && !n ? 1 : t < p ? -1 : 1;
  };
  return Ci = {
    compareIdentifiers: r,
    rcompareIdentifiers: (t, p) => r(p, t)
  }, Ci;
}
var Ii, hu;
function Ue() {
  if (hu) return Ii;
  hu = 1;
  const e = vn(), { MAX_LENGTH: r, MAX_SAFE_INTEGER: i } = bn(), { safeRe: t, safeSrc: p, t: n } = Vr(), u = zs(), { compareIdentifiers: o } = ml();
  class d {
    constructor(g, c) {
      if (c = u(c), g instanceof d) {
        if (g.loose === !!c.loose && g.includePrerelease === !!c.includePrerelease)
          return g;
        g = g.version;
      } else if (typeof g != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof g}".`);
      if (g.length > r)
        throw new TypeError(
          `version is longer than ${r} characters`
        );
      e("SemVer", g, c), this.options = c, this.loose = !!c.loose, this.includePrerelease = !!c.includePrerelease;
      const h = g.trim().match(c.loose ? t[n.LOOSE] : t[n.FULL]);
      if (!h)
        throw new TypeError(`Invalid Version: ${g}`);
      if (this.raw = g, this.major = +h[1], this.minor = +h[2], this.patch = +h[3], this.major > i || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > i || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > i || this.patch < 0)
        throw new TypeError("Invalid patch version");
      h[4] ? this.prerelease = h[4].split(".").map((s) => {
        if (/^[0-9]+$/.test(s)) {
          const f = +s;
          if (f >= 0 && f < i)
            return f;
        }
        return s;
      }) : this.prerelease = [], this.build = h[5] ? h[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(g) {
      if (e("SemVer.compare", this.version, this.options, g), !(g instanceof d)) {
        if (typeof g == "string" && g === this.version)
          return 0;
        g = new d(g, this.options);
      }
      return g.version === this.version ? 0 : this.compareMain(g) || this.comparePre(g);
    }
    compareMain(g) {
      return g instanceof d || (g = new d(g, this.options)), o(this.major, g.major) || o(this.minor, g.minor) || o(this.patch, g.patch);
    }
    comparePre(g) {
      if (g instanceof d || (g = new d(g, this.options)), this.prerelease.length && !g.prerelease.length)
        return -1;
      if (!this.prerelease.length && g.prerelease.length)
        return 1;
      if (!this.prerelease.length && !g.prerelease.length)
        return 0;
      let c = 0;
      do {
        const h = this.prerelease[c], s = g.prerelease[c];
        if (e("prerelease compare", c, h, s), h === void 0 && s === void 0)
          return 0;
        if (s === void 0)
          return 1;
        if (h === void 0)
          return -1;
        if (h === s)
          continue;
        return o(h, s);
      } while (++c);
    }
    compareBuild(g) {
      g instanceof d || (g = new d(g, this.options));
      let c = 0;
      do {
        const h = this.build[c], s = g.build[c];
        if (e("build compare", c, h, s), h === void 0 && s === void 0)
          return 0;
        if (s === void 0)
          return 1;
        if (h === void 0)
          return -1;
        if (h === s)
          continue;
        return o(h, s);
      } while (++c);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(g, c, h) {
      if (g.startsWith("pre")) {
        if (!c && h === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (c) {
          const s = new RegExp(`^${this.options.loose ? p[n.PRERELEASELOOSE] : p[n.PRERELEASE]}$`), f = `-${c}`.match(s);
          if (!f || f[1] !== c)
            throw new Error(`invalid identifier: ${c}`);
        }
      }
      switch (g) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", c, h);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", c, h);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", c, h), this.inc("pre", c, h);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", c, h), this.inc("pre", c, h);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const s = Number(h) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [s];
          else {
            let f = this.prerelease.length;
            for (; --f >= 0; )
              typeof this.prerelease[f] == "number" && (this.prerelease[f]++, f = -2);
            if (f === -1) {
              if (c === this.prerelease.join(".") && h === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(s);
            }
          }
          if (c) {
            let f = [c, s];
            h === !1 && (f = [c]), o(this.prerelease[0], c) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = f) : this.prerelease = f;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${g}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return Ii = d, Ii;
}
var xi, du;
function er() {
  if (du) return xi;
  du = 1;
  const e = Ue();
  return xi = (i, t, p = !1) => {
    if (i instanceof e)
      return i;
    try {
      return new e(i, t);
    } catch (n) {
      if (!p)
        return null;
      throw n;
    }
  }, xi;
}
var Ai, fu;
function Td() {
  if (fu) return Ai;
  fu = 1;
  const e = er();
  return Ai = (i, t) => {
    const p = e(i, t);
    return p ? p.version : null;
  }, Ai;
}
var Ti, pu;
function Ld() {
  if (pu) return Ti;
  pu = 1;
  const e = er();
  return Ti = (i, t) => {
    const p = e(i.trim().replace(/^[=v]+/, ""), t);
    return p ? p.version : null;
  }, Ti;
}
var Li, gu;
function Bd() {
  if (gu) return Li;
  gu = 1;
  const e = Ue();
  return Li = (i, t, p, n, u) => {
    typeof p == "string" && (u = n, n = p, p = void 0);
    try {
      return new e(
        i instanceof e ? i.version : i,
        p
      ).inc(t, n, u).version;
    } catch {
      return null;
    }
  }, Li;
}
var Bi, mu;
function Nd() {
  if (mu) return Bi;
  mu = 1;
  const e = er();
  return Bi = (i, t) => {
    const p = e(i, null, !0), n = e(t, null, !0), u = p.compare(n);
    if (u === 0)
      return null;
    const o = u > 0, d = o ? p : n, m = o ? n : p, g = !!d.prerelease.length;
    if (!!m.prerelease.length && !g) {
      if (!m.patch && !m.minor)
        return "major";
      if (m.compareMain(d) === 0)
        return m.minor && !m.patch ? "minor" : "patch";
    }
    const h = g ? "pre" : "";
    return p.major !== n.major ? h + "major" : p.minor !== n.minor ? h + "minor" : p.patch !== n.patch ? h + "patch" : "prerelease";
  }, Bi;
}
var Ni, wu;
function Pd() {
  if (wu) return Ni;
  wu = 1;
  const e = Ue();
  return Ni = (i, t) => new e(i, t).major, Ni;
}
var Pi, yu;
function Od() {
  if (yu) return Pi;
  yu = 1;
  const e = Ue();
  return Pi = (i, t) => new e(i, t).minor, Pi;
}
var Oi, bu;
function Fd() {
  if (bu) return Oi;
  bu = 1;
  const e = Ue();
  return Oi = (i, t) => new e(i, t).patch, Oi;
}
var Fi, vu;
function Dd() {
  if (vu) return Fi;
  vu = 1;
  const e = er();
  return Fi = (i, t) => {
    const p = e(i, t);
    return p && p.prerelease.length ? p.prerelease : null;
  }, Fi;
}
var Di, _u;
function Ye() {
  if (_u) return Di;
  _u = 1;
  const e = Ue();
  return Di = (i, t, p) => new e(i, p).compare(new e(t, p)), Di;
}
var qi, Eu;
function qd() {
  if (Eu) return qi;
  Eu = 1;
  const e = Ye();
  return qi = (i, t, p) => e(t, i, p), qi;
}
var ji, Ru;
function jd() {
  if (Ru) return ji;
  Ru = 1;
  const e = Ye();
  return ji = (i, t) => e(i, t, !0), ji;
}
var $i, Su;
function Js() {
  if (Su) return $i;
  Su = 1;
  const e = Ue();
  return $i = (i, t, p) => {
    const n = new e(i, p), u = new e(t, p);
    return n.compare(u) || n.compareBuild(u);
  }, $i;
}
var Ui, Mu;
function $d() {
  if (Mu) return Ui;
  Mu = 1;
  const e = Js();
  return Ui = (i, t) => i.sort((p, n) => e(p, n, t)), Ui;
}
var Hi, ku;
function Ud() {
  if (ku) return Hi;
  ku = 1;
  const e = Js();
  return Hi = (i, t) => i.sort((p, n) => e(n, p, t)), Hi;
}
var Wi, Cu;
function _n() {
  if (Cu) return Wi;
  Cu = 1;
  const e = Ye();
  return Wi = (i, t, p) => e(i, t, p) > 0, Wi;
}
var Vi, Iu;
function Gs() {
  if (Iu) return Vi;
  Iu = 1;
  const e = Ye();
  return Vi = (i, t, p) => e(i, t, p) < 0, Vi;
}
var zi, xu;
function wl() {
  if (xu) return zi;
  xu = 1;
  const e = Ye();
  return zi = (i, t, p) => e(i, t, p) === 0, zi;
}
var Ji, Au;
function yl() {
  if (Au) return Ji;
  Au = 1;
  const e = Ye();
  return Ji = (i, t, p) => e(i, t, p) !== 0, Ji;
}
var Gi, Tu;
function Zs() {
  if (Tu) return Gi;
  Tu = 1;
  const e = Ye();
  return Gi = (i, t, p) => e(i, t, p) >= 0, Gi;
}
var Zi, Lu;
function Ks() {
  if (Lu) return Zi;
  Lu = 1;
  const e = Ye();
  return Zi = (i, t, p) => e(i, t, p) <= 0, Zi;
}
var Ki, Bu;
function bl() {
  if (Bu) return Ki;
  Bu = 1;
  const e = wl(), r = yl(), i = _n(), t = Zs(), p = Gs(), n = Ks();
  return Ki = (o, d, m, g) => {
    switch (d) {
      case "===":
        return typeof o == "object" && (o = o.version), typeof m == "object" && (m = m.version), o === m;
      case "!==":
        return typeof o == "object" && (o = o.version), typeof m == "object" && (m = m.version), o !== m;
      case "":
      case "=":
      case "==":
        return e(o, m, g);
      case "!=":
        return r(o, m, g);
      case ">":
        return i(o, m, g);
      case ">=":
        return t(o, m, g);
      case "<":
        return p(o, m, g);
      case "<=":
        return n(o, m, g);
      default:
        throw new TypeError(`Invalid operator: ${d}`);
    }
  }, Ki;
}
var Qi, Nu;
function Hd() {
  if (Nu) return Qi;
  Nu = 1;
  const e = Ue(), r = er(), { safeRe: i, t } = Vr();
  return Qi = (n, u) => {
    if (n instanceof e)
      return n;
    if (typeof n == "number" && (n = String(n)), typeof n != "string")
      return null;
    u = u || {};
    let o = null;
    if (!u.rtl)
      o = n.match(u.includePrerelease ? i[t.COERCEFULL] : i[t.COERCE]);
    else {
      const s = u.includePrerelease ? i[t.COERCERTLFULL] : i[t.COERCERTL];
      let f;
      for (; (f = s.exec(n)) && (!o || o.index + o[0].length !== n.length); )
        (!o || f.index + f[0].length !== o.index + o[0].length) && (o = f), s.lastIndex = f.index + f[1].length + f[2].length;
      s.lastIndex = -1;
    }
    if (o === null)
      return null;
    const d = o[2], m = o[3] || "0", g = o[4] || "0", c = u.includePrerelease && o[5] ? `-${o[5]}` : "", h = u.includePrerelease && o[6] ? `+${o[6]}` : "";
    return r(`${d}.${m}.${g}${c}${h}`, u);
  }, Qi;
}
var Yi, Pu;
function Wd() {
  if (Pu) return Yi;
  Pu = 1;
  class e {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(i) {
      const t = this.map.get(i);
      if (t !== void 0)
        return this.map.delete(i), this.map.set(i, t), t;
    }
    delete(i) {
      return this.map.delete(i);
    }
    set(i, t) {
      if (!this.delete(i) && t !== void 0) {
        if (this.map.size >= this.max) {
          const n = this.map.keys().next().value;
          this.delete(n);
        }
        this.map.set(i, t);
      }
      return this;
    }
  }
  return Yi = e, Yi;
}
var Xi, Ou;
function Xe() {
  if (Ou) return Xi;
  Ou = 1;
  const e = /\s+/g;
  class r {
    constructor(E, M) {
      if (M = p(M), E instanceof r)
        return E.loose === !!M.loose && E.includePrerelease === !!M.includePrerelease ? E : new r(E.raw, M);
      if (E instanceof n)
        return this.raw = E.value, this.set = [[E]], this.formatted = void 0, this;
      if (this.options = M, this.loose = !!M.loose, this.includePrerelease = !!M.includePrerelease, this.raw = E.trim().replace(e, " "), this.set = this.raw.split("||").map((k) => this.parseRange(k.trim())).filter((k) => k.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const k = this.set[0];
        if (this.set = this.set.filter((x) => !b(x[0])), this.set.length === 0)
          this.set = [k];
        else if (this.set.length > 1) {
          for (const x of this.set)
            if (x.length === 1 && v(x[0])) {
              this.set = [x];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let E = 0; E < this.set.length; E++) {
          E > 0 && (this.formatted += "||");
          const M = this.set[E];
          for (let k = 0; k < M.length; k++)
            k > 0 && (this.formatted += " "), this.formatted += M[k].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(E) {
      const k = ((this.options.includePrerelease && s) | (this.options.loose && f)) + ":" + E, x = t.get(k);
      if (x)
        return x;
      const B = this.options.loose, j = B ? d[m.HYPHENRANGELOOSE] : d[m.HYPHENRANGE];
      E = E.replace(j, re(this.options.includePrerelease)), u("hyphen replace", E), E = E.replace(d[m.COMPARATORTRIM], g), u("comparator trim", E), E = E.replace(d[m.TILDETRIM], c), u("tilde trim", E), E = E.replace(d[m.CARETTRIM], h), u("caret trim", E);
      let A = E.split(" ").map((K) => R(K, this.options)).join(" ").split(/\s+/).map((K) => Y(K, this.options));
      B && (A = A.filter((K) => (u("loose invalid filter", K, this.options), !!K.match(d[m.COMPARATORLOOSE])))), u("range list", A);
      const y = /* @__PURE__ */ new Map(), N = A.map((K) => new n(K, this.options));
      for (const K of N) {
        if (b(K))
          return [K];
        y.set(K.value, K);
      }
      y.size > 1 && y.has("") && y.delete("");
      const te = [...y.values()];
      return t.set(k, te), te;
    }
    intersects(E, M) {
      if (!(E instanceof r))
        throw new TypeError("a Range is required");
      return this.set.some((k) => a(k, M) && E.set.some((x) => a(x, M) && k.every((B) => x.every((j) => B.intersects(j, M)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(E) {
      if (!E)
        return !1;
      if (typeof E == "string")
        try {
          E = new o(E, this.options);
        } catch {
          return !1;
        }
      for (let M = 0; M < this.set.length; M++)
        if (F(this.set[M], E, this.options))
          return !0;
      return !1;
    }
  }
  Xi = r;
  const i = Wd(), t = new i(), p = zs(), n = En(), u = vn(), o = Ue(), {
    safeRe: d,
    t: m,
    comparatorTrimReplace: g,
    tildeTrimReplace: c,
    caretTrimReplace: h
  } = Vr(), { FLAG_INCLUDE_PRERELEASE: s, FLAG_LOOSE: f } = bn(), b = (l) => l.value === "<0.0.0-0", v = (l) => l.value === "", a = (l, E) => {
    let M = !0;
    const k = l.slice();
    let x = k.pop();
    for (; M && k.length; )
      M = k.every((B) => x.intersects(B, E)), x = k.pop();
    return M;
  }, R = (l, E) => (u("comp", l, E), l = q(l, E), u("caret", l), l = I(l, E), u("tildes", l), l = H(l, E), u("xrange", l), l = ee(l, E), u("stars", l), l), S = (l) => !l || l.toLowerCase() === "x" || l === "*", I = (l, E) => l.trim().split(/\s+/).map((M) => T(M, E)).join(" "), T = (l, E) => {
    const M = E.loose ? d[m.TILDELOOSE] : d[m.TILDE];
    return l.replace(M, (k, x, B, j, A) => {
      u("tilde", l, k, x, B, j, A);
      let y;
      return S(x) ? y = "" : S(B) ? y = `>=${x}.0.0 <${+x + 1}.0.0-0` : S(j) ? y = `>=${x}.${B}.0 <${x}.${+B + 1}.0-0` : A ? (u("replaceTilde pr", A), y = `>=${x}.${B}.${j}-${A} <${x}.${+B + 1}.0-0`) : y = `>=${x}.${B}.${j} <${x}.${+B + 1}.0-0`, u("tilde return", y), y;
    });
  }, q = (l, E) => l.trim().split(/\s+/).map((M) => D(M, E)).join(" "), D = (l, E) => {
    u("caret", l, E);
    const M = E.loose ? d[m.CARETLOOSE] : d[m.CARET], k = E.includePrerelease ? "-0" : "";
    return l.replace(M, (x, B, j, A, y) => {
      u("caret", l, x, B, j, A, y);
      let N;
      return S(B) ? N = "" : S(j) ? N = `>=${B}.0.0${k} <${+B + 1}.0.0-0` : S(A) ? B === "0" ? N = `>=${B}.${j}.0${k} <${B}.${+j + 1}.0-0` : N = `>=${B}.${j}.0${k} <${+B + 1}.0.0-0` : y ? (u("replaceCaret pr", y), B === "0" ? j === "0" ? N = `>=${B}.${j}.${A}-${y} <${B}.${j}.${+A + 1}-0` : N = `>=${B}.${j}.${A}-${y} <${B}.${+j + 1}.0-0` : N = `>=${B}.${j}.${A}-${y} <${+B + 1}.0.0-0`) : (u("no pr"), B === "0" ? j === "0" ? N = `>=${B}.${j}.${A}${k} <${B}.${j}.${+A + 1}-0` : N = `>=${B}.${j}.${A}${k} <${B}.${+j + 1}.0-0` : N = `>=${B}.${j}.${A} <${+B + 1}.0.0-0`), u("caret return", N), N;
    });
  }, H = (l, E) => (u("replaceXRanges", l, E), l.split(/\s+/).map((M) => G(M, E)).join(" ")), G = (l, E) => {
    l = l.trim();
    const M = E.loose ? d[m.XRANGELOOSE] : d[m.XRANGE];
    return l.replace(M, (k, x, B, j, A, y) => {
      u("xRange", l, k, x, B, j, A, y);
      const N = S(B), te = N || S(j), K = te || S(A), $ = K;
      return x === "=" && $ && (x = ""), y = E.includePrerelease ? "-0" : "", N ? x === ">" || x === "<" ? k = "<0.0.0-0" : k = "*" : x && $ ? (te && (j = 0), A = 0, x === ">" ? (x = ">=", te ? (B = +B + 1, j = 0, A = 0) : (j = +j + 1, A = 0)) : x === "<=" && (x = "<", te ? B = +B + 1 : j = +j + 1), x === "<" && (y = "-0"), k = `${x + B}.${j}.${A}${y}`) : te ? k = `>=${B}.0.0${y} <${+B + 1}.0.0-0` : K && (k = `>=${B}.${j}.0${y} <${B}.${+j + 1}.0-0`), u("xRange return", k), k;
    });
  }, ee = (l, E) => (u("replaceStars", l, E), l.trim().replace(d[m.STAR], "")), Y = (l, E) => (u("replaceGTE0", l, E), l.trim().replace(d[E.includePrerelease ? m.GTE0PRE : m.GTE0], "")), re = (l) => (E, M, k, x, B, j, A, y, N, te, K, $) => (S(k) ? M = "" : S(x) ? M = `>=${k}.0.0${l ? "-0" : ""}` : S(B) ? M = `>=${k}.${x}.0${l ? "-0" : ""}` : j ? M = `>=${M}` : M = `>=${M}${l ? "-0" : ""}`, S(N) ? y = "" : S(te) ? y = `<${+N + 1}.0.0-0` : S(K) ? y = `<${N}.${+te + 1}.0-0` : $ ? y = `<=${N}.${te}.${K}-${$}` : l ? y = `<${N}.${te}.${+K + 1}-0` : y = `<=${y}`, `${M} ${y}`.trim()), F = (l, E, M) => {
    for (let k = 0; k < l.length; k++)
      if (!l[k].test(E))
        return !1;
    if (E.prerelease.length && !M.includePrerelease) {
      for (let k = 0; k < l.length; k++)
        if (u(l[k].semver), l[k].semver !== n.ANY && l[k].semver.prerelease.length > 0) {
          const x = l[k].semver;
          if (x.major === E.major && x.minor === E.minor && x.patch === E.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Xi;
}
var es, Fu;
function En() {
  if (Fu) return es;
  Fu = 1;
  const e = Symbol("SemVer ANY");
  class r {
    static get ANY() {
      return e;
    }
    constructor(g, c) {
      if (c = i(c), g instanceof r) {
        if (g.loose === !!c.loose)
          return g;
        g = g.value;
      }
      g = g.trim().split(/\s+/).join(" "), u("comparator", g, c), this.options = c, this.loose = !!c.loose, this.parse(g), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, u("comp", this);
    }
    parse(g) {
      const c = this.options.loose ? t[p.COMPARATORLOOSE] : t[p.COMPARATOR], h = g.match(c);
      if (!h)
        throw new TypeError(`Invalid comparator: ${g}`);
      this.operator = h[1] !== void 0 ? h[1] : "", this.operator === "=" && (this.operator = ""), h[2] ? this.semver = new o(h[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(g) {
      if (u("Comparator.test", g, this.options.loose), this.semver === e || g === e)
        return !0;
      if (typeof g == "string")
        try {
          g = new o(g, this.options);
        } catch {
          return !1;
        }
      return n(g, this.operator, this.semver, this.options);
    }
    intersects(g, c) {
      if (!(g instanceof r))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new d(g.value, c).test(this.value) : g.operator === "" ? g.value === "" ? !0 : new d(this.value, c).test(g.semver) : (c = i(c), c.includePrerelease && (this.value === "<0.0.0-0" || g.value === "<0.0.0-0") || !c.includePrerelease && (this.value.startsWith("<0.0.0") || g.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && g.operator.startsWith(">") || this.operator.startsWith("<") && g.operator.startsWith("<") || this.semver.version === g.semver.version && this.operator.includes("=") && g.operator.includes("=") || n(this.semver, "<", g.semver, c) && this.operator.startsWith(">") && g.operator.startsWith("<") || n(this.semver, ">", g.semver, c) && this.operator.startsWith("<") && g.operator.startsWith(">")));
    }
  }
  es = r;
  const i = zs(), { safeRe: t, t: p } = Vr(), n = bl(), u = vn(), o = Ue(), d = Xe();
  return es;
}
var ts, Du;
function Rn() {
  if (Du) return ts;
  Du = 1;
  const e = Xe();
  return ts = (i, t, p) => {
    try {
      t = new e(t, p);
    } catch {
      return !1;
    }
    return t.test(i);
  }, ts;
}
var rs, qu;
function Vd() {
  if (qu) return rs;
  qu = 1;
  const e = Xe();
  return rs = (i, t) => new e(i, t).set.map((p) => p.map((n) => n.value).join(" ").trim().split(" ")), rs;
}
var ns, ju;
function zd() {
  if (ju) return ns;
  ju = 1;
  const e = Ue(), r = Xe();
  return ns = (t, p, n) => {
    let u = null, o = null, d = null;
    try {
      d = new r(p, n);
    } catch {
      return null;
    }
    return t.forEach((m) => {
      d.test(m) && (!u || o.compare(m) === -1) && (u = m, o = new e(u, n));
    }), u;
  }, ns;
}
var is, $u;
function Jd() {
  if ($u) return is;
  $u = 1;
  const e = Ue(), r = Xe();
  return is = (t, p, n) => {
    let u = null, o = null, d = null;
    try {
      d = new r(p, n);
    } catch {
      return null;
    }
    return t.forEach((m) => {
      d.test(m) && (!u || o.compare(m) === 1) && (u = m, o = new e(u, n));
    }), u;
  }, is;
}
var ss, Uu;
function Gd() {
  if (Uu) return ss;
  Uu = 1;
  const e = Ue(), r = Xe(), i = _n();
  return ss = (p, n) => {
    p = new r(p, n);
    let u = new e("0.0.0");
    if (p.test(u) || (u = new e("0.0.0-0"), p.test(u)))
      return u;
    u = null;
    for (let o = 0; o < p.set.length; ++o) {
      const d = p.set[o];
      let m = null;
      d.forEach((g) => {
        const c = new e(g.semver.version);
        switch (g.operator) {
          case ">":
            c.prerelease.length === 0 ? c.patch++ : c.prerelease.push(0), c.raw = c.format();
          /* fallthrough */
          case "":
          case ">=":
            (!m || i(c, m)) && (m = c);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${g.operator}`);
        }
      }), m && (!u || i(u, m)) && (u = m);
    }
    return u && p.test(u) ? u : null;
  }, ss;
}
var os, Hu;
function Zd() {
  if (Hu) return os;
  Hu = 1;
  const e = Xe();
  return os = (i, t) => {
    try {
      return new e(i, t).range || "*";
    } catch {
      return null;
    }
  }, os;
}
var as, Wu;
function Qs() {
  if (Wu) return as;
  Wu = 1;
  const e = Ue(), r = En(), { ANY: i } = r, t = Xe(), p = Rn(), n = _n(), u = Gs(), o = Ks(), d = Zs();
  return as = (g, c, h, s) => {
    g = new e(g, s), c = new t(c, s);
    let f, b, v, a, R;
    switch (h) {
      case ">":
        f = n, b = o, v = u, a = ">", R = ">=";
        break;
      case "<":
        f = u, b = d, v = n, a = "<", R = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (p(g, c, s))
      return !1;
    for (let S = 0; S < c.set.length; ++S) {
      const I = c.set[S];
      let T = null, q = null;
      if (I.forEach((D) => {
        D.semver === i && (D = new r(">=0.0.0")), T = T || D, q = q || D, f(D.semver, T.semver, s) ? T = D : v(D.semver, q.semver, s) && (q = D);
      }), T.operator === a || T.operator === R || (!q.operator || q.operator === a) && b(g, q.semver))
        return !1;
      if (q.operator === R && v(g, q.semver))
        return !1;
    }
    return !0;
  }, as;
}
var us, Vu;
function Kd() {
  if (Vu) return us;
  Vu = 1;
  const e = Qs();
  return us = (i, t, p) => e(i, t, ">", p), us;
}
var cs, zu;
function Qd() {
  if (zu) return cs;
  zu = 1;
  const e = Qs();
  return cs = (i, t, p) => e(i, t, "<", p), cs;
}
var ls, Ju;
function Yd() {
  if (Ju) return ls;
  Ju = 1;
  const e = Xe();
  return ls = (i, t, p) => (i = new e(i, p), t = new e(t, p), i.intersects(t, p)), ls;
}
var hs, Gu;
function Xd() {
  if (Gu) return hs;
  Gu = 1;
  const e = Rn(), r = Ye();
  return hs = (i, t, p) => {
    const n = [];
    let u = null, o = null;
    const d = i.sort((h, s) => r(h, s, p));
    for (const h of d)
      e(h, t, p) ? (o = h, u || (u = h)) : (o && n.push([u, o]), o = null, u = null);
    u && n.push([u, null]);
    const m = [];
    for (const [h, s] of n)
      h === s ? m.push(h) : !s && h === d[0] ? m.push("*") : s ? h === d[0] ? m.push(`<=${s}`) : m.push(`${h} - ${s}`) : m.push(`>=${h}`);
    const g = m.join(" || "), c = typeof t.raw == "string" ? t.raw : String(t);
    return g.length < c.length ? g : t;
  }, hs;
}
var ds, Zu;
function ef() {
  if (Zu) return ds;
  Zu = 1;
  const e = Xe(), r = En(), { ANY: i } = r, t = Rn(), p = Ye(), n = (c, h, s = {}) => {
    if (c === h)
      return !0;
    c = new e(c, s), h = new e(h, s);
    let f = !1;
    e: for (const b of c.set) {
      for (const v of h.set) {
        const a = d(b, v, s);
        if (f = f || a !== null, a)
          continue e;
      }
      if (f)
        return !1;
    }
    return !0;
  }, u = [new r(">=0.0.0-0")], o = [new r(">=0.0.0")], d = (c, h, s) => {
    if (c === h)
      return !0;
    if (c.length === 1 && c[0].semver === i) {
      if (h.length === 1 && h[0].semver === i)
        return !0;
      s.includePrerelease ? c = u : c = o;
    }
    if (h.length === 1 && h[0].semver === i) {
      if (s.includePrerelease)
        return !0;
      h = o;
    }
    const f = /* @__PURE__ */ new Set();
    let b, v;
    for (const H of c)
      H.operator === ">" || H.operator === ">=" ? b = m(b, H, s) : H.operator === "<" || H.operator === "<=" ? v = g(v, H, s) : f.add(H.semver);
    if (f.size > 1)
      return null;
    let a;
    if (b && v) {
      if (a = p(b.semver, v.semver, s), a > 0)
        return null;
      if (a === 0 && (b.operator !== ">=" || v.operator !== "<="))
        return null;
    }
    for (const H of f) {
      if (b && !t(H, String(b), s) || v && !t(H, String(v), s))
        return null;
      for (const G of h)
        if (!t(H, String(G), s))
          return !1;
      return !0;
    }
    let R, S, I, T, q = v && !s.includePrerelease && v.semver.prerelease.length ? v.semver : !1, D = b && !s.includePrerelease && b.semver.prerelease.length ? b.semver : !1;
    q && q.prerelease.length === 1 && v.operator === "<" && q.prerelease[0] === 0 && (q = !1);
    for (const H of h) {
      if (T = T || H.operator === ">" || H.operator === ">=", I = I || H.operator === "<" || H.operator === "<=", b) {
        if (D && H.semver.prerelease && H.semver.prerelease.length && H.semver.major === D.major && H.semver.minor === D.minor && H.semver.patch === D.patch && (D = !1), H.operator === ">" || H.operator === ">=") {
          if (R = m(b, H, s), R === H && R !== b)
            return !1;
        } else if (b.operator === ">=" && !t(b.semver, String(H), s))
          return !1;
      }
      if (v) {
        if (q && H.semver.prerelease && H.semver.prerelease.length && H.semver.major === q.major && H.semver.minor === q.minor && H.semver.patch === q.patch && (q = !1), H.operator === "<" || H.operator === "<=") {
          if (S = g(v, H, s), S === H && S !== v)
            return !1;
        } else if (v.operator === "<=" && !t(v.semver, String(H), s))
          return !1;
      }
      if (!H.operator && (v || b) && a !== 0)
        return !1;
    }
    return !(b && I && !v && a !== 0 || v && T && !b && a !== 0 || D || q);
  }, m = (c, h, s) => {
    if (!c)
      return h;
    const f = p(c.semver, h.semver, s);
    return f > 0 ? c : f < 0 || h.operator === ">" && c.operator === ">=" ? h : c;
  }, g = (c, h, s) => {
    if (!c)
      return h;
    const f = p(c.semver, h.semver, s);
    return f < 0 ? c : f > 0 || h.operator === "<" && c.operator === "<=" ? h : c;
  };
  return ds = n, ds;
}
var fs, Ku;
function tf() {
  if (Ku) return fs;
  Ku = 1;
  const e = Vr(), r = bn(), i = Ue(), t = ml(), p = er(), n = Td(), u = Ld(), o = Bd(), d = Nd(), m = Pd(), g = Od(), c = Fd(), h = Dd(), s = Ye(), f = qd(), b = jd(), v = Js(), a = $d(), R = Ud(), S = _n(), I = Gs(), T = wl(), q = yl(), D = Zs(), H = Ks(), G = bl(), ee = Hd(), Y = En(), re = Xe(), F = Rn(), l = Vd(), E = zd(), M = Jd(), k = Gd(), x = Zd(), B = Qs(), j = Kd(), A = Qd(), y = Yd(), N = Xd(), te = ef();
  return fs = {
    parse: p,
    valid: n,
    clean: u,
    inc: o,
    diff: d,
    major: m,
    minor: g,
    patch: c,
    prerelease: h,
    compare: s,
    rcompare: f,
    compareLoose: b,
    compareBuild: v,
    sort: a,
    rsort: R,
    gt: S,
    lt: I,
    eq: T,
    neq: q,
    gte: D,
    lte: H,
    cmp: G,
    coerce: ee,
    Comparator: Y,
    Range: re,
    satisfies: F,
    toComparators: l,
    maxSatisfying: E,
    minSatisfying: M,
    minVersion: k,
    validRange: x,
    outside: B,
    gtr: j,
    ltr: A,
    intersects: y,
    simplifyRange: N,
    subset: te,
    SemVer: i,
    re: e.re,
    src: e.src,
    tokens: e.t,
    SEMVER_SPEC_VERSION: r.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: r.RELEASE_TYPES,
    compareIdentifiers: t.compareIdentifiers,
    rcompareIdentifiers: t.rcompareIdentifiers
  }, fs;
}
var Qu;
function rf() {
  return Qu || (Qu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
    const r = tf(), i = xt, t = ot();
    e.VersionStruct = (0, i.refine)((0, i.string)(), "Version", (c) => (0, r.valid)(c) === null ? `Expected SemVer version, got "${c}"` : !0), e.VersionRangeStruct = (0, i.refine)((0, i.string)(), "Version range", (c) => (0, r.validRange)(c) === null ? `Expected SemVer range, got "${c}"` : !0);
    function p(c) {
      return (0, i.is)(c, e.VersionStruct);
    }
    e.isValidSemVerVersion = p;
    function n(c) {
      return (0, i.is)(c, e.VersionRangeStruct);
    }
    e.isValidSemVerRange = n;
    function u(c) {
      (0, t.assertStruct)(c, e.VersionStruct);
    }
    e.assertIsSemVerVersion = u;
    function o(c) {
      (0, t.assertStruct)(c, e.VersionRangeStruct);
    }
    e.assertIsSemVerRange = o;
    function d(c, h) {
      return (0, r.gt)(c, h);
    }
    e.gtVersion = d;
    function m(c, h) {
      return (0, r.gtr)(c, h);
    }
    e.gtRange = m;
    function g(c, h) {
      return (0, r.satisfies)(c, h, {
        includePrerelease: !0
      });
    }
    e.satisfiesVersionRange = g;
  }(Ri)), Ri;
}
var Yu;
function nf() {
  return Yu || (Yu = 1, function(e) {
    var r = xr.__createBinding || (Object.create ? function(t, p, n, u) {
      u === void 0 && (u = n);
      var o = Object.getOwnPropertyDescriptor(p, n);
      (!o || ("get" in o ? !p.__esModule : o.writable || o.configurable)) && (o = { enumerable: !0, get: function() {
        return p[n];
      } }), Object.defineProperty(t, u, o);
    } : function(t, p, n, u) {
      u === void 0 && (u = n), t[u] = p[n];
    }), i = xr.__exportStar || function(t, p) {
      for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(p, n) && r(p, t, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), i(ot(), e), i(pl(), e), i(gl(), e), i(bd(), e), i(vd(), e), i(_d(), e), i(Ed(), e), i(yn(), e), i(Rd(), e), i(Sd(), e), i(Md(), e), i(kd(), e), i(Cd(), e), i(Id(), e), i(xd(), e), i(Ad(), e), i(rf(), e);
  }(xr)), xr;
}
var Xu;
function sf() {
  return Xu || (Xu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
    const r = nf();
    Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
      return r.createModuleLogger;
    } }), e.projectLogger = (0, r.createProjectLogger)("eth-block-tracker");
  }(pi)), pi;
}
var ec;
function of() {
  if (ec) return Vt;
  ec = 1;
  var e = Vt.__importDefault || function(g) {
    return g && g.__esModule ? g : { default: g };
  };
  Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.PollingBlockTracker = void 0;
  const r = e(js()), i = e(Bh()), t = sl(), p = sf(), n = (0, p.createModuleLogger)(p.projectLogger, "polling-block-tracker"), u = (0, r.default)(), o = 1e3;
  let d = class extends t.BaseBlockTracker {
    constructor(c = {}) {
      var h;
      if (!c.provider)
        throw new Error("PollingBlockTracker - no provider specified.");
      super(Object.assign(Object.assign({}, c), { blockResetDuration: (h = c.blockResetDuration) !== null && h !== void 0 ? h : c.pollingInterval })), this._provider = c.provider, this._pollingInterval = c.pollingInterval || 20 * o, this._retryTimeout = c.retryTimeout || this._pollingInterval / 10, this._keepEventLoopActive = c.keepEventLoopActive === void 0 ? !0 : c.keepEventLoopActive, this._setSkipCacheFlag = c.setSkipCacheFlag || !1;
    }
    // trigger block polling
    async checkForLatestBlock() {
      return await this._updateLatestBlock(), await this.getLatestBlock();
    }
    async _start() {
      this._synchronize();
    }
    async _end() {
    }
    async _synchronize() {
      for (var c; this._isRunning; )
        try {
          await this._updateLatestBlock();
          const h = m(this._pollingInterval, !this._keepEventLoopActive);
          this.emit("_waitingForNextIteration"), await h;
        } catch (h) {
          const s = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(c = h.stack) !== null && c !== void 0 ? c : h}`);
          try {
            this.emit("error", s);
          } catch {
            console.error(s);
          }
          const f = m(this._retryTimeout, !this._keepEventLoopActive);
          this.emit("_waitingForNextIteration"), await f;
        }
    }
    async _updateLatestBlock() {
      const c = await this._fetchLatestBlock();
      this._newPotentialLatest(c);
    }
    async _fetchLatestBlock() {
      const c = {
        jsonrpc: "2.0",
        id: u(),
        method: "eth_blockNumber",
        params: []
      };
      this._setSkipCacheFlag && (c.skipCache = !0), n("Making request", c);
      const h = await (0, i.default)((s) => this._provider.sendAsync(c, s))();
      if (n("Got response", h), h.error)
        throw new Error(`PollingBlockTracker - encountered error fetching block:
${h.error.message}`);
      return h.result;
    }
  };
  Vt.PollingBlockTracker = d;
  function m(g, c) {
    return new Promise((h) => {
      const s = setTimeout(h, g);
      s.unref && c && s.unref();
    });
  }
  return Vt;
}
var Jt = {}, tc;
function af() {
  if (tc) return Jt;
  tc = 1;
  var e = Jt.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.SubscribeBlockTracker = void 0;
  const r = e(js()), i = sl(), t = (0, r.default)();
  let p = class extends i.BaseBlockTracker {
    constructor(u = {}) {
      if (!u.provider)
        throw new Error("SubscribeBlockTracker - no provider specified.");
      super(u), this._provider = u.provider, this._subscriptionId = null;
    }
    async checkForLatestBlock() {
      return await this.getLatestBlock();
    }
    async _start() {
      if (this._subscriptionId === void 0 || this._subscriptionId === null)
        try {
          const u = await this._call("eth_blockNumber");
          this._subscriptionId = await this._call("eth_subscribe", "newHeads"), this._provider.on("data", this._handleSubData.bind(this)), this._newPotentialLatest(u);
        } catch (u) {
          this.emit("error", u);
        }
    }
    async _end() {
      if (this._subscriptionId !== null && this._subscriptionId !== void 0)
        try {
          await this._call("eth_unsubscribe", this._subscriptionId), this._subscriptionId = null;
        } catch (u) {
          this.emit("error", u);
        }
    }
    _call(u, ...o) {
      return new Promise((d, m) => {
        this._provider.sendAsync({
          id: t(),
          method: u,
          params: o,
          jsonrpc: "2.0"
        }, (g, c) => {
          g ? m(g) : d(c.result);
        });
      });
    }
    _handleSubData(u, o) {
      var d;
      o.method === "eth_subscription" && ((d = o.params) === null || d === void 0 ? void 0 : d.subscription) === this._subscriptionId && this._newPotentialLatest(o.params.result.number);
    }
  };
  return Jt.SubscribeBlockTracker = p, Jt;
}
var rc;
function uf() {
  return rc || (rc = 1, function(e) {
    var r = Ir.__createBinding || (Object.create ? function(t, p, n, u) {
      u === void 0 && (u = n), Object.defineProperty(t, u, { enumerable: !0, get: function() {
        return p[n];
      } });
    } : function(t, p, n, u) {
      u === void 0 && (u = n), t[u] = p[n];
    }), i = Ir.__exportStar || function(t, p) {
      for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(p, n) && r(p, t, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), i(of(), e), i(af(), e);
  }(Ir)), Ir;
}
var Lr = {}, Br = {}, Nr = {}, nc;
function vl() {
  if (nc) return Nr;
  nc = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.getUniqueId = void 0;
  const e = 4294967295;
  let r = Math.floor(Math.random() * e);
  function i() {
    return r = (r + 1) % e, r;
  }
  return Nr.getUniqueId = i, Nr;
}
var ic;
function cf() {
  if (ic) return Br;
  ic = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.createIdRemapMiddleware = void 0;
  const e = vl();
  function r() {
    return (i, t, p, n) => {
      const u = i.id, o = e.getUniqueId();
      i.id = o, t.id = o, p((d) => {
        i.id = u, t.id = u, d();
      });
    };
  }
  return Br.createIdRemapMiddleware = r, Br;
}
var Pr = {}, sc;
function lf() {
  if (sc) return Pr;
  sc = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.createAsyncMiddleware = void 0;
  function e(r) {
    return async (i, t, p, n) => {
      let u;
      const o = new Promise((c) => {
        u = c;
      });
      let d = null, m = !1;
      const g = async () => {
        m = !0, p((c) => {
          d = c, u();
        }), await o;
      };
      try {
        await r(i, t, g), m ? (await o, d(null)) : n(null);
      } catch (c) {
        d ? d(c) : n(c);
      }
    };
  }
  return Pr.createAsyncMiddleware = e, Pr;
}
var Or = {}, oc;
function hf() {
  if (oc) return Or;
  oc = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.createScaffoldMiddleware = void 0;
  function e(r) {
    return (i, t, p, n) => {
      const u = r[i.method];
      return u === void 0 ? p() : typeof u == "function" ? u(i, t, p, n) : (t.result = u, n());
    };
  }
  return Or.createScaffoldMiddleware = e, Or;
}
var Gt = {}, an = {}, ac;
function df() {
  if (ac) return an;
  ac = 1, Object.defineProperty(an, "__esModule", { value: !0 });
  const e = hn();
  function r(p, n, u) {
    try {
      Reflect.apply(p, n, u);
    } catch (o) {
      setTimeout(() => {
        throw o;
      });
    }
  }
  function i(p) {
    const n = p.length, u = new Array(n);
    for (let o = 0; o < n; o += 1)
      u[o] = p[o];
    return u;
  }
  class t extends e.EventEmitter {
    emit(n, ...u) {
      let o = n === "error";
      const d = this._events;
      if (d !== void 0)
        o = o && d.error === void 0;
      else if (!o)
        return !1;
      if (o) {
        let g;
        if (u.length > 0 && ([g] = u), g instanceof Error)
          throw g;
        const c = new Error(`Unhandled error.${g ? ` (${g.message})` : ""}`);
        throw c.context = g, c;
      }
      const m = d[n];
      if (m === void 0)
        return !1;
      if (typeof m == "function")
        r(m, this, u);
      else {
        const g = m.length, c = i(m);
        for (let h = 0; h < g; h += 1)
          r(c[h], this, u);
      }
      return !0;
    }
  }
  return an.default = t, an;
}
var ps = {}, Mt = {}, gs, uc;
function ff() {
  if (uc) return gs;
  uc = 1, gs = n, n.default = n, n.stable = m, n.stableStringify = m;
  var e = "[...]", r = "[Circular]", i = [], t = [];
  function p() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function n(h, s, f, b) {
    typeof b > "u" && (b = p()), o(h, "", 0, [], void 0, 0, b);
    var v;
    try {
      t.length === 0 ? v = JSON.stringify(h, s, f) : v = JSON.stringify(h, c(s), f);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; i.length !== 0; ) {
        var a = i.pop();
        a.length === 4 ? Object.defineProperty(a[0], a[1], a[3]) : a[0][a[1]] = a[2];
      }
    }
    return v;
  }
  function u(h, s, f, b) {
    var v = Object.getOwnPropertyDescriptor(b, f);
    v.get !== void 0 ? v.configurable ? (Object.defineProperty(b, f, { value: h }), i.push([b, f, s, v])) : t.push([s, f, h]) : (b[f] = h, i.push([b, f, s]));
  }
  function o(h, s, f, b, v, a, R) {
    a += 1;
    var S;
    if (typeof h == "object" && h !== null) {
      for (S = 0; S < b.length; S++)
        if (b[S] === h) {
          u(r, h, s, v);
          return;
        }
      if (typeof R.depthLimit < "u" && a > R.depthLimit) {
        u(e, h, s, v);
        return;
      }
      if (typeof R.edgesLimit < "u" && f + 1 > R.edgesLimit) {
        u(e, h, s, v);
        return;
      }
      if (b.push(h), Array.isArray(h))
        for (S = 0; S < h.length; S++)
          o(h[S], S, S, b, h, a, R);
      else {
        var I = Object.keys(h);
        for (S = 0; S < I.length; S++) {
          var T = I[S];
          o(h[T], T, S, b, h, a, R);
        }
      }
      b.pop();
    }
  }
  function d(h, s) {
    return h < s ? -1 : h > s ? 1 : 0;
  }
  function m(h, s, f, b) {
    typeof b > "u" && (b = p());
    var v = g(h, "", 0, [], void 0, 0, b) || h, a;
    try {
      t.length === 0 ? a = JSON.stringify(v, s, f) : a = JSON.stringify(v, c(s), f);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; i.length !== 0; ) {
        var R = i.pop();
        R.length === 4 ? Object.defineProperty(R[0], R[1], R[3]) : R[0][R[1]] = R[2];
      }
    }
    return a;
  }
  function g(h, s, f, b, v, a, R) {
    a += 1;
    var S;
    if (typeof h == "object" && h !== null) {
      for (S = 0; S < b.length; S++)
        if (b[S] === h) {
          u(r, h, s, v);
          return;
        }
      try {
        if (typeof h.toJSON == "function")
          return;
      } catch {
        return;
      }
      if (typeof R.depthLimit < "u" && a > R.depthLimit) {
        u(e, h, s, v);
        return;
      }
      if (typeof R.edgesLimit < "u" && f + 1 > R.edgesLimit) {
        u(e, h, s, v);
        return;
      }
      if (b.push(h), Array.isArray(h))
        for (S = 0; S < h.length; S++)
          g(h[S], S, S, b, h, a, R);
      else {
        var I = {}, T = Object.keys(h).sort(d);
        for (S = 0; S < T.length; S++) {
          var q = T[S];
          g(h[q], q, S, b, h, a, R), I[q] = h[q];
        }
        if (typeof v < "u")
          i.push([v, s, h]), v[s] = I;
        else
          return I;
      }
      b.pop();
    }
  }
  function c(h) {
    return h = typeof h < "u" ? h : function(s, f) {
      return f;
    }, function(s, f) {
      if (t.length > 0)
        for (var b = 0; b < t.length; b++) {
          var v = t[b];
          if (v[1] === s && v[0] === f) {
            f = v[2], t.splice(b, 1);
            break;
          }
        }
      return h.call(this, s, f);
    };
  }
  return gs;
}
var cc;
function Ys() {
  if (cc) return Mt;
  cc = 1, Object.defineProperty(Mt, "__esModule", { value: !0 }), Mt.EthereumProviderError = Mt.EthereumRpcError = void 0;
  const e = ff();
  class r extends Error {
    constructor(u, o, d) {
      if (!Number.isInteger(u))
        throw new Error('"code" must be an integer.');
      if (!o || typeof o != "string")
        throw new Error('"message" must be a nonempty string.');
      super(o), this.code = u, d !== void 0 && (this.data = d);
    }
    /**
     * Returns a plain object with all public class properties.
     */
    serialize() {
      const u = {
        code: this.code,
        message: this.message
      };
      return this.data !== void 0 && (u.data = this.data), this.stack && (u.stack = this.stack), u;
    }
    /**
     * Return a string representation of the serialized error, omitting
     * any circular references.
     */
    toString() {
      return e.default(this.serialize(), p, 2);
    }
  }
  Mt.EthereumRpcError = r;
  class i extends r {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     * `code` must be an integer in the 1000 <= 4999 range.
     */
    constructor(u, o, d) {
      if (!t(u))
        throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
      super(u, o, d);
    }
  }
  Mt.EthereumProviderError = i;
  function t(n) {
    return Number.isInteger(n) && n >= 1e3 && n <= 4999;
  }
  function p(n, u) {
    if (u !== "[Circular]")
      return u;
  }
  return Mt;
}
var ms = {}, kt = {}, lc;
function Xs() {
  return lc || (lc = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.errorValues = kt.errorCodes = void 0, kt.errorCodes = {
    rpc: {
      invalidInput: -32e3,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603
    },
    provider: {
      userRejectedRequest: 4001,
      unauthorized: 4100,
      unsupportedMethod: 4200,
      disconnected: 4900,
      chainDisconnected: 4901
    }
  }, kt.errorValues = {
    "-32700": {
      standard: "JSON RPC 2.0",
      message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
      standard: "JSON RPC 2.0",
      message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
      standard: "JSON RPC 2.0",
      message: "The method does not exist / is not available."
    },
    "-32602": {
      standard: "JSON RPC 2.0",
      message: "Invalid method parameter(s)."
    },
    "-32603": {
      standard: "JSON RPC 2.0",
      message: "Internal JSON-RPC error."
    },
    "-32000": {
      standard: "EIP-1474",
      message: "Invalid input."
    },
    "-32001": {
      standard: "EIP-1474",
      message: "Resource not found."
    },
    "-32002": {
      standard: "EIP-1474",
      message: "Resource unavailable."
    },
    "-32003": {
      standard: "EIP-1474",
      message: "Transaction rejected."
    },
    "-32004": {
      standard: "EIP-1474",
      message: "Method not supported."
    },
    "-32005": {
      standard: "EIP-1474",
      message: "Request limit exceeded."
    },
    4001: {
      standard: "EIP-1193",
      message: "User rejected the request."
    },
    4100: {
      standard: "EIP-1193",
      message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
      standard: "EIP-1193",
      message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
      standard: "EIP-1193",
      message: "The provider is disconnected from all chains."
    },
    4901: {
      standard: "EIP-1193",
      message: "The provider is disconnected from the specified chain."
    }
  }), kt;
}
var hc;
function _l() {
  return hc || (hc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const r = Xs(), i = Ys(), t = r.errorCodes.rpc.internal, p = "Unspecified error message. This is a bug, please report it.", n = {
      code: t,
      message: u(t)
    };
    e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function u(h, s = p) {
      if (Number.isInteger(h)) {
        const f = h.toString();
        if (c(r.errorValues, f))
          return r.errorValues[f].message;
        if (m(h))
          return e.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
      return s;
    }
    e.getMessageFromCode = u;
    function o(h) {
      if (!Number.isInteger(h))
        return !1;
      const s = h.toString();
      return !!(r.errorValues[s] || m(h));
    }
    e.isValidCode = o;
    function d(h, { fallbackError: s = n, shouldIncludeStack: f = !1 } = {}) {
      var b, v;
      if (!s || !Number.isInteger(s.code) || typeof s.message != "string")
        throw new Error("Must provide fallback error with integer number code and string message.");
      if (h instanceof i.EthereumRpcError)
        return h.serialize();
      const a = {};
      if (h && typeof h == "object" && !Array.isArray(h) && c(h, "code") && o(h.code)) {
        const S = h;
        a.code = S.code, S.message && typeof S.message == "string" ? (a.message = S.message, c(S, "data") && (a.data = S.data)) : (a.message = u(a.code), a.data = { originalError: g(h) });
      } else {
        a.code = s.code;
        const S = (b = h) === null || b === void 0 ? void 0 : b.message;
        a.message = S && typeof S == "string" ? S : s.message, a.data = { originalError: g(h) };
      }
      const R = (v = h) === null || v === void 0 ? void 0 : v.stack;
      return f && h && R && typeof R == "string" && (a.stack = R), a;
    }
    e.serializeError = d;
    function m(h) {
      return h >= -32099 && h <= -32e3;
    }
    function g(h) {
      return h && typeof h == "object" && !Array.isArray(h) ? Object.assign({}, h) : h;
    }
    function c(h, s) {
      return Object.prototype.hasOwnProperty.call(h, s);
    }
  }(ms)), ms;
}
var Fr = {}, dc;
function pf() {
  if (dc) return Fr;
  dc = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.ethErrors = void 0;
  const e = Ys(), r = _l(), i = Xs();
  Fr.ethErrors = {
    rpc: {
      /**
       * Get a JSON RPC 2.0 Parse (-32700) error.
       */
      parse: (u) => t(i.errorCodes.rpc.parse, u),
      /**
       * Get a JSON RPC 2.0 Invalid Request (-32600) error.
       */
      invalidRequest: (u) => t(i.errorCodes.rpc.invalidRequest, u),
      /**
       * Get a JSON RPC 2.0 Invalid Params (-32602) error.
       */
      invalidParams: (u) => t(i.errorCodes.rpc.invalidParams, u),
      /**
       * Get a JSON RPC 2.0 Method Not Found (-32601) error.
       */
      methodNotFound: (u) => t(i.errorCodes.rpc.methodNotFound, u),
      /**
       * Get a JSON RPC 2.0 Internal (-32603) error.
       */
      internal: (u) => t(i.errorCodes.rpc.internal, u),
      /**
       * Get a JSON RPC 2.0 Server error.
       * Permits integer error codes in the [ -32099 <= -32005 ] range.
       * Codes -32000 through -32004 are reserved by EIP-1474.
       */
      server: (u) => {
        if (!u || typeof u != "object" || Array.isArray(u))
          throw new Error("Ethereum RPC Server errors must provide single object argument.");
        const { code: o } = u;
        if (!Number.isInteger(o) || o > -32005 || o < -32099)
          throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        return t(o, u);
      },
      /**
       * Get an Ethereum JSON RPC Invalid Input (-32000) error.
       */
      invalidInput: (u) => t(i.errorCodes.rpc.invalidInput, u),
      /**
       * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
       */
      resourceNotFound: (u) => t(i.errorCodes.rpc.resourceNotFound, u),
      /**
       * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
       */
      resourceUnavailable: (u) => t(i.errorCodes.rpc.resourceUnavailable, u),
      /**
       * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
       */
      transactionRejected: (u) => t(i.errorCodes.rpc.transactionRejected, u),
      /**
       * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
       */
      methodNotSupported: (u) => t(i.errorCodes.rpc.methodNotSupported, u),
      /**
       * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
       */
      limitExceeded: (u) => t(i.errorCodes.rpc.limitExceeded, u)
    },
    provider: {
      /**
       * Get an Ethereum Provider User Rejected Request (4001) error.
       */
      userRejectedRequest: (u) => p(i.errorCodes.provider.userRejectedRequest, u),
      /**
       * Get an Ethereum Provider Unauthorized (4100) error.
       */
      unauthorized: (u) => p(i.errorCodes.provider.unauthorized, u),
      /**
       * Get an Ethereum Provider Unsupported Method (4200) error.
       */
      unsupportedMethod: (u) => p(i.errorCodes.provider.unsupportedMethod, u),
      /**
       * Get an Ethereum Provider Not Connected (4900) error.
       */
      disconnected: (u) => p(i.errorCodes.provider.disconnected, u),
      /**
       * Get an Ethereum Provider Chain Not Connected (4901) error.
       */
      chainDisconnected: (u) => p(i.errorCodes.provider.chainDisconnected, u),
      /**
       * Get a custom Ethereum Provider error.
       */
      custom: (u) => {
        if (!u || typeof u != "object" || Array.isArray(u))
          throw new Error("Ethereum Provider custom errors must provide single object argument.");
        const { code: o, message: d, data: m } = u;
        if (!d || typeof d != "string")
          throw new Error('"message" must be a nonempty string');
        return new e.EthereumProviderError(o, d, m);
      }
    }
  };
  function t(u, o) {
    const [d, m] = n(o);
    return new e.EthereumRpcError(u, d || r.getMessageFromCode(u), m);
  }
  function p(u, o) {
    const [d, m] = n(o);
    return new e.EthereumProviderError(u, d || r.getMessageFromCode(u), m);
  }
  function n(u) {
    if (u) {
      if (typeof u == "string")
        return [u];
      if (typeof u == "object" && !Array.isArray(u)) {
        const { message: o, data: d } = u;
        if (o && typeof o != "string")
          throw new Error("Must specify string message.");
        return [o || void 0, d];
      }
    }
    return [];
  }
  return Fr;
}
var fc;
function gf() {
  return fc || (fc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
    const r = Ys();
    Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
      return r.EthereumRpcError;
    } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
      return r.EthereumProviderError;
    } });
    const i = _l();
    Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
      return i.serializeError;
    } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
      return i.getMessageFromCode;
    } });
    const t = pf();
    Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
      return t.ethErrors;
    } });
    const p = Xs();
    Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
      return p.errorCodes;
    } });
  }(ps)), ps;
}
var pc;
function El() {
  if (pc) return Gt;
  pc = 1;
  var e = Gt.__importDefault || function(n) {
    return n && n.__esModule ? n : { default: n };
  };
  Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.JsonRpcEngine = void 0;
  const r = e(df()), i = gf();
  let t = class it extends r.default {
    constructor() {
      super(), this._middleware = [];
    }
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    push(u) {
      this._middleware.push(u);
    }
    handle(u, o) {
      if (o && typeof o != "function")
        throw new Error('"callback" must be a function if provided.');
      return Array.isArray(u) ? o ? this._handleBatch(u, o) : this._handleBatch(u) : o ? this._handle(u, o) : this._promiseHandle(u);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
    asMiddleware() {
      return async (u, o, d, m) => {
        try {
          const [g, c, h] = await it._runAllMiddleware(u, o, this._middleware);
          return c ? (await it._runReturnHandlers(h), m(g)) : d(async (s) => {
            try {
              await it._runReturnHandlers(h);
            } catch (f) {
              return s(f);
            }
            return s();
          });
        } catch (g) {
          return m(g);
        }
      };
    }
    async _handleBatch(u, o) {
      try {
        const d = await Promise.all(
          // 1. Begin executing each request in the order received
          u.map(this._promiseHandle.bind(this))
        );
        return o ? o(null, d) : d;
      } catch (d) {
        if (o)
          return o(d);
        throw d;
      }
    }
    /**
     * A promise-wrapped _handle.
     */
    _promiseHandle(u) {
      return new Promise((o) => {
        this._handle(u, (d, m) => {
          o(m);
        });
      });
    }
    /**
     * Ensures that the request object is valid, processes it, and passes any
     * error and the response object to the given callback.
     *
     * Does not reject.
     */
    async _handle(u, o) {
      if (!u || Array.isArray(u) || typeof u != "object") {
        const c = new i.EthereumRpcError(i.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof u}`, { request: u });
        return o(c, { id: void 0, jsonrpc: "2.0", error: c });
      }
      if (typeof u.method != "string") {
        const c = new i.EthereumRpcError(i.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof u.method}`, { request: u });
        return o(c, { id: u.id, jsonrpc: "2.0", error: c });
      }
      const d = Object.assign({}, u), m = {
        id: d.id,
        jsonrpc: d.jsonrpc
      };
      let g = null;
      try {
        await this._processRequest(d, m);
      } catch (c) {
        g = c;
      }
      return g && (delete m.result, m.error || (m.error = i.serializeError(g))), o(g, m);
    }
    /**
     * For the given request and response, runs all middleware and their return
     * handlers, if any, and ensures that internal request processing semantics
     * are satisfied.
     */
    async _processRequest(u, o) {
      const [d, m, g] = await it._runAllMiddleware(u, o, this._middleware);
      if (it._checkForCompletion(u, o, m), await it._runReturnHandlers(g), d)
        throw d;
    }
    /**
     * Serially executes the given stack of middleware.
     *
     * @returns An array of any error encountered during middleware execution,
     * a boolean indicating whether the request was completed, and an array of
     * middleware-defined return handlers.
     */
    static async _runAllMiddleware(u, o, d) {
      const m = [];
      let g = null, c = !1;
      for (const h of d)
        if ([g, c] = await it._runMiddleware(u, o, h, m), c)
          break;
      return [g, c, m.reverse()];
    }
    /**
     * Runs an individual middleware.
     *
     * @returns An array of any error encountered during middleware exection,
     * and a boolean indicating whether the request should end.
     */
    static _runMiddleware(u, o, d, m) {
      return new Promise((g) => {
        const c = (s) => {
          const f = s || o.error;
          f && (o.error = i.serializeError(f)), g([f, !0]);
        }, h = (s) => {
          o.error ? c(o.error) : (s && (typeof s != "function" && c(new i.EthereumRpcError(i.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof s}" for request:
${p(u)}`, { request: u })), m.push(s)), g([null, !1]));
        };
        try {
          d(u, o, h, c);
        } catch (s) {
          c(s);
        }
      });
    }
    /**
     * Serially executes array of return handlers. The request and response are
     * assumed to be in their scope.
     */
    static async _runReturnHandlers(u) {
      for (const o of u)
        await new Promise((d, m) => {
          o((g) => g ? m(g) : d());
        });
    }
    /**
     * Throws an error if the response has neither a result nor an error, or if
     * the "isComplete" flag is falsy.
     */
    static _checkForCompletion(u, o, d) {
      if (!("result" in o) && !("error" in o))
        throw new i.EthereumRpcError(i.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${p(u)}`, { request: u });
      if (!d)
        throw new i.EthereumRpcError(i.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${p(u)}`, { request: u });
    }
  };
  Gt.JsonRpcEngine = t;
  function p(n) {
    return JSON.stringify(n, null, 2);
  }
  return Gt;
}
var Dr = {}, gc;
function mf() {
  if (gc) return Dr;
  gc = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.mergeMiddleware = void 0;
  const e = El();
  function r(i) {
    const t = new e.JsonRpcEngine();
    return i.forEach((p) => t.push(p)), t.asMiddleware();
  }
  return Dr.mergeMiddleware = r, Dr;
}
var mc;
function Rl() {
  return mc || (mc = 1, function(e) {
    var r = Lr.__createBinding || (Object.create ? function(t, p, n, u) {
      u === void 0 && (u = n), Object.defineProperty(t, u, { enumerable: !0, get: function() {
        return p[n];
      } });
    } : function(t, p, n, u) {
      u === void 0 && (u = n), t[u] = p[n];
    }), i = Lr.__exportStar || function(t, p) {
      for (var n in t) n !== "default" && !Object.prototype.hasOwnProperty.call(p, n) && r(p, t, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), i(cf(), e), i(lf(), e), i(hf(), e), i(vl(), e), i(El(), e), i(mf(), e);
  }(Lr)), Lr;
}
var ws = {}, un = {};
const eo = /* @__PURE__ */ $r(Cl);
var cn = {}, wc;
function Sl() {
  if (wc) return cn;
  wc = 1, Object.defineProperty(cn, "__esModule", { value: !0 });
  var e = eo, r = (
    /** @class */
    function() {
      function i(t) {
        if (this._maxConcurrency = t, this._queue = [], t <= 0)
          throw new Error("semaphore must be initialized to a positive value");
        this._value = t;
      }
      return i.prototype.acquire = function() {
        var t = this, p = this.isLocked(), n = new Promise(function(u) {
          return t._queue.push(u);
        });
        return p || this._dispatch(), n;
      }, i.prototype.runExclusive = function(t) {
        return e.__awaiter(this, void 0, void 0, function() {
          var p, n, u;
          return e.__generator(this, function(o) {
            switch (o.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                p = o.sent(), n = p[0], u = p[1], o.label = 2;
              case 2:
                return o.trys.push([2, , 4, 5]), [4, t(n)];
              case 3:
                return [2, o.sent()];
              case 4:
                return u(), [
                  7
                  /*endfinally*/
                ];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, i.prototype.isLocked = function() {
        return this._value <= 0;
      }, i.prototype.release = function() {
        if (this._maxConcurrency > 1)
          throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
        if (this._currentReleaser) {
          var t = this._currentReleaser;
          this._currentReleaser = void 0, t();
        }
      }, i.prototype._dispatch = function() {
        var t = this, p = this._queue.shift();
        if (p) {
          var n = !1;
          this._currentReleaser = function() {
            n || (n = !0, t._value++, t._dispatch());
          }, p([this._value--, this._currentReleaser]);
        }
      }, i;
    }()
  );
  return cn.default = r, cn;
}
var yc;
function wf() {
  if (yc) return un;
  yc = 1, Object.defineProperty(un, "__esModule", { value: !0 });
  var e = eo, r = Sl(), i = (
    /** @class */
    function() {
      function t() {
        this._semaphore = new r.default(1);
      }
      return t.prototype.acquire = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          var p, n;
          return e.__generator(this, function(u) {
            switch (u.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                return p = u.sent(), n = p[1], [2, n];
            }
          });
        });
      }, t.prototype.runExclusive = function(p) {
        return this._semaphore.runExclusive(function() {
          return p();
        });
      }, t.prototype.isLocked = function() {
        return this._semaphore.isLocked();
      }, t.prototype.release = function() {
        this._semaphore.release();
      }, t;
    }()
  );
  return un.default = i, un;
}
var qr = {}, bc;
function yf() {
  if (bc) return qr;
  bc = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.withTimeout = void 0;
  var e = eo;
  function r(i, t, p) {
    var n = this;
    return p === void 0 && (p = new Error("timeout")), {
      acquire: function() {
        return new Promise(function(u, o) {
          return e.__awaiter(n, void 0, void 0, function() {
            var d, m, g;
            return e.__generator(this, function(c) {
              switch (c.label) {
                case 0:
                  return d = !1, setTimeout(function() {
                    d = !0, o(p);
                  }, t), [4, i.acquire()];
                case 1:
                  return m = c.sent(), d ? (g = Array.isArray(m) ? m[1] : m, g()) : u(m), [
                    2
                    /*return*/
                  ];
              }
            });
          });
        });
      },
      runExclusive: function(u) {
        return e.__awaiter(this, void 0, void 0, function() {
          var o, d;
          return e.__generator(this, function(m) {
            switch (m.label) {
              case 0:
                o = function() {
                }, m.label = 1;
              case 1:
                return m.trys.push([1, , 7, 8]), [4, this.acquire()];
              case 2:
                return d = m.sent(), Array.isArray(d) ? (o = d[1], [4, u(d[0])]) : [3, 4];
              case 3:
                return [2, m.sent()];
              case 4:
                return o = d, [4, u()];
              case 5:
                return [2, m.sent()];
              case 6:
                return [3, 8];
              case 7:
                return o(), [
                  7
                  /*endfinally*/
                ];
              case 8:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      },
      release: function() {
        i.release();
      },
      isLocked: function() {
        return i.isLocked();
      }
    };
  }
  return qr.withTimeout = r, qr;
}
var vc;
function bf() {
  return vc || (vc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.withTimeout = e.Semaphore = e.Mutex = void 0;
    var r = wf();
    Object.defineProperty(e, "Mutex", { enumerable: !0, get: function() {
      return r.default;
    } });
    var i = Sl();
    Object.defineProperty(e, "Semaphore", { enumerable: !0, get: function() {
      return i.default;
    } });
    var t = yf();
    Object.defineProperty(e, "withTimeout", { enumerable: !0, get: function() {
      return t.withTimeout;
    } });
  }(ws)), ws;
}
var ys, _c;
function vf() {
  if (_c) return ys;
  _c = 1, ys = r;
  var e = Object.prototype.hasOwnProperty;
  function r() {
    for (var i = {}, t = 0; t < arguments.length; t++) {
      var p = arguments[t];
      for (var n in p)
        e.call(p, n) && (i[n] = p[n]);
    }
    return i;
  }
  return ys;
}
var bs, Ec;
function _f() {
  if (Ec) return bs;
  Ec = 1;
  const e = vf(), r = js()();
  bs = i;
  function i(u) {
    const o = this;
    o.currentProvider = u;
  }
  i.prototype.getBalance = p(2, "eth_getBalance"), i.prototype.getCode = p(2, "eth_getCode"), i.prototype.getTransactionCount = p(2, "eth_getTransactionCount"), i.prototype.getStorageAt = p(3, "eth_getStorageAt"), i.prototype.call = p(2, "eth_call"), i.prototype.protocolVersion = t("eth_protocolVersion"), i.prototype.syncing = t("eth_syncing"), i.prototype.coinbase = t("eth_coinbase"), i.prototype.mining = t("eth_mining"), i.prototype.hashrate = t("eth_hashrate"), i.prototype.gasPrice = t("eth_gasPrice"), i.prototype.accounts = t("eth_accounts"), i.prototype.blockNumber = t("eth_blockNumber"), i.prototype.getBlockTransactionCountByHash = t("eth_getBlockTransactionCountByHash"), i.prototype.getBlockTransactionCountByNumber = t("eth_getBlockTransactionCountByNumber"), i.prototype.getUncleCountByBlockHash = t("eth_getUncleCountByBlockHash"), i.prototype.getUncleCountByBlockNumber = t("eth_getUncleCountByBlockNumber"), i.prototype.sign = t("eth_sign"), i.prototype.sendTransaction = t("eth_sendTransaction"), i.prototype.sendRawTransaction = t("eth_sendRawTransaction"), i.prototype.estimateGas = t("eth_estimateGas"), i.prototype.getBlockByHash = t("eth_getBlockByHash"), i.prototype.getBlockByNumber = t("eth_getBlockByNumber"), i.prototype.getTransactionByHash = t("eth_getTransactionByHash"), i.prototype.getTransactionByBlockHashAndIndex = t("eth_getTransactionByBlockHashAndIndex"), i.prototype.getTransactionByBlockNumberAndIndex = t("eth_getTransactionByBlockNumberAndIndex"), i.prototype.getTransactionReceipt = t("eth_getTransactionReceipt"), i.prototype.getUncleByBlockHashAndIndex = t("eth_getUncleByBlockHashAndIndex"), i.prototype.getUncleByBlockNumberAndIndex = t("eth_getUncleByBlockNumberAndIndex"), i.prototype.getCompilers = t("eth_getCompilers"), i.prototype.compileLLL = t("eth_compileLLL"), i.prototype.compileSolidity = t("eth_compileSolidity"), i.prototype.compileSerpent = t("eth_compileSerpent"), i.prototype.newFilter = t("eth_newFilter"), i.prototype.newBlockFilter = t("eth_newBlockFilter"), i.prototype.newPendingTransactionFilter = t("eth_newPendingTransactionFilter"), i.prototype.uninstallFilter = t("eth_uninstallFilter"), i.prototype.getFilterChanges = t("eth_getFilterChanges"), i.prototype.getFilterLogs = t("eth_getFilterLogs"), i.prototype.getLogs = t("eth_getLogs"), i.prototype.getWork = t("eth_getWork"), i.prototype.submitWork = t("eth_submitWork"), i.prototype.submitHashrate = t("eth_submitHashrate"), i.prototype.sendAsync = function(u, o) {
    this.currentProvider.sendAsync(n(u), function(m, g) {
      if (!m && g.error && (m = new Error("EthQuery - RPC Error - " + g.error.message)), m) return o(m);
      o(null, g.result);
    });
  };
  function t(u) {
    return function() {
      const o = this;
      var d = [].slice.call(arguments), m = d.pop();
      o.sendAsync({
        method: u,
        params: d
      }, m);
    };
  }
  function p(u, o) {
    return function() {
      const d = this;
      var m = [].slice.call(arguments), g = m.pop();
      m.length < u && m.push("latest"), d.sendAsync({
        method: o,
        params: m
      }, g);
    };
  }
  function n(u) {
    return e({
      // defaults
      id: r(),
      jsonrpc: "2.0",
      params: []
      // user-specified
    }, u);
  }
  return bs;
}
var vs, Rc;
function Ef() {
  if (Rc) return vs;
  Rc = 1;
  const e = (i, t, p, n) => function(...u) {
    const o = t.promiseModule;
    return new o((d, m) => {
      t.multiArgs ? u.push((...c) => {
        t.errorFirst ? c[0] ? m(c) : (c.shift(), d(c)) : d(c);
      }) : t.errorFirst ? u.push((c, h) => {
        c ? m(c) : d(h);
      }) : u.push(d), Reflect.apply(i, this === p ? n : this, u);
    });
  }, r = /* @__PURE__ */ new WeakMap();
  return vs = (i, t) => {
    t = {
      exclude: [/.+(?:Sync|Stream)$/],
      errorFirst: !0,
      promiseModule: Promise,
      ...t
    };
    const p = typeof i;
    if (!(i !== null && (p === "object" || p === "function")))
      throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${i === null ? "null" : p}\``);
    const n = (d, m) => {
      let g = r.get(d);
      if (g || (g = {}, r.set(d, g)), m in g)
        return g[m];
      const c = (v) => typeof v == "string" || typeof m == "symbol" ? m === v : v.test(m), h = Reflect.getOwnPropertyDescriptor(d, m), s = h === void 0 || h.writable || h.configurable, b = (t.include ? t.include.some(c) : !t.exclude.some(c)) && s;
      return g[m] = b, b;
    }, u = /* @__PURE__ */ new WeakMap(), o = new Proxy(i, {
      apply(d, m, g) {
        const c = u.get(d);
        if (c)
          return Reflect.apply(c, m, g);
        const h = t.excludeMain ? d : e(d, t, o, d);
        return u.set(d, h), Reflect.apply(h, m, g);
      },
      get(d, m) {
        const g = d[m];
        if (!n(d, m) || g === Function.prototype[m])
          return g;
        const c = u.get(g);
        if (c)
          return c;
        if (typeof g == "function") {
          const h = e(g, t, o, d);
          return u.set(g, h), h;
        }
        return g;
      }
    });
    return o;
  }, vs;
}
var _s, Sc;
function to() {
  if (Sc) return _s;
  Sc = 1;
  const e = $s().default;
  class r extends e {
    constructor() {
      super(), this.updates = [];
    }
    async initialize() {
    }
    async update() {
      throw new Error("BaseFilter - no update method specified");
    }
    addResults(t) {
      this.updates = this.updates.concat(t), t.forEach((p) => this.emit("update", p));
    }
    addInitialResults(t) {
    }
    getChangesAndClear() {
      const t = this.updates;
      return this.updates = [], t;
    }
  }
  return _s = r, _s;
}
var Es, Mc;
function Rf() {
  if (Mc) return Es;
  Mc = 1;
  const e = to();
  class r extends e {
    constructor() {
      super(), this.allResults = [];
    }
    async update() {
      throw new Error("BaseFilterWithHistory - no update method specified");
    }
    addResults(t) {
      this.allResults = this.allResults.concat(t), super.addResults(t);
    }
    addInitialResults(t) {
      this.allResults = this.allResults.concat(t), super.addInitialResults(t);
    }
    getAllResults() {
      return this.allResults;
    }
  }
  return Es = r, Es;
}
var Rs, kc;
function zr() {
  if (kc) return Rs;
  kc = 1, Rs = {
    minBlockRef: e,
    maxBlockRef: r,
    sortBlockRefs: i,
    bnToHex: t,
    blockRefIsNumber: p,
    hexToInt: n,
    incrementHexInt: u,
    intToHex: o,
    unsafeRandomBytes: d
  };
  function e(...g) {
    return i(g)[0];
  }
  function r(...g) {
    const c = i(g);
    return c[c.length - 1];
  }
  function i(g) {
    return g.sort((c, h) => c === "latest" || h === "earliest" ? 1 : h === "latest" || c === "earliest" ? -1 : n(c) - n(h));
  }
  function t(g) {
    return "0x" + g.toString(16);
  }
  function p(g) {
    return g && !["earliest", "latest", "pending"].includes(g);
  }
  function n(g) {
    return g == null ? g : Number.parseInt(g, 16);
  }
  function u(g) {
    if (g == null) return g;
    const c = n(g);
    return o(c + 1);
  }
  function o(g) {
    if (g == null) return g;
    let c = g.toString(16);
    return c.length % 2 && (c = "0" + c), "0x" + c;
  }
  function d(g) {
    let c = "0x";
    for (let h = 0; h < g; h++)
      c += m(), c += m();
    return c;
  }
  function m() {
    return Math.floor(Math.random() * 16).toString(16);
  }
  return Rs;
}
var Ss, Cc;
function Sf() {
  if (Cc) return Ss;
  Cc = 1;
  const e = _f(), r = Ef(), i = Rf(), { bnToHex: t, hexToInt: p, incrementHexInt: n, minBlockRef: u, blockRefIsNumber: o } = zr();
  class d extends i {
    constructor({ provider: g, params: c }) {
      super(), this.type = "log", this.ethQuery = new e(g), this.params = Object.assign({
        fromBlock: "latest",
        toBlock: "latest",
        address: void 0,
        topics: []
      }, c), this.params.address && (Array.isArray(this.params.address) || (this.params.address = [this.params.address]), this.params.address = this.params.address.map((h) => h.toLowerCase()));
    }
    async initialize({ currentBlock: g }) {
      let c = this.params.fromBlock;
      ["latest", "pending"].includes(c) && (c = g), c === "earliest" && (c = "0x0"), this.params.fromBlock = c;
      const h = u(this.params.toBlock, g), s = Object.assign({}, this.params, { toBlock: h }), f = await this._fetchLogs(s);
      this.addInitialResults(f);
    }
    async update({ oldBlock: g, newBlock: c }) {
      const h = c;
      let s;
      g ? s = n(g) : s = c;
      const f = Object.assign({}, this.params, { fromBlock: s, toBlock: h }), v = (await this._fetchLogs(f)).filter((a) => this.matchLog(a));
      this.addResults(v);
    }
    async _fetchLogs(g) {
      return await r((h) => this.ethQuery.getLogs(g, h))();
    }
    matchLog(g) {
      if (p(this.params.fromBlock) >= p(g.blockNumber) || o(this.params.toBlock) && p(this.params.toBlock) <= p(g.blockNumber)) return !1;
      const c = g.address && g.address.toLowerCase();
      return this.params.address && c && !this.params.address.includes(c) ? !1 : this.params.topics.every((s, f) => {
        let b = g.topics[f];
        if (!b) return !1;
        b = b.toLowerCase();
        let v = Array.isArray(s) ? s : [s];
        return v.includes(null) ? !0 : (v = v.map((S) => S.toLowerCase()), v.includes(b));
      });
    }
  }
  return Ss = d, Ss;
}
var Ms, Ic;
function ro() {
  if (Ic) return Ms;
  Ic = 1, Ms = e;
  async function e({ provider: n, fromBlock: u, toBlock: o }) {
    u || (u = o);
    const d = r(u), g = r(o) - d + 1, c = Array(g).fill().map((s, f) => d + f).map(i);
    let h = await Promise.all(
      c.map((s) => p(n, "eth_getBlockByNumber", [s, !1]))
    );
    return h = h.filter((s) => s !== null), h;
  }
  function r(n) {
    return n == null ? n : Number.parseInt(n, 16);
  }
  function i(n) {
    return n == null ? n : "0x" + n.toString(16);
  }
  function t(n, u) {
    return new Promise((o, d) => {
      n.sendAsync(u, (m, g) => {
        m ? d(m) : g.error ? d(g.error) : g.result ? o(g.result) : d(new Error("Result was empty"));
      });
    });
  }
  async function p(n, u, o) {
    for (let d = 0; d < 3; d++)
      try {
        return await t(n, {
          id: 1,
          jsonrpc: "2.0",
          method: u,
          params: o
        });
      } catch (m) {
        console.error(
          `provider.sendAsync failed: ${m.stack || m.message || m}`
        );
      }
    return null;
  }
  return Ms;
}
var ks, xc;
function Mf() {
  if (xc) return ks;
  xc = 1;
  const e = to(), r = ro(), { incrementHexInt: i } = zr();
  class t extends e {
    constructor({ provider: n, params: u }) {
      super(), this.type = "block", this.provider = n;
    }
    async update({ oldBlock: n, newBlock: u }) {
      const o = u, d = i(n), g = (await r({ provider: this.provider, fromBlock: d, toBlock: o })).map((c) => c.hash);
      this.addResults(g);
    }
  }
  return ks = t, ks;
}
var Cs, Ac;
function kf() {
  if (Ac) return Cs;
  Ac = 1;
  const e = to(), r = ro(), { incrementHexInt: i } = zr();
  class t extends e {
    constructor({ provider: n }) {
      super(), this.type = "tx", this.provider = n;
    }
    async update({ oldBlock: n }) {
      const u = n, o = i(n), d = await r({ provider: this.provider, fromBlock: o, toBlock: u }), m = [];
      for (const g of d)
        m.push(...g.transactions);
      this.addResults(m);
    }
  }
  return Cs = t, Cs;
}
var Is, Tc;
function Cf() {
  if (Tc) return Is;
  Tc = 1;
  const e = bf().Mutex, { createAsyncMiddleware: r, createScaffoldMiddleware: i } = Rl(), t = Sf(), p = Mf(), n = kf(), { intToHex: u, hexToInt: o } = zr();
  Is = d;
  function d({ blockTracker: s, provider: f }) {
    let b = 0, v = {};
    const a = new e(), R = c({ mutex: a }), S = i({
      // install filters
      eth_newFilter: R(m(T)),
      eth_newBlockFilter: R(m(q)),
      eth_newPendingTransactionFilter: R(m(D)),
      // uninstall filters
      eth_uninstallFilter: R(g(ee)),
      // checking filter changes
      eth_getFilterChanges: R(g(H)),
      eth_getFilterLogs: R(g(G))
    }), I = async ({ oldBlock: E, newBlock: M }) => {
      if (v.length === 0) return;
      const k = await a.acquire();
      try {
        await Promise.all(h(v).map(async (x) => {
          try {
            await x.update({ oldBlock: E, newBlock: M });
          } catch (B) {
            console.error(B);
          }
        }));
      } catch (x) {
        console.error(x);
      }
      k();
    };
    return S.newLogFilter = T, S.newBlockFilter = q, S.newPendingTransactionFilter = D, S.uninstallFilter = ee, S.getFilterChanges = H, S.getFilterLogs = G, S.destroy = () => {
      F();
    }, S;
    async function T(E) {
      const M = new t({ provider: f, params: E });
      return await Y(M), M;
    }
    async function q() {
      const E = new p({ provider: f });
      return await Y(E), E;
    }
    async function D() {
      const E = new n({ provider: f });
      return await Y(E), E;
    }
    async function H(E) {
      const M = o(E), k = v[M];
      if (!k)
        throw new Error(`No filter for index "${M}"`);
      return k.getChangesAndClear();
    }
    async function G(E) {
      const M = o(E), k = v[M];
      if (!k)
        throw new Error(`No filter for index "${M}"`);
      let x = [];
      return k.type === "log" && (x = k.getAllResults()), x;
    }
    async function ee(E) {
      const M = o(E), x = !!v[M];
      return x && await re(M), x;
    }
    async function Y(E) {
      const M = h(v).length, k = await s.getLatestBlock();
      await E.initialize({ currentBlock: k }), b++, v[b] = E, E.id = b, E.idHex = u(b);
      const x = h(v).length;
      return l({ prevFilterCount: M, newFilterCount: x }), b;
    }
    async function re(E) {
      const M = h(v).length;
      delete v[E];
      const k = h(v).length;
      l({ prevFilterCount: M, newFilterCount: k });
    }
    async function F() {
      const E = h(v).length;
      v = {}, l({ prevFilterCount: E, newFilterCount: 0 });
    }
    function l({ prevFilterCount: E, newFilterCount: M }) {
      if (E === 0 && M > 0) {
        s.on("sync", I);
        return;
      }
      if (E > 0 && M === 0) {
        s.removeListener("sync", I);
        return;
      }
    }
  }
  function m(s) {
    return g(async (...f) => {
      const b = await s(...f);
      return u(b.id);
    });
  }
  function g(s) {
    return r(async (f, b) => {
      const v = await s.apply(null, f.params);
      b.result = v;
    });
  }
  function c({ mutex: s }) {
    return (f) => async (b, v, a, R) => {
      (await s.acquire())(), f(b, v, a, R);
    };
  }
  function h(s, f) {
    const b = [];
    for (let v in s)
      b.push(s[v]);
    return b;
  }
  return Is;
}
var xs, Lc;
function If() {
  if (Lc) return xs;
  Lc = 1;
  const e = $s().default, { createAsyncMiddleware: r, createScaffoldMiddleware: i } = Rl(), t = Cf(), { unsafeRandomBytes: p, incrementHexInt: n } = zr(), u = ro();
  xs = o;
  function o({ blockTracker: m, provider: g }) {
    const c = {}, h = t({ blockTracker: m, provider: g });
    let s = !1;
    const f = new e(), b = i({
      eth_subscribe: r(v),
      eth_unsubscribe: r(a)
    });
    return b.destroy = S, { events: f, middleware: b };
    async function v(I, T) {
      if (s) throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
      const q = I.params[0], D = p(16);
      let H;
      switch (q) {
        case "newHeads":
          H = G({ subId: D });
          break;
        case "logs":
          const Y = I.params[1], re = await h.newLogFilter(Y);
          H = ee({ subId: D, filter: re });
          break;
        default:
          throw new Error(`SubscriptionManager - unsupported subscription type "${q}"`);
      }
      c[D] = H, T.result = D;
      return;
      function G({ subId: Y }) {
        const re = {
          type: q,
          destroy: async () => {
            m.removeListener("sync", re.update);
          },
          update: async ({ oldBlock: F, newBlock: l }) => {
            const E = l, M = n(F);
            (await u({ provider: g, fromBlock: M, toBlock: E })).map(d).filter((B) => B !== null).forEach((B) => {
              R(Y, B);
            });
          }
        };
        return m.on("sync", re.update), re;
      }
      function ee({ subId: Y, filter: re }) {
        return re.on("update", (l) => R(Y, l)), {
          type: q,
          destroy: async () => await h.uninstallFilter(re.idHex)
        };
      }
    }
    async function a(I, T) {
      if (s) throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
      const q = I.params[0], D = c[q];
      if (!D) {
        T.result = !1;
        return;
      }
      delete c[q], await D.destroy(), T.result = !0;
    }
    function R(I, T) {
      f.emit("notification", {
        jsonrpc: "2.0",
        method: "eth_subscription",
        params: {
          subscription: I,
          result: T
        }
      });
    }
    function S() {
      f.removeAllListeners();
      for (const I in c)
        c[I].destroy(), delete c[I];
      s = !0;
    }
  }
  function d(m) {
    return m == null ? null : {
      hash: m.hash,
      parentHash: m.parentHash,
      sha3Uncles: m.sha3Uncles,
      miner: m.miner,
      stateRoot: m.stateRoot,
      transactionsRoot: m.transactionsRoot,
      receiptsRoot: m.receiptsRoot,
      logsBloom: m.logsBloom,
      difficulty: m.difficulty,
      number: m.number,
      gasLimit: m.gasLimit,
      gasUsed: m.gasUsed,
      nonce: m.nonce,
      mixHash: m.mixHash,
      timestamp: m.timestamp,
      extraData: m.extraData
    };
  }
  return xs;
}
var Bc;
function xf() {
  if (Bc) return Cr;
  Bc = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.SubscriptionManager = void 0;
  const e = uf(), r = If(), i = () => {
  };
  let t = class {
    constructor(n) {
      const u = new e.PollingBlockTracker({
        provider: n,
        pollingInterval: 15e3,
        setSkipCacheFlag: !0
      }), { events: o, middleware: d } = r({
        blockTracker: u,
        provider: n
      });
      this.events = o, this.subscriptionMiddleware = d;
    }
    async handleRequest(n) {
      const u = {};
      return await this.subscriptionMiddleware(n, u, i, i), u;
    }
    destroy() {
      this.subscriptionMiddleware.destroy();
    }
  };
  return Cr.SubscriptionManager = t, Cr;
}
var Nc;
function Ts() {
  if (Nc) return Dt;
  Nc = 1;
  var e = Dt.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.CoinbaseWalletProvider = void 0;
  const r = e(dn()), i = Il(), t = /* @__PURE__ */ pn(), p = /* @__PURE__ */ tt(), n = /* @__PURE__ */ Gc(), u = /* @__PURE__ */ Fs(), o = /* @__PURE__ */ Ds(), d = /* @__PURE__ */ Ns(), m = e(/* @__PURE__ */ Th()), g = /* @__PURE__ */ Os(), c = /* @__PURE__ */ Lh(), h = /* @__PURE__ */ xf(), s = "DefaultChainId", f = "DefaultJsonRpcUrl";
  let b = class extends i.EventEmitter {
    constructor(a) {
      var R, S;
      super(), this._filterPolyfill = new c.FilterPolyfill(this), this._subscriptionManager = new h.SubscriptionManager(this), this._relay = null, this._addresses = [], this.hasMadeFirstChainChangedEmission = !1, this.setProviderInfo = this.setProviderInfo.bind(this), this.updateProviderInfo = this.updateProviderInfo.bind(this), this.getChainId = this.getChainId.bind(this), this.setAppInfo = this.setAppInfo.bind(this), this.enable = this.enable.bind(this), this.close = this.close.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this.request = this.request.bind(this), this._setAddresses = this._setAddresses.bind(this), this.scanQRCode = this.scanQRCode.bind(this), this.genericRequest = this.genericRequest.bind(this), this._chainIdFromOpts = a.chainId, this._jsonRpcUrlFromOpts = a.jsonRpcUrl, this._overrideIsMetaMask = a.overrideIsMetaMask, this._relayProvider = a.relayProvider, this._storage = a.storage, this._relayEventManager = a.relayEventManager, this.diagnostic = a.diagnosticLogger, this.reloadOnDisconnect = !0, this.isCoinbaseWallet = (R = a.overrideIsCoinbaseWallet) !== null && R !== void 0 ? R : !0, this.isCoinbaseBrowser = (S = a.overrideIsCoinbaseBrowser) !== null && S !== void 0 ? S : !1, this.qrUrl = a.qrUrl;
      const I = this.getChainId(), T = (0, p.prepend0x)(I.toString(16));
      this.emit("connect", { chainIdStr: T });
      const q = this._storage.getItem(u.LOCAL_STORAGE_ADDRESSES_KEY);
      if (q) {
        const D = q.split(" ");
        D[0] !== "" && (this._addresses = D.map((H) => (0, p.ensureAddressString)(H)), this.emit("accountsChanged", D));
      }
      this._subscriptionManager.events.on("notification", (D) => {
        this.emit("message", {
          type: D.method,
          data: D.params
        });
      }), this._isAuthorized() && this.initializeRelay(), window.addEventListener("message", (D) => {
        var H;
        if (!(D.origin !== location.origin || D.source !== window) && D.data.type === "walletLinkMessage" && D.data.data.action === "dappChainSwitched") {
          const G = D.data.data.chainId, ee = (H = D.data.data.jsonRpcUrl) !== null && H !== void 0 ? H : this.jsonRpcUrl;
          this.updateProviderInfo(ee, Number(G));
        }
      });
    }
    /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
    get selectedAddress() {
      return this._addresses[0] || void 0;
    }
    /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
    get networkVersion() {
      return this.getChainId().toString(10);
    }
    /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
    get chainId() {
      return (0, p.prepend0x)(this.getChainId().toString(16));
    }
    get isWalletLink() {
      return !0;
    }
    /**
     * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
     * true for this method.
     */
    get isMetaMask() {
      return this._overrideIsMetaMask;
    }
    get host() {
      return this.jsonRpcUrl;
    }
    get connected() {
      return !0;
    }
    isConnected() {
      return !0;
    }
    get jsonRpcUrl() {
      var a;
      return (a = this._storage.getItem(f)) !== null && a !== void 0 ? a : this._jsonRpcUrlFromOpts;
    }
    set jsonRpcUrl(a) {
      this._storage.setItem(f, a);
    }
    disableReloadOnDisconnect() {
      this.reloadOnDisconnect = !1;
    }
    setProviderInfo(a, R) {
      this.isCoinbaseBrowser || (this._chainIdFromOpts = R, this._jsonRpcUrlFromOpts = a), this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
    }
    updateProviderInfo(a, R) {
      this.jsonRpcUrl = a;
      const S = this.getChainId();
      this._storage.setItem(s, R.toString(10)), ((0, p.ensureIntNumber)(R) !== S || !this.hasMadeFirstChainChangedEmission) && (this.emit("chainChanged", this.getChainId()), this.hasMadeFirstChainChangedEmission = !0);
    }
    async watchAsset(a, R, S, I, T, q) {
      const H = await (await this.initializeRelay()).watchAsset(a, R, S, I, T, q == null ? void 0 : q.toString()).promise;
      return (0, d.isErrorResponse)(H) ? !1 : !!H.result;
    }
    async addEthereumChain(a, R, S, I, T, q) {
      var D, H;
      if ((0, p.ensureIntNumber)(a) === this.getChainId())
        return !1;
      const G = await this.initializeRelay(), ee = G.inlineAddEthereumChain(a.toString());
      !this._isAuthorized() && !ee && await G.requestEthereumAccounts().promise;
      const Y = await G.addEthereumChain(a.toString(), R, T, S, I, q).promise;
      return (0, d.isErrorResponse)(Y) ? !1 : (((D = Y.result) === null || D === void 0 ? void 0 : D.isApproved) === !0 && this.updateProviderInfo(R[0], a), ((H = Y.result) === null || H === void 0 ? void 0 : H.isApproved) === !0);
    }
    async switchEthereumChain(a) {
      const S = await (await this.initializeRelay()).switchEthereumChain(a.toString(10), this.selectedAddress || void 0).promise;
      if ((0, d.isErrorResponse)(S)) {
        if (!S.errorCode)
          return;
        throw S.errorCode === t.standardErrorCodes.provider.unsupportedChain ? t.standardErrors.provider.unsupportedChain() : t.standardErrors.provider.custom({
          message: S.errorMessage,
          code: S.errorCode
        });
      }
      const I = S.result;
      I.isApproved && I.rpcUrl.length > 0 && this.updateProviderInfo(I.rpcUrl, a);
    }
    setAppInfo(a, R) {
      this.initializeRelay().then((S) => S.setAppInfo(a, R));
    }
    /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
    async enable() {
      var a;
      return (a = this.diagnostic) === null || a === void 0 || a.log(g.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::enable",
        addresses_length: this._addresses.length,
        sessionIdHash: this._relay ? o.Session.hash(this._relay.session.id) : void 0
      }), this._isAuthorized() ? [...this._addresses] : await this.send("eth_requestAccounts");
    }
    async close() {
      (await this.initializeRelay()).resetAndReload();
    }
    send(a, R) {
      try {
        const S = this._send(a, R);
        if (S instanceof Promise)
          return S.catch((I) => {
            throw (0, t.serializeError)(I, a);
          });
      } catch (S) {
        throw (0, t.serializeError)(S, a);
      }
    }
    _send(a, R) {
      if (typeof a == "string") {
        const I = a, T = Array.isArray(R) ? R : R !== void 0 ? [R] : [], q = {
          jsonrpc: "2.0",
          id: 0,
          method: I,
          params: T
        };
        return this._sendRequestAsync(q).then((D) => D.result);
      }
      if (typeof R == "function") {
        const I = a, T = R;
        return this._sendAsync(I, T);
      }
      if (Array.isArray(a))
        return a.map((T) => this._sendRequest(T));
      const S = a;
      return this._sendRequest(S);
    }
    async sendAsync(a, R) {
      try {
        return this._sendAsync(a, R).catch((S) => {
          throw (0, t.serializeError)(S, a);
        });
      } catch (S) {
        return Promise.reject((0, t.serializeError)(S, a));
      }
    }
    async _sendAsync(a, R) {
      if (typeof R != "function")
        throw new Error("callback is required");
      if (Array.isArray(a)) {
        const I = R;
        this._sendMultipleRequestsAsync(a).then((T) => I(null, T)).catch((T) => I(T, null));
        return;
      }
      const S = R;
      return this._sendRequestAsync(a).then((I) => S(null, I)).catch((I) => S(I, null));
    }
    async request(a) {
      try {
        return this._request(a).catch((R) => {
          throw (0, t.serializeError)(R, a.method);
        });
      } catch (R) {
        return Promise.reject((0, t.serializeError)(R, a.method));
      }
    }
    async _request(a) {
      if (!a || typeof a != "object" || Array.isArray(a))
        throw t.standardErrors.rpc.invalidRequest({
          message: "Expected a single, non-array, object argument.",
          data: a
        });
      const { method: R, params: S } = a;
      if (typeof R != "string" || R.length === 0)
        throw t.standardErrors.rpc.invalidRequest({
          message: "'args.method' must be a non-empty string.",
          data: a
        });
      if (S !== void 0 && !Array.isArray(S) && (typeof S != "object" || S === null))
        throw t.standardErrors.rpc.invalidRequest({
          message: "'args.params' must be an object or array if provided.",
          data: a
        });
      const I = S === void 0 ? [] : S, T = this._relayEventManager.makeRequestId();
      return (await this._sendRequestAsync({
        method: R,
        params: I,
        jsonrpc: "2.0",
        id: T
      })).result;
    }
    async scanQRCode(a) {
      const S = await (await this.initializeRelay()).scanQRCode((0, p.ensureRegExpString)(a)).promise;
      if ((0, d.isErrorResponse)(S))
        throw (0, t.serializeError)(S.errorMessage, "scanQRCode");
      if (typeof S.result != "string")
        throw (0, t.serializeError)("result was not a string", "scanQRCode");
      return S.result;
    }
    async genericRequest(a, R) {
      const I = await (await this.initializeRelay()).genericRequest(a, R).promise;
      if ((0, d.isErrorResponse)(I))
        throw (0, t.serializeError)(I.errorMessage, "generic");
      if (typeof I.result != "string")
        throw (0, t.serializeError)("result was not a string", "generic");
      return I.result;
    }
    /**
     * @beta
     * This method is currently in beta. While it is available for use, please note that it is still under testing and may undergo significant changes.
     *
     * @remarks
     * IMPORTANT: Signature validation is not performed by this method. Users of this method are advised to perform their own signature validation.
     * Common web3 frontend libraries such as ethers.js and viem provide the `verifyMessage` utility function that can be used for signature validation.
     *
     * It combines `eth_requestAccounts` and "Sign-In with Ethereum" (EIP-4361) into a single call.
     * The returned account and signed message can be used to authenticate the user.
     *
     * @param {Object} params - An object with the following properties:
     * - `nonce` {string}: A unique string to prevent replay attacks.
     * - `statement` {string}: An optional human-readable ASCII assertion that the user will sign.
     * - `resources` {string[]}: An optional list of information the user wishes to have resolved as part of authentication by the relying party.
     *
     * @returns {Promise<ConnectAndSignInResponse>} A promise that resolves to an object with the following properties:
     * - `accounts` {string[]}: The Ethereum accounts of the user.
     * - `message` {string}: The overall message that the user signed. Hex encoded.
     * - `signature` {string}: The signature of the message, signed with the user's private key. Hex encoded.
     */
    async connectAndSignIn(a) {
      var R;
      (R = this.diagnostic) === null || R === void 0 || R.log(g.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::connectAndSignIn",
        sessionIdHash: this._relay ? o.Session.hash(this._relay.session.id) : void 0
      });
      let S;
      try {
        const T = await this.initializeRelay();
        if (!(T instanceof n.MobileRelay))
          throw new Error("connectAndSignIn is only supported on mobile");
        if (S = await T.connectAndSignIn(a).promise, (0, d.isErrorResponse)(S))
          throw new Error(S.errorMessage);
      } catch (T) {
        throw typeof T.message == "string" && T.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied account authorization") : T;
      }
      if (!S.result)
        throw new Error("accounts received is empty");
      const { accounts: I } = S.result;
      return this._setAddresses(I), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), S.result;
    }
    async selectProvider(a) {
      const S = await (await this.initializeRelay()).selectProvider(a).promise;
      if ((0, d.isErrorResponse)(S))
        throw (0, t.serializeError)(S.errorMessage, "selectProvider");
      if (typeof S.result != "string")
        throw (0, t.serializeError)("result was not a string", "selectProvider");
      return S.result;
    }
    supportsSubscriptions() {
      return !1;
    }
    subscribe() {
      throw new Error("Subscriptions are not supported");
    }
    unsubscribe() {
      throw new Error("Subscriptions are not supported");
    }
    disconnect() {
      return !0;
    }
    _sendRequest(a) {
      const R = {
        jsonrpc: "2.0",
        id: a.id
      }, { method: S } = a;
      if (R.result = this._handleSynchronousMethods(a), R.result === void 0)
        throw new Error(`Coinbase Wallet does not support calling ${S} synchronously without a callback. Please provide a callback parameter to call ${S} asynchronously.`);
      return R;
    }
    _setAddresses(a, R) {
      if (!Array.isArray(a))
        throw new Error("addresses is not an array");
      const S = a.map((I) => (0, p.ensureAddressString)(I));
      JSON.stringify(S) !== JSON.stringify(this._addresses) && (this._addresses = S, this.emit("accountsChanged", this._addresses), this._storage.setItem(u.LOCAL_STORAGE_ADDRESSES_KEY, S.join(" ")));
    }
    _sendRequestAsync(a) {
      return new Promise((R, S) => {
        try {
          const I = this._handleSynchronousMethods(a);
          if (I !== void 0)
            return R({
              jsonrpc: "2.0",
              id: a.id,
              result: I
            });
          const T = this._handleAsynchronousFilterMethods(a);
          if (T !== void 0) {
            T.then((D) => R(Object.assign(Object.assign({}, D), { id: a.id }))).catch((D) => S(D));
            return;
          }
          const q = this._handleSubscriptionMethods(a);
          if (q !== void 0) {
            q.then((D) => R({
              jsonrpc: "2.0",
              id: a.id,
              result: D.result
            })).catch((D) => S(D));
            return;
          }
        } catch (I) {
          return S(I);
        }
        this._handleAsynchronousMethods(a).then((I) => I && R(Object.assign(Object.assign({}, I), { id: a.id }))).catch((I) => S(I));
      });
    }
    _sendMultipleRequestsAsync(a) {
      return Promise.all(a.map((R) => this._sendRequestAsync(R)));
    }
    _handleSynchronousMethods(a) {
      const { method: R } = a, S = a.params || [];
      switch (R) {
        case "eth_accounts":
          return this._eth_accounts();
        case "eth_coinbase":
          return this._eth_coinbase();
        case "eth_uninstallFilter":
          return this._eth_uninstallFilter(S);
        case "net_version":
          return this._net_version();
        case "eth_chainId":
          return this._eth_chainId();
        default:
          return;
      }
    }
    async _handleAsynchronousMethods(a) {
      const { method: R } = a, S = a.params || [];
      switch (R) {
        case "eth_requestAccounts":
          return this._eth_requestAccounts();
        case "eth_sign":
          return this._eth_sign(S);
        case "eth_ecRecover":
          return this._eth_ecRecover(S);
        case "personal_sign":
          return this._personal_sign(S);
        case "personal_ecRecover":
          return this._personal_ecRecover(S);
        case "eth_signTransaction":
          return this._eth_signTransaction(S);
        case "eth_sendRawTransaction":
          return this._eth_sendRawTransaction(S);
        case "eth_sendTransaction":
          return this._eth_sendTransaction(S);
        case "eth_signTypedData_v1":
          return this._eth_signTypedData_v1(S);
        case "eth_signTypedData_v2":
          return this._throwUnsupportedMethodError();
        case "eth_signTypedData_v3":
          return this._eth_signTypedData_v3(S);
        case "eth_signTypedData_v4":
        case "eth_signTypedData":
          return this._eth_signTypedData_v4(S);
        case "cbWallet_arbitrary":
          return this._cbwallet_arbitrary(S);
        case "wallet_addEthereumChain":
          return this._wallet_addEthereumChain(S);
        case "wallet_switchEthereumChain":
          return this._wallet_switchEthereumChain(S);
        case "wallet_watchAsset":
          return this._wallet_watchAsset(S);
      }
      return (await this.initializeRelay()).makeEthereumJSONRPCRequest(a, this.jsonRpcUrl).catch((T) => {
        var q;
        throw (T.code === t.standardErrorCodes.rpc.methodNotFound || T.code === t.standardErrorCodes.rpc.methodNotSupported) && ((q = this.diagnostic) === null || q === void 0 || q.log(g.EVENTS.METHOD_NOT_IMPLEMENTED, {
          method: a.method,
          sessionIdHash: this._relay ? o.Session.hash(this._relay.session.id) : void 0
        })), T;
      });
    }
    _handleAsynchronousFilterMethods(a) {
      const { method: R } = a, S = a.params || [];
      switch (R) {
        case "eth_newFilter":
          return this._eth_newFilter(S);
        case "eth_newBlockFilter":
          return this._eth_newBlockFilter();
        case "eth_newPendingTransactionFilter":
          return this._eth_newPendingTransactionFilter();
        case "eth_getFilterChanges":
          return this._eth_getFilterChanges(S);
        case "eth_getFilterLogs":
          return this._eth_getFilterLogs(S);
      }
    }
    _handleSubscriptionMethods(a) {
      switch (a.method) {
        case "eth_subscribe":
        case "eth_unsubscribe":
          return this._subscriptionManager.handleRequest(a);
      }
    }
    _isKnownAddress(a) {
      try {
        const R = (0, p.ensureAddressString)(a);
        return this._addresses.map((I) => (0, p.ensureAddressString)(I)).includes(R);
      } catch {
      }
      return !1;
    }
    _ensureKnownAddress(a) {
      var R;
      if (!this._isKnownAddress(a))
        throw (R = this.diagnostic) === null || R === void 0 || R.log(g.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED), new Error("Unknown Ethereum address");
    }
    _prepareTransactionParams(a) {
      const R = a.from ? (0, p.ensureAddressString)(a.from) : this.selectedAddress;
      if (!R)
        throw new Error("Ethereum address is unavailable");
      this._ensureKnownAddress(R);
      const S = a.to ? (0, p.ensureAddressString)(a.to) : null, I = a.value != null ? (0, p.ensureBN)(a.value) : new r.default(0), T = a.data ? (0, p.ensureBuffer)(a.data) : Buffer.alloc(0), q = a.nonce != null ? (0, p.ensureIntNumber)(a.nonce) : null, D = a.gasPrice != null ? (0, p.ensureBN)(a.gasPrice) : null, H = a.maxFeePerGas != null ? (0, p.ensureBN)(a.maxFeePerGas) : null, G = a.maxPriorityFeePerGas != null ? (0, p.ensureBN)(a.maxPriorityFeePerGas) : null, ee = a.gas != null ? (0, p.ensureBN)(a.gas) : null, Y = a.chainId ? (0, p.ensureIntNumber)(a.chainId) : this.getChainId();
      return {
        fromAddress: R,
        toAddress: S,
        weiValue: I,
        data: T,
        nonce: q,
        gasPriceInWei: D,
        maxFeePerGas: H,
        maxPriorityFeePerGas: G,
        gasLimit: ee,
        chainId: Y
      };
    }
    _isAuthorized() {
      return this._addresses.length > 0;
    }
    _requireAuthorization() {
      if (!this._isAuthorized())
        throw t.standardErrors.provider.unauthorized({});
    }
    _throwUnsupportedMethodError() {
      throw t.standardErrors.provider.unsupportedMethod({});
    }
    async _signEthereumMessage(a, R, S, I) {
      this._ensureKnownAddress(R);
      try {
        const q = await (await this.initializeRelay()).signEthereumMessage(a, R, S, I).promise;
        if ((0, d.isErrorResponse)(q))
          throw new Error(q.errorMessage);
        return { jsonrpc: "2.0", id: 0, result: q.result };
      } catch (T) {
        throw typeof T.message == "string" && T.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied message signature") : T;
      }
    }
    async _ethereumAddressFromSignedMessage(a, R, S) {
      const T = await (await this.initializeRelay()).ethereumAddressFromSignedMessage(a, R, S).promise;
      if ((0, d.isErrorResponse)(T))
        throw new Error(T.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: T.result };
    }
    _eth_accounts() {
      return [...this._addresses];
    }
    _eth_coinbase() {
      return this.selectedAddress || null;
    }
    _net_version() {
      return this.getChainId().toString(10);
    }
    _eth_chainId() {
      return (0, p.hexStringFromIntNumber)(this.getChainId());
    }
    getChainId() {
      const a = this._storage.getItem(s);
      if (!a)
        return (0, p.ensureIntNumber)(this._chainIdFromOpts);
      const R = parseInt(a, 10);
      return (0, p.ensureIntNumber)(R);
    }
    async _eth_requestAccounts() {
      var a;
      if ((a = this.diagnostic) === null || a === void 0 || a.log(g.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::_eth_requestAccounts",
        addresses_length: this._addresses.length,
        sessionIdHash: this._relay ? o.Session.hash(this._relay.session.id) : void 0
      }), this._isAuthorized())
        return Promise.resolve({
          jsonrpc: "2.0",
          id: 0,
          result: this._addresses
        });
      let R;
      try {
        if (R = await (await this.initializeRelay()).requestEthereumAccounts().promise, (0, d.isErrorResponse)(R))
          throw new Error(R.errorMessage);
      } catch (S) {
        throw typeof S.message == "string" && S.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied account authorization") : S;
      }
      if (!R.result)
        throw new Error("accounts received is empty");
      return this._setAddresses(R.result), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), { jsonrpc: "2.0", id: 0, result: this._addresses };
    }
    _eth_sign(a) {
      this._requireAuthorization();
      const R = (0, p.ensureAddressString)(a[0]), S = (0, p.ensureBuffer)(a[1]);
      return this._signEthereumMessage(S, R, !1);
    }
    _eth_ecRecover(a) {
      const R = (0, p.ensureBuffer)(a[0]), S = (0, p.ensureBuffer)(a[1]);
      return this._ethereumAddressFromSignedMessage(R, S, !1);
    }
    _personal_sign(a) {
      this._requireAuthorization();
      const R = (0, p.ensureBuffer)(a[0]), S = (0, p.ensureAddressString)(a[1]);
      return this._signEthereumMessage(R, S, !0);
    }
    _personal_ecRecover(a) {
      const R = (0, p.ensureBuffer)(a[0]), S = (0, p.ensureBuffer)(a[1]);
      return this._ethereumAddressFromSignedMessage(R, S, !0);
    }
    async _eth_signTransaction(a) {
      this._requireAuthorization();
      const R = this._prepareTransactionParams(a[0] || {});
      try {
        const I = await (await this.initializeRelay()).signEthereumTransaction(R).promise;
        if ((0, d.isErrorResponse)(I))
          throw new Error(I.errorMessage);
        return { jsonrpc: "2.0", id: 0, result: I.result };
      } catch (S) {
        throw typeof S.message == "string" && S.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied transaction signature") : S;
      }
    }
    async _eth_sendRawTransaction(a) {
      const R = (0, p.ensureBuffer)(a[0]), I = await (await this.initializeRelay()).submitEthereumTransaction(R, this.getChainId()).promise;
      if ((0, d.isErrorResponse)(I))
        throw new Error(I.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: I.result };
    }
    async _eth_sendTransaction(a) {
      this._requireAuthorization();
      const R = this._prepareTransactionParams(a[0] || {});
      try {
        const I = await (await this.initializeRelay()).signAndSubmitEthereumTransaction(R).promise;
        if ((0, d.isErrorResponse)(I))
          throw new Error(I.errorMessage);
        return { jsonrpc: "2.0", id: 0, result: I.result };
      } catch (S) {
        throw typeof S.message == "string" && S.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied transaction signature") : S;
      }
    }
    async _eth_signTypedData_v1(a) {
      this._requireAuthorization();
      const R = (0, p.ensureParsedJSONObject)(a[0]), S = (0, p.ensureAddressString)(a[1]);
      this._ensureKnownAddress(S);
      const I = m.default.hashForSignTypedDataLegacy({ data: R }), T = JSON.stringify(R, null, 2);
      return this._signEthereumMessage(I, S, !1, T);
    }
    async _eth_signTypedData_v3(a) {
      this._requireAuthorization();
      const R = (0, p.ensureAddressString)(a[0]), S = (0, p.ensureParsedJSONObject)(a[1]);
      this._ensureKnownAddress(R);
      const I = m.default.hashForSignTypedData_v3({ data: S }), T = JSON.stringify(S, null, 2);
      return this._signEthereumMessage(I, R, !1, T);
    }
    async _eth_signTypedData_v4(a) {
      this._requireAuthorization();
      const R = (0, p.ensureAddressString)(a[0]), S = (0, p.ensureParsedJSONObject)(a[1]);
      this._ensureKnownAddress(R);
      const I = m.default.hashForSignTypedData_v4({ data: S }), T = JSON.stringify(S, null, 2);
      return this._signEthereumMessage(I, R, !1, T);
    }
    /** @deprecated */
    async _cbwallet_arbitrary(a) {
      const R = a[0], S = a[1];
      if (typeof S != "string")
        throw new Error("parameter must be a string");
      if (typeof R != "object" || R === null)
        throw new Error("parameter must be an object");
      return { jsonrpc: "2.0", id: 0, result: await this.genericRequest(R, S) };
    }
    async _wallet_addEthereumChain(a) {
      var R, S, I, T;
      const q = a[0];
      if (((R = q.rpcUrls) === null || R === void 0 ? void 0 : R.length) === 0)
        return {
          jsonrpc: "2.0",
          id: 0,
          error: { code: 2, message: "please pass in at least 1 rpcUrl" }
        };
      if (!q.chainName || q.chainName.trim() === "")
        throw t.standardErrors.rpc.invalidParams("chainName is a required field");
      if (!q.nativeCurrency)
        throw t.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
      const D = parseInt(q.chainId, 16);
      return await this.addEthereumChain(D, (S = q.rpcUrls) !== null && S !== void 0 ? S : [], (I = q.blockExplorerUrls) !== null && I !== void 0 ? I : [], q.chainName, (T = q.iconUrls) !== null && T !== void 0 ? T : [], q.nativeCurrency) ? { jsonrpc: "2.0", id: 0, result: null } : {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: "unable to add ethereum chain" }
      };
    }
    async _wallet_switchEthereumChain(a) {
      const R = a[0];
      return await this.switchEthereumChain(parseInt(R.chainId, 16)), { jsonrpc: "2.0", id: 0, result: null };
    }
    async _wallet_watchAsset(a) {
      const R = Array.isArray(a) ? a[0] : a;
      if (!R.type)
        throw t.standardErrors.rpc.invalidParams("Type is required");
      if ((R == null ? void 0 : R.type) !== "ERC20")
        throw t.standardErrors.rpc.invalidParams(`Asset of type '${R.type}' is not supported`);
      if (!(R != null && R.options))
        throw t.standardErrors.rpc.invalidParams("Options are required");
      if (!(R != null && R.options.address))
        throw t.standardErrors.rpc.invalidParams("Address is required");
      const S = this.getChainId(), { address: I, symbol: T, image: q, decimals: D } = R.options;
      return { jsonrpc: "2.0", id: 0, result: await this.watchAsset(R.type, I, T, D, q, S) };
    }
    _eth_uninstallFilter(a) {
      const R = (0, p.ensureHexString)(a[0]);
      return this._filterPolyfill.uninstallFilter(R);
    }
    async _eth_newFilter(a) {
      const R = a[0];
      return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newFilter(R) };
    }
    async _eth_newBlockFilter() {
      return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newBlockFilter() };
    }
    async _eth_newPendingTransactionFilter() {
      return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newPendingTransactionFilter() };
    }
    _eth_getFilterChanges(a) {
      const R = (0, p.ensureHexString)(a[0]);
      return this._filterPolyfill.getFilterChanges(R);
    }
    _eth_getFilterLogs(a) {
      const R = (0, p.ensureHexString)(a[0]);
      return this._filterPolyfill.getFilterLogs(R);
    }
    initializeRelay() {
      return this._relay ? Promise.resolve(this._relay) : this._relayProvider().then((a) => (a.setAccountsCallback((R, S) => this._setAddresses(R, S)), a.setChainCallback((R, S) => {
        this.updateProviderInfo(S, parseInt(R, 10));
      }), a.setDappDefaultChainCallback(this._chainIdFromOpts), this._relay = a, a));
    }
  };
  return Dt.CoinbaseWalletProvider = b, Dt;
}
var jr = {}, Pc;
function Af() {
  if (Pc) return jr;
  Pc = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.RelayEventManager = void 0;
  const e = /* @__PURE__ */ tt();
  let r = class {
    constructor() {
      this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
    }
    makeRequestId() {
      this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
      const t = this._nextRequestId, p = (0, e.prepend0x)(t.toString(16));
      return this.callbacks.get(p) && this.callbacks.delete(p), t;
    }
  };
  return jr.RelayEventManager = r, jr;
}
var Oc;
function Fc() {
  if (Oc) return tr;
  Oc = 1, Object.defineProperty(tr, "__esModule", { value: !0 }), tr.CoinbaseWalletSDK = void 0;
  const e = /* @__PURE__ */ Ll(), r = /* @__PURE__ */ Bl(), i = /* @__PURE__ */ tt(), t = /* @__PURE__ */ Fl(), p = /* @__PURE__ */ Ts(), n = /* @__PURE__ */ Gc(), u = /* @__PURE__ */ Jc(), o = /* @__PURE__ */ Af(), d = /* @__PURE__ */ Vc(), m = /* @__PURE__ */ zc(), g = /* @__PURE__ */ Ps();
  let c = class Ml {
    /**
     * Constructor
     * @param options Coinbase Wallet SDK constructor options
     */
    constructor(s) {
      var f, b, v;
      this._appName = "", this._appLogoUrl = null, this._relay = null, this._relayEventManager = null;
      const a = s.linkAPIUrl || r.LINK_API_URL;
      typeof s.overrideIsMetaMask > "u" ? this._overrideIsMetaMask = !1 : this._overrideIsMetaMask = s.overrideIsMetaMask, this._overrideIsCoinbaseWallet = (f = s.overrideIsCoinbaseWallet) !== null && f !== void 0 ? f : !0, this._overrideIsCoinbaseBrowser = (b = s.overrideIsCoinbaseBrowser) !== null && b !== void 0 ? b : !1, this._diagnosticLogger = s.diagnosticLogger, this._reloadOnDisconnect = (v = s.reloadOnDisconnect) !== null && v !== void 0 ? v : !0;
      const R = new URL(a), S = `${R.protocol}//${R.host}`;
      if (this._storage = new t.ScopedLocalStorage(`-walletlink:${S}`), this._storage.setItem("version", Ml.VERSION), this.walletExtension || this.coinbaseBrowser)
        return;
      this._relayEventManager = new o.RelayEventManager();
      const I = (0, i.isMobileWeb)(), T = s.uiConstructor || ((D) => I ? new u.MobileRelayUI(D) : new d.WalletLinkRelayUI(D)), q = {
        linkAPIUrl: a,
        version: g.LIB_VERSION,
        darkMode: !!s.darkMode,
        headlessMode: !!s.headlessMode,
        uiConstructor: T,
        storage: this._storage,
        relayEventManager: this._relayEventManager,
        diagnosticLogger: this._diagnosticLogger,
        reloadOnDisconnect: this._reloadOnDisconnect,
        enableMobileWalletLink: s.enableMobileWalletLink
      };
      this._relay = I ? new n.MobileRelay(q) : new m.WalletLinkRelay(q), this.setAppInfo(s.appName, s.appLogoUrl), !s.headlessMode && this._relay.attachUI();
    }
    /**
     * Create a Web3 Provider object
     * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
     * @param chainId Ethereum Chain ID (Default: 1)
     * @returns A Web3 Provider
     */
    makeWeb3Provider(s = "", f = 1) {
      const b = this.walletExtension;
      if (b)
        return this.isCipherProvider(b) || b.setProviderInfo(s, f), this._reloadOnDisconnect === !1 && typeof b.disableReloadOnDisconnect == "function" && b.disableReloadOnDisconnect(), b;
      const v = this.coinbaseBrowser;
      if (v)
        return v;
      const a = this._relay;
      if (!a || !this._relayEventManager || !this._storage)
        throw new Error("Relay not initialized, should never happen");
      return s || a.setConnectDisabled(!0), new p.CoinbaseWalletProvider({
        relayProvider: () => Promise.resolve(a),
        relayEventManager: this._relayEventManager,
        storage: this._storage,
        jsonRpcUrl: s,
        chainId: f,
        qrUrl: this.getQrUrl(),
        diagnosticLogger: this._diagnosticLogger,
        overrideIsMetaMask: this._overrideIsMetaMask,
        overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
        overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
      });
    }
    /**
     * Set application information
     * @param appName Application name
     * @param appLogoUrl Application logo image URL
     */
    setAppInfo(s, f) {
      var b;
      this._appName = s || "DApp", this._appLogoUrl = f || (0, i.getFavicon)();
      const v = this.walletExtension;
      v ? this.isCipherProvider(v) || v.setAppInfo(this._appName, this._appLogoUrl) : (b = this._relay) === null || b === void 0 || b.setAppInfo(this._appName, this._appLogoUrl);
    }
    /**
     * Disconnect. After disconnecting, this will reload the web page to ensure
     * all potential stale state is cleared.
     */
    disconnect() {
      var s;
      const f = this === null || this === void 0 ? void 0 : this.walletExtension;
      f ? f.close() : (s = this._relay) === null || s === void 0 || s.resetAndReload();
    }
    /**
     * Return QR URL for mobile wallet connection, will return null if extension is installed
     */
    getQrUrl() {
      var s, f;
      return (f = (s = this._relay) === null || s === void 0 ? void 0 : s.getQRCodeUrl()) !== null && f !== void 0 ? f : null;
    }
    /**
     * Official Coinbase Wallet logo for developers to use on their frontend
     * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
     * @param width Width of the logo (Optional)
     * @returns SVG Data URI
     */
    getCoinbaseWalletLogo(s, f = 240) {
      return (0, e.walletLogo)(s, f);
    }
    get walletExtension() {
      var s;
      return (s = window.coinbaseWalletExtension) !== null && s !== void 0 ? s : window.walletLinkExtension;
    }
    get coinbaseBrowser() {
      var s, f;
      try {
        const b = (s = window.ethereum) !== null && s !== void 0 ? s : (f = window.top) === null || f === void 0 ? void 0 : f.ethereum;
        return b && "isCoinbaseBrowser" in b && b.isCoinbaseBrowser ? b : void 0;
      } catch {
        return;
      }
    }
    isCipherProvider(s) {
      return typeof s.isCipher == "boolean" && s.isCipher;
    }
  };
  return tr.CoinbaseWalletSDK = c, c.VERSION = g.LIB_VERSION, tr;
}
var Dc;
function Tf() {
  return Dc || (Dc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CoinbaseWalletProvider = e.CoinbaseWalletSDK = void 0;
    const r = /* @__PURE__ */ Fc(), i = /* @__PURE__ */ Ts();
    var t = /* @__PURE__ */ Fc();
    Object.defineProperty(e, "CoinbaseWalletSDK", { enumerable: !0, get: function() {
      return t.CoinbaseWalletSDK;
    } });
    var p = /* @__PURE__ */ Ts();
    Object.defineProperty(e, "CoinbaseWalletProvider", { enumerable: !0, get: function() {
      return p.CoinbaseWalletProvider;
    } }), e.default = r.CoinbaseWalletSDK, typeof window < "u" && (window.CoinbaseWalletSDK = r.CoinbaseWalletSDK, window.CoinbaseWalletProvider = i.CoinbaseWalletProvider, window.WalletLink = r.CoinbaseWalletSDK, window.WalletLinkProvider = i.CoinbaseWalletProvider);
  }(In)), In;
}
var Lf = /* @__PURE__ */ Tf();
const Bf = /* @__PURE__ */ xl(Lf), n0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Bf
}, Symbol.toStringTag, { value: "Module" }));
export {
  n0 as i
};
