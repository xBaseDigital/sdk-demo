import { h as $r, t as Zt, u as Ll, v as Bl, o as Nl } from "./index-Bw1j4Goj.js";
import { r as Ps, a as Qe } from "./inherits_browser-C5Z1JwyD.js";
import { p as Pl, h as Ol } from "./hooks.module-C3CSZ0PZ.js";
import { r as dn } from "./events-BCEOhv4q.js";
var xn = {}, tr = {}, rr = {}, oo;
function Fl() {
  if (oo) return rr;
  oo = 1, Object.defineProperty(rr, "__esModule", { value: !0 }), rr.walletLogo = void 0;
  const e = (r, n) => {
    let t;
    switch (r) {
      case "standard":
        return t = n, `data:image/svg+xml,%3Csvg width='${n}' height='${t}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
      case "circle":
        return t = n, `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='${n}' height='${t}' viewBox='0 0 999.81 999.81'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052fe;%7D.cls-2%7Bfill:%23fefefe;%7D.cls-3%7Bfill:%230152fe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M655-115.9h56c.83,1.59,2.36.88,3.56,1a478,478,0,0,1,75.06,10.42C891.4-81.76,978.33-32.58,1049.19,44q116.7,126,131.94,297.61c.38,4.14-.34,8.53,1.78,12.45v59c-1.58.84-.91,2.35-1,3.56a482.05,482.05,0,0,1-10.38,74.05c-24,106.72-76.64,196.76-158.83,268.93s-178.18,112.82-287.2,122.6c-4.83.43-9.86-.25-14.51,1.77H654c-1-1.68-2.69-.91-4.06-1a496.89,496.89,0,0,1-105.9-18.59c-93.54-27.42-172.78-77.59-236.91-150.94Q199.34,590.1,184.87,426.58c-.47-5.19.25-10.56-1.77-15.59V355c1.68-1,.91-2.7,1-4.06a498.12,498.12,0,0,1,18.58-105.9c26-88.75,72.64-164.9,140.6-227.57q126-116.27,297.21-131.61C645.32-114.57,650.35-113.88,655-115.9Zm377.92,500c0-192.44-156.31-349.49-347.56-350.15-194.13-.68-350.94,155.13-352.29,347.42-1.37,194.55,155.51,352.1,348.56,352.47C876.15,734.23,1032.93,577.84,1032.93,384.11Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-2' d='M1032.93,384.11c0,193.73-156.78,350.12-351.29,349.74-193-.37-349.93-157.92-348.56-352.47C334.43,189.09,491.24,33.28,685.37,34,876.62,34.62,1032.94,191.67,1032.93,384.11ZM683,496.81q43.74,0,87.48,0c15.55,0,25.32-9.72,25.33-25.21q0-87.48,0-175c0-15.83-9.68-25.46-25.59-25.46H595.77c-15.88,0-25.57,9.64-25.58,25.46q0,87.23,0,174.45c0,16.18,9.59,25.7,25.84,25.71Z' transform='translate(-183.1 115.9)'/%3E%3Cpath class='cls-3' d='M683,496.81H596c-16.25,0-25.84-9.53-25.84-25.71q0-87.23,0-174.45c0-15.82,9.7-25.46,25.58-25.46H770.22c15.91,0,25.59,9.63,25.59,25.46q0,87.47,0,175c0,15.49-9.78,25.2-25.33,25.21Q726.74,496.84,683,496.81Z' transform='translate(-183.1 115.9)'/%3E%3C/svg%3E`;
      case "text":
        return t = (0.1 * n).toFixed(2), `data:image/svg+xml,%3Csvg width='${n}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
      case "textWithLogo":
        return t = (0.25 * n).toFixed(2), `data:image/svg+xml,%3Csvg width='${n}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%230052ff;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
      case "textLight":
        return t = (0.1 * n).toFixed(2), `data:image/svg+xml,%3Csvg width='${n}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 528.15 53.64'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Ctitle%3ECoinbase_Wordmark_SubBrands_ALL%3C/title%3E%3Cpath class='cls-1' d='M164.45,15a15,15,0,0,0-11.74,5.4V0h-8.64V52.92h8.5V48a15,15,0,0,0,11.88,5.62c10.37,0,18.21-8.21,18.21-19.3S174.67,15,164.45,15Zm-1.3,30.67c-6.19,0-10.73-4.83-10.73-11.31S157,23,163.22,23s10.66,4.82,10.66,11.37S169.34,45.65,163.15,45.65Zm83.31-14.91-6.34-.93c-3-.43-5.18-1.44-5.18-3.82,0-2.59,2.8-3.89,6.62-3.89,4.18,0,6.84,1.8,7.42,4.76h8.35c-.94-7.49-6.7-11.88-15.55-11.88-9.15,0-15.2,4.68-15.2,11.3,0,6.34,4,10,12,11.16l6.33.94c3.1.43,4.83,1.65,4.83,4,0,2.95-3,4.17-7.2,4.17-5.12,0-8-2.09-8.43-5.25h-8.49c.79,7.27,6.48,12.38,16.84,12.38,9.44,0,15.7-4.32,15.7-11.74C258.12,35.28,253.58,31.82,246.46,30.74Zm-27.65-2.3c0-8.06-4.9-13.46-15.27-13.46-9.79,0-15.26,5-16.34,12.6h8.57c.43-3,2.73-5.4,7.63-5.4,4.39,0,6.55,1.94,6.55,4.32,0,3.09-4,3.88-8.85,4.39-6.63.72-14.84,3-14.84,11.66,0,6.7,5,11,12.89,11,6.19,0,10.08-2.59,12-6.7.28,3.67,3,6.05,6.84,6.05h5v-7.7h-4.25Zm-8.5,9.36c0,5-4.32,8.64-9.57,8.64-3.24,0-6-1.37-6-4.25,0-3.67,4.39-4.68,8.42-5.11s6-1.22,7.13-2.88ZM281.09,15c-11.09,0-19.23,8.35-19.23,19.36,0,11.6,8.72,19.3,19.37,19.3,9,0,16.06-5.33,17.86-12.89h-9c-1.3,3.31-4.47,5.19-8.71,5.19-5.55,0-9.72-3.46-10.66-9.51H299.3V33.12C299.3,22.46,291.53,15,281.09,15Zm-9.87,15.26c1.37-5.18,5.26-7.7,9.72-7.7,4.9,0,8.64,2.8,9.51,7.7ZM19.3,23a9.84,9.84,0,0,1,9.5,7h9.14c-1.65-8.93-9-15-18.57-15A19,19,0,0,0,0,34.34c0,11.09,8.28,19.3,19.37,19.3,9.36,0,16.85-6,18.5-15H28.8a9.75,9.75,0,0,1-9.43,7.06c-6.27,0-10.66-4.83-10.66-11.31S13,23,19.3,23Zm41.11-8A19,19,0,0,0,41,34.34c0,11.09,8.28,19.3,19.37,19.3A19,19,0,0,0,79.92,34.27C79.92,23.33,71.64,15,60.41,15Zm.07,30.67c-6.19,0-10.73-4.83-10.73-11.31S54.22,23,60.41,23s10.8,4.89,10.8,11.37S66.67,45.65,60.48,45.65ZM123.41,15c-5.62,0-9.29,2.3-11.45,5.54V15.7h-8.57V52.92H112V32.69C112,27,115.63,23,121,23c5,0,8.06,3.53,8.06,8.64V52.92h8.64V31C137.66,21.6,132.84,15,123.41,15ZM92,.36a5.36,5.36,0,0,0-5.55,5.47,5.55,5.55,0,0,0,11.09,0A5.35,5.35,0,0,0,92,.36Zm-9.72,23h5.4V52.92h8.64V15.7h-14Zm298.17-7.7L366.2,52.92H372L375.29,44H392l3.33,8.88h6L386.87,15.7ZM377,39.23l6.45-17.56h.1l6.56,17.56ZM362.66,15.7l-7.88,29h-.11l-8.14-29H341l-8,28.93h-.1l-8-28.87H319L329.82,53h5.45l8.19-29.24h.11L352,53h5.66L368.1,15.7Zm135.25,0v4.86h12.32V52.92h5.6V20.56h12.32V15.7ZM467.82,52.92h25.54V48.06H473.43v-12h18.35V31.35H473.43V20.56h19.93V15.7H467.82ZM443,15.7h-5.6V52.92h24.32V48.06H443Zm-30.45,0h-5.61V52.92h24.32V48.06H412.52Z'/%3E%3C/svg%3E`;
      case "textWithLogoLight":
        return t = (0.25 * n).toFixed(2), `data:image/svg+xml,%3Csvg width='${n}' height='${t}' xmlns='http://www.w3.org/2000/svg' viewBox='0 0 308.44 77.61'%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fefefe;%7D%3C/style%3E%3C/defs%3E%3Cpath class='cls-1' d='M142.94,20.2l-7.88,29H135l-8.15-29h-5.55l-8,28.93h-.11l-8-28.87H99.27l10.84,37.27h5.44l8.2-29.24h.1l8.41,29.24h5.66L148.39,20.2Zm17.82,0L146.48,57.42h5.82l3.28-8.88h16.65l3.34,8.88h6L167.16,20.2Zm-3.44,23.52,6.45-17.55h.11l6.56,17.55ZM278.2,20.2v4.86h12.32V57.42h5.6V25.06h12.32V20.2ZM248.11,57.42h25.54V52.55H253.71V40.61h18.35V35.85H253.71V25.06h19.94V20.2H248.11ZM223.26,20.2h-5.61V57.42H242V52.55H223.26Zm-30.46,0h-5.6V57.42h24.32V52.55H192.8Zm-154,38A19.41,19.41,0,1,1,57.92,35.57H77.47a38.81,38.81,0,1,0,0,6.47H57.92A19.39,19.39,0,0,1,38.81,58.21Z'/%3E%3C/svg%3E`;
      default:
        return t = n, `data:image/svg+xml,%3Csvg width='${n}' height='${t}' viewBox='0 0 1024 1024' fill='none' xmlns='http://www.w3.org/2000/svg'%3E %3Crect width='1024' height='1024' fill='%230052FF'/%3E %3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M152 512C152 710.823 313.177 872 512 872C710.823 872 872 710.823 872 512C872 313.177 710.823 152 512 152C313.177 152 152 313.177 152 512ZM420 396C406.745 396 396 406.745 396 420V604C396 617.255 406.745 628 420 628H604C617.255 628 628 617.255 628 604V420C628 406.745 617.255 396 604 396H420Z' fill='white'/%3E %3C/svg%3E `;
    }
  };
  return rr.walletLogo = e, rr;
}
var nr = {}, ao;
function Dl() {
  return ao || (ao = 1, Object.defineProperty(nr, "__esModule", { value: !0 }), nr.LINK_API_URL = void 0, nr.LINK_API_URL = "https://www.walletlink.org"), nr;
}
var ie = {}, hn = { exports: {} }, ql = hn.exports, uo;
function fn() {
  return uo || (uo = 1, function(e) {
    (function(r, n) {
      function t(F, h) {
        if (!F) throw new Error(h || "Assertion failed");
      }
      function g(F, h) {
        F.super_ = h;
        var E = function() {
        };
        E.prototype = h.prototype, F.prototype = new E(), F.prototype.constructor = F;
      }
      function i(F, h, E) {
        if (i.isBN(F))
          return F;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, F !== null && ((h === "le" || h === "be") && (E = h, h = 10), this._init(F || 0, h || 10, E || "be"));
      }
      typeof r == "object" ? r.exports = i : n.BN = i, i.BN = i, i.wordSize = 26;
      var c;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? c = window.Buffer : c = Ps.Buffer;
      } catch {
      }
      i.isBN = function(h) {
        return h instanceof i ? !0 : h !== null && typeof h == "object" && h.constructor.wordSize === i.wordSize && Array.isArray(h.words);
      }, i.max = function(h, E) {
        return h.cmp(E) > 0 ? h : E;
      }, i.min = function(h, E) {
        return h.cmp(E) < 0 ? h : E;
      }, i.prototype._init = function(h, E, C) {
        if (typeof h == "number")
          return this._initNumber(h, E, C);
        if (typeof h == "object")
          return this._initArray(h, E, C);
        E === "hex" && (E = 16), t(E === (E | 0) && E >= 2 && E <= 36), h = h.toString().replace(/\s+/g, "");
        var M = 0;
        h[0] === "-" && (M++, this.negative = 1), M < h.length && (E === 16 ? this._parseHex(h, M, C) : (this._parseBase(h, E, M), C === "le" && this._initArray(this.toArray(), E, C)));
      }, i.prototype._initNumber = function(h, E, C) {
        h < 0 && (this.negative = 1, h = -h), h < 67108864 ? (this.words = [h & 67108863], this.length = 1) : h < 4503599627370496 ? (this.words = [
          h & 67108863,
          h / 67108864 & 67108863
        ], this.length = 2) : (t(h < 9007199254740992), this.words = [
          h & 67108863,
          h / 67108864 & 67108863,
          1
        ], this.length = 3), C === "le" && this._initArray(this.toArray(), E, C);
      }, i.prototype._initArray = function(h, E, C) {
        if (t(typeof h.length == "number"), h.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(h.length / 3), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var x, B, j = 0;
        if (C === "be")
          for (M = h.length - 1, x = 0; M >= 0; M -= 3)
            B = h[M] | h[M - 1] << 8 | h[M - 2] << 16, this.words[x] |= B << j & 67108863, this.words[x + 1] = B >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, x++);
        else if (C === "le")
          for (M = 0, x = 0; M < h.length; M += 3)
            B = h[M] | h[M + 1] << 8 | h[M + 2] << 16, this.words[x] |= B << j & 67108863, this.words[x + 1] = B >>> 26 - j & 67108863, j += 24, j >= 26 && (j -= 26, x++);
        return this._strip();
      };
      function a(F, h) {
        var E = F.charCodeAt(h);
        if (E >= 48 && E <= 57)
          return E - 48;
        if (E >= 65 && E <= 70)
          return E - 55;
        if (E >= 97 && E <= 102)
          return E - 87;
        t(!1, "Invalid character in " + F);
      }
      function d(F, h, E) {
        var C = a(F, E);
        return E - 1 >= h && (C |= a(F, E - 1) << 4), C;
      }
      i.prototype._parseHex = function(h, E, C) {
        this.length = Math.ceil((h.length - E) / 6), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var x = 0, B = 0, j;
        if (C === "be")
          for (M = h.length - 1; M >= E; M -= 2)
            j = d(h, E, M) << x, this.words[B] |= j & 67108863, x >= 18 ? (x -= 18, B += 1, this.words[B] |= j >>> 26) : x += 8;
        else {
          var A = h.length - E;
          for (M = A % 2 === 0 ? E + 1 : E; M < h.length; M += 2)
            j = d(h, E, M) << x, this.words[B] |= j & 67108863, x >= 18 ? (x -= 18, B += 1, this.words[B] |= j >>> 26) : x += 8;
        }
        this._strip();
      };
      function m(F, h, E, C) {
        for (var M = 0, x = 0, B = Math.min(F.length, E), j = h; j < B; j++) {
          var A = F.charCodeAt(j) - 48;
          M *= C, A >= 49 ? x = A - 49 + 10 : A >= 17 ? x = A - 17 + 10 : x = A, t(A >= 0 && x < C, "Invalid character"), M += x;
        }
        return M;
      }
      i.prototype._parseBase = function(h, E, C) {
        this.words = [0], this.length = 1;
        for (var M = 0, x = 1; x <= 67108863; x *= E)
          M++;
        M--, x = x / E | 0;
        for (var B = h.length - C, j = B % M, A = Math.min(B, B - j) + C, v = 0, N = C; N < A; N += M)
          v = m(h, N, N + M, E), this.imuln(x), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
        if (j !== 0) {
          var te = 1;
          for (v = m(h, N, h.length, E), N = 0; N < j; N++)
            te *= E;
          this.imuln(te), this.words[0] + v < 67108864 ? this.words[0] += v : this._iaddn(v);
        }
        this._strip();
      }, i.prototype.copy = function(h) {
        h.words = new Array(this.length);
        for (var E = 0; E < this.length; E++)
          h.words[E] = this.words[E];
        h.length = this.length, h.negative = this.negative, h.red = this.red;
      };
      function p(F, h) {
        F.words = h.words, F.length = h.length, F.negative = h.negative, F.red = h.red;
      }
      if (i.prototype._move = function(h) {
        p(h, this);
      }, i.prototype.clone = function() {
        var h = new i(null);
        return this.copy(h), h;
      }, i.prototype._expand = function(h) {
        for (; this.length < h; )
          this.words[this.length++] = 0;
        return this;
      }, i.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, i.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          i.prototype[Symbol.for("nodejs.util.inspect.custom")] = o;
        } catch {
          i.prototype.inspect = o;
        }
      else
        i.prototype.inspect = o;
      function o() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var l = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], s = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], f = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      i.prototype.toString = function(h, E) {
        h = h || 10, E = E | 0 || 1;
        var C;
        if (h === 16 || h === "hex") {
          C = "";
          for (var M = 0, x = 0, B = 0; B < this.length; B++) {
            var j = this.words[B], A = ((j << M | x) & 16777215).toString(16);
            x = j >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, B--), x !== 0 || B !== this.length - 1 ? C = l[6 - A.length] + A + C : C = A + C;
          }
          for (x !== 0 && (C = x.toString(16) + C); C.length % E !== 0; )
            C = "0" + C;
          return this.negative !== 0 && (C = "-" + C), C;
        }
        if (h === (h | 0) && h >= 2 && h <= 36) {
          var v = s[h], N = f[h];
          C = "";
          var te = this.clone();
          for (te.negative = 0; !te.isZero(); ) {
            var K = te.modrn(N).toString(h);
            te = te.idivn(N), te.isZero() ? C = K + C : C = l[v - K.length] + K + C;
          }
          for (this.isZero() && (C = "0" + C); C.length % E !== 0; )
            C = "0" + C;
          return this.negative !== 0 && (C = "-" + C), C;
        }
        t(!1, "Base should be between 2 and 36");
      }, i.prototype.toNumber = function() {
        var h = this.words[0];
        return this.length === 2 ? h += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? h += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && t(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -h : h;
      }, i.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, c && (i.prototype.toBuffer = function(h, E) {
        return this.toArrayLike(c, h, E);
      }), i.prototype.toArray = function(h, E) {
        return this.toArrayLike(Array, h, E);
      };
      var b = function(h, E) {
        return h.allocUnsafe ? h.allocUnsafe(E) : new h(E);
      };
      i.prototype.toArrayLike = function(h, E, C) {
        this._strip();
        var M = this.byteLength(), x = C || Math.max(1, M);
        t(M <= x, "byte array longer than desired length"), t(x > 0, "Requested array length <= 0");
        var B = b(h, x), j = E === "le" ? "LE" : "BE";
        return this["_toArrayLike" + j](B, M), B;
      }, i.prototype._toArrayLikeLE = function(h, E) {
        for (var C = 0, M = 0, x = 0, B = 0; x < this.length; x++) {
          var j = this.words[x] << B | M;
          h[C++] = j & 255, C < h.length && (h[C++] = j >> 8 & 255), C < h.length && (h[C++] = j >> 16 & 255), B === 6 ? (C < h.length && (h[C++] = j >> 24 & 255), M = 0, B = 0) : (M = j >>> 24, B += 2);
        }
        if (C < h.length)
          for (h[C++] = M; C < h.length; )
            h[C++] = 0;
      }, i.prototype._toArrayLikeBE = function(h, E) {
        for (var C = h.length - 1, M = 0, x = 0, B = 0; x < this.length; x++) {
          var j = this.words[x] << B | M;
          h[C--] = j & 255, C >= 0 && (h[C--] = j >> 8 & 255), C >= 0 && (h[C--] = j >> 16 & 255), B === 6 ? (C >= 0 && (h[C--] = j >> 24 & 255), M = 0, B = 0) : (M = j >>> 24, B += 2);
        }
        if (C >= 0)
          for (h[C--] = M; C >= 0; )
            h[C--] = 0;
      }, Math.clz32 ? i.prototype._countBits = function(h) {
        return 32 - Math.clz32(h);
      } : i.prototype._countBits = function(h) {
        var E = h, C = 0;
        return E >= 4096 && (C += 13, E >>>= 13), E >= 64 && (C += 7, E >>>= 7), E >= 8 && (C += 4, E >>>= 4), E >= 2 && (C += 2, E >>>= 2), C + E;
      }, i.prototype._zeroBits = function(h) {
        if (h === 0) return 26;
        var E = h, C = 0;
        return E & 8191 || (C += 13, E >>>= 13), E & 127 || (C += 7, E >>>= 7), E & 15 || (C += 4, E >>>= 4), E & 3 || (C += 2, E >>>= 2), E & 1 || C++, C;
      }, i.prototype.bitLength = function() {
        var h = this.words[this.length - 1], E = this._countBits(h);
        return (this.length - 1) * 26 + E;
      };
      function y(F) {
        for (var h = new Array(F.bitLength()), E = 0; E < h.length; E++) {
          var C = E / 26 | 0, M = E % 26;
          h[E] = F.words[C] >>> M & 1;
        }
        return h;
      }
      i.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var h = 0, E = 0; E < this.length; E++) {
          var C = this._zeroBits(this.words[E]);
          if (h += C, C !== 26) break;
        }
        return h;
      }, i.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, i.prototype.toTwos = function(h) {
        return this.negative !== 0 ? this.abs().inotn(h).iaddn(1) : this.clone();
      }, i.prototype.fromTwos = function(h) {
        return this.testn(h - 1) ? this.notn(h).iaddn(1).ineg() : this.clone();
      }, i.prototype.isNeg = function() {
        return this.negative !== 0;
      }, i.prototype.neg = function() {
        return this.clone().ineg();
      }, i.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, i.prototype.iuor = function(h) {
        for (; this.length < h.length; )
          this.words[this.length++] = 0;
        for (var E = 0; E < h.length; E++)
          this.words[E] = this.words[E] | h.words[E];
        return this._strip();
      }, i.prototype.ior = function(h) {
        return t((this.negative | h.negative) === 0), this.iuor(h);
      }, i.prototype.or = function(h) {
        return this.length > h.length ? this.clone().ior(h) : h.clone().ior(this);
      }, i.prototype.uor = function(h) {
        return this.length > h.length ? this.clone().iuor(h) : h.clone().iuor(this);
      }, i.prototype.iuand = function(h) {
        var E;
        this.length > h.length ? E = h : E = this;
        for (var C = 0; C < E.length; C++)
          this.words[C] = this.words[C] & h.words[C];
        return this.length = E.length, this._strip();
      }, i.prototype.iand = function(h) {
        return t((this.negative | h.negative) === 0), this.iuand(h);
      }, i.prototype.and = function(h) {
        return this.length > h.length ? this.clone().iand(h) : h.clone().iand(this);
      }, i.prototype.uand = function(h) {
        return this.length > h.length ? this.clone().iuand(h) : h.clone().iuand(this);
      }, i.prototype.iuxor = function(h) {
        var E, C;
        this.length > h.length ? (E = this, C = h) : (E = h, C = this);
        for (var M = 0; M < C.length; M++)
          this.words[M] = E.words[M] ^ C.words[M];
        if (this !== E)
          for (; M < E.length; M++)
            this.words[M] = E.words[M];
        return this.length = E.length, this._strip();
      }, i.prototype.ixor = function(h) {
        return t((this.negative | h.negative) === 0), this.iuxor(h);
      }, i.prototype.xor = function(h) {
        return this.length > h.length ? this.clone().ixor(h) : h.clone().ixor(this);
      }, i.prototype.uxor = function(h) {
        return this.length > h.length ? this.clone().iuxor(h) : h.clone().iuxor(this);
      }, i.prototype.inotn = function(h) {
        t(typeof h == "number" && h >= 0);
        var E = Math.ceil(h / 26) | 0, C = h % 26;
        this._expand(E), C > 0 && E--;
        for (var M = 0; M < E; M++)
          this.words[M] = ~this.words[M] & 67108863;
        return C > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - C), this._strip();
      }, i.prototype.notn = function(h) {
        return this.clone().inotn(h);
      }, i.prototype.setn = function(h, E) {
        t(typeof h == "number" && h >= 0);
        var C = h / 26 | 0, M = h % 26;
        return this._expand(C + 1), E ? this.words[C] = this.words[C] | 1 << M : this.words[C] = this.words[C] & ~(1 << M), this._strip();
      }, i.prototype.iadd = function(h) {
        var E;
        if (this.negative !== 0 && h.negative === 0)
          return this.negative = 0, E = this.isub(h), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && h.negative !== 0)
          return h.negative = 0, E = this.isub(h), h.negative = 1, E._normSign();
        var C, M;
        this.length > h.length ? (C = this, M = h) : (C = h, M = this);
        for (var x = 0, B = 0; B < M.length; B++)
          E = (C.words[B] | 0) + (M.words[B] | 0) + x, this.words[B] = E & 67108863, x = E >>> 26;
        for (; x !== 0 && B < C.length; B++)
          E = (C.words[B] | 0) + x, this.words[B] = E & 67108863, x = E >>> 26;
        if (this.length = C.length, x !== 0)
          this.words[this.length] = x, this.length++;
        else if (C !== this)
          for (; B < C.length; B++)
            this.words[B] = C.words[B];
        return this;
      }, i.prototype.add = function(h) {
        var E;
        return h.negative !== 0 && this.negative === 0 ? (h.negative = 0, E = this.sub(h), h.negative ^= 1, E) : h.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = h.sub(this), this.negative = 1, E) : this.length > h.length ? this.clone().iadd(h) : h.clone().iadd(this);
      }, i.prototype.isub = function(h) {
        if (h.negative !== 0) {
          h.negative = 0;
          var E = this.iadd(h);
          return h.negative = 1, E._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(h), this.negative = 1, this._normSign();
        var C = this.cmp(h);
        if (C === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var M, x;
        C > 0 ? (M = this, x = h) : (M = h, x = this);
        for (var B = 0, j = 0; j < x.length; j++)
          E = (M.words[j] | 0) - (x.words[j] | 0) + B, B = E >> 26, this.words[j] = E & 67108863;
        for (; B !== 0 && j < M.length; j++)
          E = (M.words[j] | 0) + B, B = E >> 26, this.words[j] = E & 67108863;
        if (B === 0 && j < M.length && M !== this)
          for (; j < M.length; j++)
            this.words[j] = M.words[j];
        return this.length = Math.max(this.length, j), M !== this && (this.negative = 1), this._strip();
      }, i.prototype.sub = function(h) {
        return this.clone().isub(h);
      };
      function u(F, h, E) {
        E.negative = h.negative ^ F.negative;
        var C = F.length + h.length | 0;
        E.length = C, C = C - 1 | 0;
        var M = F.words[0] | 0, x = h.words[0] | 0, B = M * x, j = B & 67108863, A = B / 67108864 | 0;
        E.words[0] = j;
        for (var v = 1; v < C; v++) {
          for (var N = A >>> 26, te = A & 67108863, K = Math.min(v, h.length - 1), $ = Math.max(0, v - F.length + 1); $ <= K; $++) {
            var W = v - $ | 0;
            M = F.words[W] | 0, x = h.words[$] | 0, B = M * x + te, N += B / 67108864 | 0, te = B & 67108863;
          }
          E.words[v] = te | 0, A = N | 0;
        }
        return A !== 0 ? E.words[v] = A | 0 : E.length--, E._strip();
      }
      var R = function(h, E, C) {
        var M = h.words, x = E.words, B = C.words, j = 0, A, v, N, te = M[0] | 0, K = te & 8191, $ = te >>> 13, W = M[1] | 0, J = W & 8191, ee = W >>> 13, oe = M[2] | 0, P = oe & 8191, O = oe >>> 13, Z = M[3] | 0, Q = Z & 8191, ae = Z >>> 13, le = M[4] | 0, ne = le & 8191, fe = le >>> 13, He = M[5] | 0, me = He & 8191, he = He >>> 13, ve = M[6] | 0, pe = ve & 8191, we = ve >>> 13, je = M[7] | 0, ye = je & 8191, k = je >>> 13, w = M[8] | 0, _ = w & 8191, L = w >>> 13, U = M[9] | 0, V = U & 8191, z = U >>> 13, de = x[0] | 0, ce = de & 8191, ue = de >>> 13, be = x[1] | 0, se = be & 8191, _e = be >>> 13, At = x[2] | 0, Ee = At & 8191, Re = At >>> 13, Tt = x[3] | 0, Se = Tt & 8191, Ce = Tt >>> 13, Lt = x[4] | 0, Me = Lt & 8191, ke = Lt >>> 13, Bt = x[5] | 0, Ie = Bt & 8191, xe = Bt >>> 13, Nt = x[6] | 0, Ae = Nt & 8191, Te = Nt >>> 13, Pt = x[7] | 0, Le = Pt & 8191, Be = Pt >>> 13, Ot = x[8] | 0, Ne = Ot & 8191, Pe = Ot >>> 13, Ft = x[9] | 0, Oe = Ft & 8191, Fe = Ft >>> 13;
        C.negative = h.negative ^ E.negative, C.length = 19, A = Math.imul(K, ce), v = Math.imul(K, ue), v = v + Math.imul($, ce) | 0, N = Math.imul($, ue);
        var at = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (at >>> 26) | 0, at &= 67108863, A = Math.imul(J, ce), v = Math.imul(J, ue), v = v + Math.imul(ee, ce) | 0, N = Math.imul(ee, ue), A = A + Math.imul(K, se) | 0, v = v + Math.imul(K, _e) | 0, v = v + Math.imul($, se) | 0, N = N + Math.imul($, _e) | 0;
        var ut = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (ut >>> 26) | 0, ut &= 67108863, A = Math.imul(P, ce), v = Math.imul(P, ue), v = v + Math.imul(O, ce) | 0, N = Math.imul(O, ue), A = A + Math.imul(J, se) | 0, v = v + Math.imul(J, _e) | 0, v = v + Math.imul(ee, se) | 0, N = N + Math.imul(ee, _e) | 0, A = A + Math.imul(K, Ee) | 0, v = v + Math.imul(K, Re) | 0, v = v + Math.imul($, Ee) | 0, N = N + Math.imul($, Re) | 0;
        var ct = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (ct >>> 26) | 0, ct &= 67108863, A = Math.imul(Q, ce), v = Math.imul(Q, ue), v = v + Math.imul(ae, ce) | 0, N = Math.imul(ae, ue), A = A + Math.imul(P, se) | 0, v = v + Math.imul(P, _e) | 0, v = v + Math.imul(O, se) | 0, N = N + Math.imul(O, _e) | 0, A = A + Math.imul(J, Ee) | 0, v = v + Math.imul(J, Re) | 0, v = v + Math.imul(ee, Ee) | 0, N = N + Math.imul(ee, Re) | 0, A = A + Math.imul(K, Se) | 0, v = v + Math.imul(K, Ce) | 0, v = v + Math.imul($, Se) | 0, N = N + Math.imul($, Ce) | 0;
        var lt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (lt >>> 26) | 0, lt &= 67108863, A = Math.imul(ne, ce), v = Math.imul(ne, ue), v = v + Math.imul(fe, ce) | 0, N = Math.imul(fe, ue), A = A + Math.imul(Q, se) | 0, v = v + Math.imul(Q, _e) | 0, v = v + Math.imul(ae, se) | 0, N = N + Math.imul(ae, _e) | 0, A = A + Math.imul(P, Ee) | 0, v = v + Math.imul(P, Re) | 0, v = v + Math.imul(O, Ee) | 0, N = N + Math.imul(O, Re) | 0, A = A + Math.imul(J, Se) | 0, v = v + Math.imul(J, Ce) | 0, v = v + Math.imul(ee, Se) | 0, N = N + Math.imul(ee, Ce) | 0, A = A + Math.imul(K, Me) | 0, v = v + Math.imul(K, ke) | 0, v = v + Math.imul($, Me) | 0, N = N + Math.imul($, ke) | 0;
        var ht = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (ht >>> 26) | 0, ht &= 67108863, A = Math.imul(me, ce), v = Math.imul(me, ue), v = v + Math.imul(he, ce) | 0, N = Math.imul(he, ue), A = A + Math.imul(ne, se) | 0, v = v + Math.imul(ne, _e) | 0, v = v + Math.imul(fe, se) | 0, N = N + Math.imul(fe, _e) | 0, A = A + Math.imul(Q, Ee) | 0, v = v + Math.imul(Q, Re) | 0, v = v + Math.imul(ae, Ee) | 0, N = N + Math.imul(ae, Re) | 0, A = A + Math.imul(P, Se) | 0, v = v + Math.imul(P, Ce) | 0, v = v + Math.imul(O, Se) | 0, N = N + Math.imul(O, Ce) | 0, A = A + Math.imul(J, Me) | 0, v = v + Math.imul(J, ke) | 0, v = v + Math.imul(ee, Me) | 0, N = N + Math.imul(ee, ke) | 0, A = A + Math.imul(K, Ie) | 0, v = v + Math.imul(K, xe) | 0, v = v + Math.imul($, Ie) | 0, N = N + Math.imul($, xe) | 0;
        var dt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (dt >>> 26) | 0, dt &= 67108863, A = Math.imul(pe, ce), v = Math.imul(pe, ue), v = v + Math.imul(we, ce) | 0, N = Math.imul(we, ue), A = A + Math.imul(me, se) | 0, v = v + Math.imul(me, _e) | 0, v = v + Math.imul(he, se) | 0, N = N + Math.imul(he, _e) | 0, A = A + Math.imul(ne, Ee) | 0, v = v + Math.imul(ne, Re) | 0, v = v + Math.imul(fe, Ee) | 0, N = N + Math.imul(fe, Re) | 0, A = A + Math.imul(Q, Se) | 0, v = v + Math.imul(Q, Ce) | 0, v = v + Math.imul(ae, Se) | 0, N = N + Math.imul(ae, Ce) | 0, A = A + Math.imul(P, Me) | 0, v = v + Math.imul(P, ke) | 0, v = v + Math.imul(O, Me) | 0, N = N + Math.imul(O, ke) | 0, A = A + Math.imul(J, Ie) | 0, v = v + Math.imul(J, xe) | 0, v = v + Math.imul(ee, Ie) | 0, N = N + Math.imul(ee, xe) | 0, A = A + Math.imul(K, Ae) | 0, v = v + Math.imul(K, Te) | 0, v = v + Math.imul($, Ae) | 0, N = N + Math.imul($, Te) | 0;
        var ft = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (ft >>> 26) | 0, ft &= 67108863, A = Math.imul(ye, ce), v = Math.imul(ye, ue), v = v + Math.imul(k, ce) | 0, N = Math.imul(k, ue), A = A + Math.imul(pe, se) | 0, v = v + Math.imul(pe, _e) | 0, v = v + Math.imul(we, se) | 0, N = N + Math.imul(we, _e) | 0, A = A + Math.imul(me, Ee) | 0, v = v + Math.imul(me, Re) | 0, v = v + Math.imul(he, Ee) | 0, N = N + Math.imul(he, Re) | 0, A = A + Math.imul(ne, Se) | 0, v = v + Math.imul(ne, Ce) | 0, v = v + Math.imul(fe, Se) | 0, N = N + Math.imul(fe, Ce) | 0, A = A + Math.imul(Q, Me) | 0, v = v + Math.imul(Q, ke) | 0, v = v + Math.imul(ae, Me) | 0, N = N + Math.imul(ae, ke) | 0, A = A + Math.imul(P, Ie) | 0, v = v + Math.imul(P, xe) | 0, v = v + Math.imul(O, Ie) | 0, N = N + Math.imul(O, xe) | 0, A = A + Math.imul(J, Ae) | 0, v = v + Math.imul(J, Te) | 0, v = v + Math.imul(ee, Ae) | 0, N = N + Math.imul(ee, Te) | 0, A = A + Math.imul(K, Le) | 0, v = v + Math.imul(K, Be) | 0, v = v + Math.imul($, Le) | 0, N = N + Math.imul($, Be) | 0;
        var pt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (pt >>> 26) | 0, pt &= 67108863, A = Math.imul(_, ce), v = Math.imul(_, ue), v = v + Math.imul(L, ce) | 0, N = Math.imul(L, ue), A = A + Math.imul(ye, se) | 0, v = v + Math.imul(ye, _e) | 0, v = v + Math.imul(k, se) | 0, N = N + Math.imul(k, _e) | 0, A = A + Math.imul(pe, Ee) | 0, v = v + Math.imul(pe, Re) | 0, v = v + Math.imul(we, Ee) | 0, N = N + Math.imul(we, Re) | 0, A = A + Math.imul(me, Se) | 0, v = v + Math.imul(me, Ce) | 0, v = v + Math.imul(he, Se) | 0, N = N + Math.imul(he, Ce) | 0, A = A + Math.imul(ne, Me) | 0, v = v + Math.imul(ne, ke) | 0, v = v + Math.imul(fe, Me) | 0, N = N + Math.imul(fe, ke) | 0, A = A + Math.imul(Q, Ie) | 0, v = v + Math.imul(Q, xe) | 0, v = v + Math.imul(ae, Ie) | 0, N = N + Math.imul(ae, xe) | 0, A = A + Math.imul(P, Ae) | 0, v = v + Math.imul(P, Te) | 0, v = v + Math.imul(O, Ae) | 0, N = N + Math.imul(O, Te) | 0, A = A + Math.imul(J, Le) | 0, v = v + Math.imul(J, Be) | 0, v = v + Math.imul(ee, Le) | 0, N = N + Math.imul(ee, Be) | 0, A = A + Math.imul(K, Ne) | 0, v = v + Math.imul(K, Pe) | 0, v = v + Math.imul($, Ne) | 0, N = N + Math.imul($, Pe) | 0;
        var gt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, A = Math.imul(V, ce), v = Math.imul(V, ue), v = v + Math.imul(z, ce) | 0, N = Math.imul(z, ue), A = A + Math.imul(_, se) | 0, v = v + Math.imul(_, _e) | 0, v = v + Math.imul(L, se) | 0, N = N + Math.imul(L, _e) | 0, A = A + Math.imul(ye, Ee) | 0, v = v + Math.imul(ye, Re) | 0, v = v + Math.imul(k, Ee) | 0, N = N + Math.imul(k, Re) | 0, A = A + Math.imul(pe, Se) | 0, v = v + Math.imul(pe, Ce) | 0, v = v + Math.imul(we, Se) | 0, N = N + Math.imul(we, Ce) | 0, A = A + Math.imul(me, Me) | 0, v = v + Math.imul(me, ke) | 0, v = v + Math.imul(he, Me) | 0, N = N + Math.imul(he, ke) | 0, A = A + Math.imul(ne, Ie) | 0, v = v + Math.imul(ne, xe) | 0, v = v + Math.imul(fe, Ie) | 0, N = N + Math.imul(fe, xe) | 0, A = A + Math.imul(Q, Ae) | 0, v = v + Math.imul(Q, Te) | 0, v = v + Math.imul(ae, Ae) | 0, N = N + Math.imul(ae, Te) | 0, A = A + Math.imul(P, Le) | 0, v = v + Math.imul(P, Be) | 0, v = v + Math.imul(O, Le) | 0, N = N + Math.imul(O, Be) | 0, A = A + Math.imul(J, Ne) | 0, v = v + Math.imul(J, Pe) | 0, v = v + Math.imul(ee, Ne) | 0, N = N + Math.imul(ee, Pe) | 0, A = A + Math.imul(K, Oe) | 0, v = v + Math.imul(K, Fe) | 0, v = v + Math.imul($, Oe) | 0, N = N + Math.imul($, Fe) | 0;
        var mt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, A = Math.imul(V, se), v = Math.imul(V, _e), v = v + Math.imul(z, se) | 0, N = Math.imul(z, _e), A = A + Math.imul(_, Ee) | 0, v = v + Math.imul(_, Re) | 0, v = v + Math.imul(L, Ee) | 0, N = N + Math.imul(L, Re) | 0, A = A + Math.imul(ye, Se) | 0, v = v + Math.imul(ye, Ce) | 0, v = v + Math.imul(k, Se) | 0, N = N + Math.imul(k, Ce) | 0, A = A + Math.imul(pe, Me) | 0, v = v + Math.imul(pe, ke) | 0, v = v + Math.imul(we, Me) | 0, N = N + Math.imul(we, ke) | 0, A = A + Math.imul(me, Ie) | 0, v = v + Math.imul(me, xe) | 0, v = v + Math.imul(he, Ie) | 0, N = N + Math.imul(he, xe) | 0, A = A + Math.imul(ne, Ae) | 0, v = v + Math.imul(ne, Te) | 0, v = v + Math.imul(fe, Ae) | 0, N = N + Math.imul(fe, Te) | 0, A = A + Math.imul(Q, Le) | 0, v = v + Math.imul(Q, Be) | 0, v = v + Math.imul(ae, Le) | 0, N = N + Math.imul(ae, Be) | 0, A = A + Math.imul(P, Ne) | 0, v = v + Math.imul(P, Pe) | 0, v = v + Math.imul(O, Ne) | 0, N = N + Math.imul(O, Pe) | 0, A = A + Math.imul(J, Oe) | 0, v = v + Math.imul(J, Fe) | 0, v = v + Math.imul(ee, Oe) | 0, N = N + Math.imul(ee, Fe) | 0;
        var wt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, A = Math.imul(V, Ee), v = Math.imul(V, Re), v = v + Math.imul(z, Ee) | 0, N = Math.imul(z, Re), A = A + Math.imul(_, Se) | 0, v = v + Math.imul(_, Ce) | 0, v = v + Math.imul(L, Se) | 0, N = N + Math.imul(L, Ce) | 0, A = A + Math.imul(ye, Me) | 0, v = v + Math.imul(ye, ke) | 0, v = v + Math.imul(k, Me) | 0, N = N + Math.imul(k, ke) | 0, A = A + Math.imul(pe, Ie) | 0, v = v + Math.imul(pe, xe) | 0, v = v + Math.imul(we, Ie) | 0, N = N + Math.imul(we, xe) | 0, A = A + Math.imul(me, Ae) | 0, v = v + Math.imul(me, Te) | 0, v = v + Math.imul(he, Ae) | 0, N = N + Math.imul(he, Te) | 0, A = A + Math.imul(ne, Le) | 0, v = v + Math.imul(ne, Be) | 0, v = v + Math.imul(fe, Le) | 0, N = N + Math.imul(fe, Be) | 0, A = A + Math.imul(Q, Ne) | 0, v = v + Math.imul(Q, Pe) | 0, v = v + Math.imul(ae, Ne) | 0, N = N + Math.imul(ae, Pe) | 0, A = A + Math.imul(P, Oe) | 0, v = v + Math.imul(P, Fe) | 0, v = v + Math.imul(O, Oe) | 0, N = N + Math.imul(O, Fe) | 0;
        var yt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, A = Math.imul(V, Se), v = Math.imul(V, Ce), v = v + Math.imul(z, Se) | 0, N = Math.imul(z, Ce), A = A + Math.imul(_, Me) | 0, v = v + Math.imul(_, ke) | 0, v = v + Math.imul(L, Me) | 0, N = N + Math.imul(L, ke) | 0, A = A + Math.imul(ye, Ie) | 0, v = v + Math.imul(ye, xe) | 0, v = v + Math.imul(k, Ie) | 0, N = N + Math.imul(k, xe) | 0, A = A + Math.imul(pe, Ae) | 0, v = v + Math.imul(pe, Te) | 0, v = v + Math.imul(we, Ae) | 0, N = N + Math.imul(we, Te) | 0, A = A + Math.imul(me, Le) | 0, v = v + Math.imul(me, Be) | 0, v = v + Math.imul(he, Le) | 0, N = N + Math.imul(he, Be) | 0, A = A + Math.imul(ne, Ne) | 0, v = v + Math.imul(ne, Pe) | 0, v = v + Math.imul(fe, Ne) | 0, N = N + Math.imul(fe, Pe) | 0, A = A + Math.imul(Q, Oe) | 0, v = v + Math.imul(Q, Fe) | 0, v = v + Math.imul(ae, Oe) | 0, N = N + Math.imul(ae, Fe) | 0;
        var bt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (bt >>> 26) | 0, bt &= 67108863, A = Math.imul(V, Me), v = Math.imul(V, ke), v = v + Math.imul(z, Me) | 0, N = Math.imul(z, ke), A = A + Math.imul(_, Ie) | 0, v = v + Math.imul(_, xe) | 0, v = v + Math.imul(L, Ie) | 0, N = N + Math.imul(L, xe) | 0, A = A + Math.imul(ye, Ae) | 0, v = v + Math.imul(ye, Te) | 0, v = v + Math.imul(k, Ae) | 0, N = N + Math.imul(k, Te) | 0, A = A + Math.imul(pe, Le) | 0, v = v + Math.imul(pe, Be) | 0, v = v + Math.imul(we, Le) | 0, N = N + Math.imul(we, Be) | 0, A = A + Math.imul(me, Ne) | 0, v = v + Math.imul(me, Pe) | 0, v = v + Math.imul(he, Ne) | 0, N = N + Math.imul(he, Pe) | 0, A = A + Math.imul(ne, Oe) | 0, v = v + Math.imul(ne, Fe) | 0, v = v + Math.imul(fe, Oe) | 0, N = N + Math.imul(fe, Fe) | 0;
        var vt = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, A = Math.imul(V, Ie), v = Math.imul(V, xe), v = v + Math.imul(z, Ie) | 0, N = Math.imul(z, xe), A = A + Math.imul(_, Ae) | 0, v = v + Math.imul(_, Te) | 0, v = v + Math.imul(L, Ae) | 0, N = N + Math.imul(L, Te) | 0, A = A + Math.imul(ye, Le) | 0, v = v + Math.imul(ye, Be) | 0, v = v + Math.imul(k, Le) | 0, N = N + Math.imul(k, Be) | 0, A = A + Math.imul(pe, Ne) | 0, v = v + Math.imul(pe, Pe) | 0, v = v + Math.imul(we, Ne) | 0, N = N + Math.imul(we, Pe) | 0, A = A + Math.imul(me, Oe) | 0, v = v + Math.imul(me, Fe) | 0, v = v + Math.imul(he, Oe) | 0, N = N + Math.imul(he, Fe) | 0;
        var _t = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, A = Math.imul(V, Ae), v = Math.imul(V, Te), v = v + Math.imul(z, Ae) | 0, N = Math.imul(z, Te), A = A + Math.imul(_, Le) | 0, v = v + Math.imul(_, Be) | 0, v = v + Math.imul(L, Le) | 0, N = N + Math.imul(L, Be) | 0, A = A + Math.imul(ye, Ne) | 0, v = v + Math.imul(ye, Pe) | 0, v = v + Math.imul(k, Ne) | 0, N = N + Math.imul(k, Pe) | 0, A = A + Math.imul(pe, Oe) | 0, v = v + Math.imul(pe, Fe) | 0, v = v + Math.imul(we, Oe) | 0, N = N + Math.imul(we, Fe) | 0;
        var Cn = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (Cn >>> 26) | 0, Cn &= 67108863, A = Math.imul(V, Le), v = Math.imul(V, Be), v = v + Math.imul(z, Le) | 0, N = Math.imul(z, Be), A = A + Math.imul(_, Ne) | 0, v = v + Math.imul(_, Pe) | 0, v = v + Math.imul(L, Ne) | 0, N = N + Math.imul(L, Pe) | 0, A = A + Math.imul(ye, Oe) | 0, v = v + Math.imul(ye, Fe) | 0, v = v + Math.imul(k, Oe) | 0, N = N + Math.imul(k, Fe) | 0;
        var Mn = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (Mn >>> 26) | 0, Mn &= 67108863, A = Math.imul(V, Ne), v = Math.imul(V, Pe), v = v + Math.imul(z, Ne) | 0, N = Math.imul(z, Pe), A = A + Math.imul(_, Oe) | 0, v = v + Math.imul(_, Fe) | 0, v = v + Math.imul(L, Oe) | 0, N = N + Math.imul(L, Fe) | 0;
        var kn = (j + A | 0) + ((v & 8191) << 13) | 0;
        j = (N + (v >>> 13) | 0) + (kn >>> 26) | 0, kn &= 67108863, A = Math.imul(V, Oe), v = Math.imul(V, Fe), v = v + Math.imul(z, Oe) | 0, N = Math.imul(z, Fe);
        var In = (j + A | 0) + ((v & 8191) << 13) | 0;
        return j = (N + (v >>> 13) | 0) + (In >>> 26) | 0, In &= 67108863, B[0] = at, B[1] = ut, B[2] = ct, B[3] = lt, B[4] = ht, B[5] = dt, B[6] = ft, B[7] = pt, B[8] = gt, B[9] = mt, B[10] = wt, B[11] = yt, B[12] = bt, B[13] = vt, B[14] = _t, B[15] = Cn, B[16] = Mn, B[17] = kn, B[18] = In, j !== 0 && (B[19] = j, C.length++), C;
      };
      Math.imul || (R = u);
      function S(F, h, E) {
        E.negative = h.negative ^ F.negative, E.length = F.length + h.length;
        for (var C = 0, M = 0, x = 0; x < E.length - 1; x++) {
          var B = M;
          M = 0;
          for (var j = C & 67108863, A = Math.min(x, h.length - 1), v = Math.max(0, x - F.length + 1); v <= A; v++) {
            var N = x - v, te = F.words[N] | 0, K = h.words[v] | 0, $ = te * K, W = $ & 67108863;
            B = B + ($ / 67108864 | 0) | 0, W = W + j | 0, j = W & 67108863, B = B + (W >>> 26) | 0, M += B >>> 26, B &= 67108863;
          }
          E.words[x] = j, C = B, B = M;
        }
        return C !== 0 ? E.words[x] = C : E.length--, E._strip();
      }
      function I(F, h, E) {
        return S(F, h, E);
      }
      i.prototype.mulTo = function(h, E) {
        var C, M = this.length + h.length;
        return this.length === 10 && h.length === 10 ? C = R(this, h, E) : M < 63 ? C = u(this, h, E) : M < 1024 ? C = S(this, h, E) : C = I(this, h, E), C;
      }, i.prototype.mul = function(h) {
        var E = new i(null);
        return E.words = new Array(this.length + h.length), this.mulTo(h, E);
      }, i.prototype.mulf = function(h) {
        var E = new i(null);
        return E.words = new Array(this.length + h.length), I(this, h, E);
      }, i.prototype.imul = function(h) {
        return this.clone().mulTo(h, this);
      }, i.prototype.imuln = function(h) {
        var E = h < 0;
        E && (h = -h), t(typeof h == "number"), t(h < 67108864);
        for (var C = 0, M = 0; M < this.length; M++) {
          var x = (this.words[M] | 0) * h, B = (x & 67108863) + (C & 67108863);
          C >>= 26, C += x / 67108864 | 0, C += B >>> 26, this.words[M] = B & 67108863;
        }
        return C !== 0 && (this.words[M] = C, this.length++), E ? this.ineg() : this;
      }, i.prototype.muln = function(h) {
        return this.clone().imuln(h);
      }, i.prototype.sqr = function() {
        return this.mul(this);
      }, i.prototype.isqr = function() {
        return this.imul(this.clone());
      }, i.prototype.pow = function(h) {
        var E = y(h);
        if (E.length === 0) return new i(1);
        for (var C = this, M = 0; M < E.length && E[M] === 0; M++, C = C.sqr())
          ;
        if (++M < E.length)
          for (var x = C.sqr(); M < E.length; M++, x = x.sqr())
            E[M] !== 0 && (C = C.mul(x));
        return C;
      }, i.prototype.iushln = function(h) {
        t(typeof h == "number" && h >= 0);
        var E = h % 26, C = (h - E) / 26, M = 67108863 >>> 26 - E << 26 - E, x;
        if (E !== 0) {
          var B = 0;
          for (x = 0; x < this.length; x++) {
            var j = this.words[x] & M, A = (this.words[x] | 0) - j << E;
            this.words[x] = A | B, B = j >>> 26 - E;
          }
          B && (this.words[x] = B, this.length++);
        }
        if (C !== 0) {
          for (x = this.length - 1; x >= 0; x--)
            this.words[x + C] = this.words[x];
          for (x = 0; x < C; x++)
            this.words[x] = 0;
          this.length += C;
        }
        return this._strip();
      }, i.prototype.ishln = function(h) {
        return t(this.negative === 0), this.iushln(h);
      }, i.prototype.iushrn = function(h, E, C) {
        t(typeof h == "number" && h >= 0);
        var M;
        E ? M = (E - E % 26) / 26 : M = 0;
        var x = h % 26, B = Math.min((h - x) / 26, this.length), j = 67108863 ^ 67108863 >>> x << x, A = C;
        if (M -= B, M = Math.max(0, M), A) {
          for (var v = 0; v < B; v++)
            A.words[v] = this.words[v];
          A.length = B;
        }
        if (B !== 0) if (this.length > B)
          for (this.length -= B, v = 0; v < this.length; v++)
            this.words[v] = this.words[v + B];
        else
          this.words[0] = 0, this.length = 1;
        var N = 0;
        for (v = this.length - 1; v >= 0 && (N !== 0 || v >= M); v--) {
          var te = this.words[v] | 0;
          this.words[v] = N << 26 - x | te >>> x, N = te & j;
        }
        return A && N !== 0 && (A.words[A.length++] = N), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, i.prototype.ishrn = function(h, E, C) {
        return t(this.negative === 0), this.iushrn(h, E, C);
      }, i.prototype.shln = function(h) {
        return this.clone().ishln(h);
      }, i.prototype.ushln = function(h) {
        return this.clone().iushln(h);
      }, i.prototype.shrn = function(h) {
        return this.clone().ishrn(h);
      }, i.prototype.ushrn = function(h) {
        return this.clone().iushrn(h);
      }, i.prototype.testn = function(h) {
        t(typeof h == "number" && h >= 0);
        var E = h % 26, C = (h - E) / 26, M = 1 << E;
        if (this.length <= C) return !1;
        var x = this.words[C];
        return !!(x & M);
      }, i.prototype.imaskn = function(h) {
        t(typeof h == "number" && h >= 0);
        var E = h % 26, C = (h - E) / 26;
        if (t(this.negative === 0, "imaskn works only with positive numbers"), this.length <= C)
          return this;
        if (E !== 0 && C++, this.length = Math.min(C, this.length), E !== 0) {
          var M = 67108863 ^ 67108863 >>> E << E;
          this.words[this.length - 1] &= M;
        }
        return this._strip();
      }, i.prototype.maskn = function(h) {
        return this.clone().imaskn(h);
      }, i.prototype.iaddn = function(h) {
        return t(typeof h == "number"), t(h < 67108864), h < 0 ? this.isubn(-h) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= h ? (this.words[0] = h - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(h), this.negative = 1, this) : this._iaddn(h);
      }, i.prototype._iaddn = function(h) {
        this.words[0] += h;
        for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
          this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
        return this.length = Math.max(this.length, E + 1), this;
      }, i.prototype.isubn = function(h) {
        if (t(typeof h == "number"), t(h < 67108864), h < 0) return this.iaddn(-h);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(h), this.negative = 1, this;
        if (this.words[0] -= h, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var E = 0; E < this.length && this.words[E] < 0; E++)
            this.words[E] += 67108864, this.words[E + 1] -= 1;
        return this._strip();
      }, i.prototype.addn = function(h) {
        return this.clone().iaddn(h);
      }, i.prototype.subn = function(h) {
        return this.clone().isubn(h);
      }, i.prototype.iabs = function() {
        return this.negative = 0, this;
      }, i.prototype.abs = function() {
        return this.clone().iabs();
      }, i.prototype._ishlnsubmul = function(h, E, C) {
        var M = h.length + C, x;
        this._expand(M);
        var B, j = 0;
        for (x = 0; x < h.length; x++) {
          B = (this.words[x + C] | 0) + j;
          var A = (h.words[x] | 0) * E;
          B -= A & 67108863, j = (B >> 26) - (A / 67108864 | 0), this.words[x + C] = B & 67108863;
        }
        for (; x < this.length - C; x++)
          B = (this.words[x + C] | 0) + j, j = B >> 26, this.words[x + C] = B & 67108863;
        if (j === 0) return this._strip();
        for (t(j === -1), j = 0, x = 0; x < this.length; x++)
          B = -(this.words[x] | 0) + j, j = B >> 26, this.words[x] = B & 67108863;
        return this.negative = 1, this._strip();
      }, i.prototype._wordDiv = function(h, E) {
        var C = this.length - h.length, M = this.clone(), x = h, B = x.words[x.length - 1] | 0, j = this._countBits(B);
        C = 26 - j, C !== 0 && (x = x.ushln(C), M.iushln(C), B = x.words[x.length - 1] | 0);
        var A = M.length - x.length, v;
        if (E !== "mod") {
          v = new i(null), v.length = A + 1, v.words = new Array(v.length);
          for (var N = 0; N < v.length; N++)
            v.words[N] = 0;
        }
        var te = M.clone()._ishlnsubmul(x, 1, A);
        te.negative === 0 && (M = te, v && (v.words[A] = 1));
        for (var K = A - 1; K >= 0; K--) {
          var $ = (M.words[x.length + K] | 0) * 67108864 + (M.words[x.length + K - 1] | 0);
          for ($ = Math.min($ / B | 0, 67108863), M._ishlnsubmul(x, $, K); M.negative !== 0; )
            $--, M.negative = 0, M._ishlnsubmul(x, 1, K), M.isZero() || (M.negative ^= 1);
          v && (v.words[K] = $);
        }
        return v && v._strip(), M._strip(), E !== "div" && C !== 0 && M.iushrn(C), {
          div: v || null,
          mod: M
        };
      }, i.prototype.divmod = function(h, E, C) {
        if (t(!h.isZero()), this.isZero())
          return {
            div: new i(0),
            mod: new i(0)
          };
        var M, x, B;
        return this.negative !== 0 && h.negative === 0 ? (B = this.neg().divmod(h, E), E !== "mod" && (M = B.div.neg()), E !== "div" && (x = B.mod.neg(), C && x.negative !== 0 && x.iadd(h)), {
          div: M,
          mod: x
        }) : this.negative === 0 && h.negative !== 0 ? (B = this.divmod(h.neg(), E), E !== "mod" && (M = B.div.neg()), {
          div: M,
          mod: B.mod
        }) : this.negative & h.negative ? (B = this.neg().divmod(h.neg(), E), E !== "div" && (x = B.mod.neg(), C && x.negative !== 0 && x.isub(h)), {
          div: B.div,
          mod: x
        }) : h.length > this.length || this.cmp(h) < 0 ? {
          div: new i(0),
          mod: this
        } : h.length === 1 ? E === "div" ? {
          div: this.divn(h.words[0]),
          mod: null
        } : E === "mod" ? {
          div: null,
          mod: new i(this.modrn(h.words[0]))
        } : {
          div: this.divn(h.words[0]),
          mod: new i(this.modrn(h.words[0]))
        } : this._wordDiv(h, E);
      }, i.prototype.div = function(h) {
        return this.divmod(h, "div", !1).div;
      }, i.prototype.mod = function(h) {
        return this.divmod(h, "mod", !1).mod;
      }, i.prototype.umod = function(h) {
        return this.divmod(h, "mod", !0).mod;
      }, i.prototype.divRound = function(h) {
        var E = this.divmod(h);
        if (E.mod.isZero()) return E.div;
        var C = E.div.negative !== 0 ? E.mod.isub(h) : E.mod, M = h.ushrn(1), x = h.andln(1), B = C.cmp(M);
        return B < 0 || x === 1 && B === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
      }, i.prototype.modrn = function(h) {
        var E = h < 0;
        E && (h = -h), t(h <= 67108863);
        for (var C = (1 << 26) % h, M = 0, x = this.length - 1; x >= 0; x--)
          M = (C * M + (this.words[x] | 0)) % h;
        return E ? -M : M;
      }, i.prototype.modn = function(h) {
        return this.modrn(h);
      }, i.prototype.idivn = function(h) {
        var E = h < 0;
        E && (h = -h), t(h <= 67108863);
        for (var C = 0, M = this.length - 1; M >= 0; M--) {
          var x = (this.words[M] | 0) + C * 67108864;
          this.words[M] = x / h | 0, C = x % h;
        }
        return this._strip(), E ? this.ineg() : this;
      }, i.prototype.divn = function(h) {
        return this.clone().idivn(h);
      }, i.prototype.egcd = function(h) {
        t(h.negative === 0), t(!h.isZero());
        var E = this, C = h.clone();
        E.negative !== 0 ? E = E.umod(h) : E = E.clone();
        for (var M = new i(1), x = new i(0), B = new i(0), j = new i(1), A = 0; E.isEven() && C.isEven(); )
          E.iushrn(1), C.iushrn(1), ++A;
        for (var v = C.clone(), N = E.clone(); !E.isZero(); ) {
          for (var te = 0, K = 1; !(E.words[0] & K) && te < 26; ++te, K <<= 1) ;
          if (te > 0)
            for (E.iushrn(te); te-- > 0; )
              (M.isOdd() || x.isOdd()) && (M.iadd(v), x.isub(N)), M.iushrn(1), x.iushrn(1);
          for (var $ = 0, W = 1; !(C.words[0] & W) && $ < 26; ++$, W <<= 1) ;
          if ($ > 0)
            for (C.iushrn($); $-- > 0; )
              (B.isOdd() || j.isOdd()) && (B.iadd(v), j.isub(N)), B.iushrn(1), j.iushrn(1);
          E.cmp(C) >= 0 ? (E.isub(C), M.isub(B), x.isub(j)) : (C.isub(E), B.isub(M), j.isub(x));
        }
        return {
          a: B,
          b: j,
          gcd: C.iushln(A)
        };
      }, i.prototype._invmp = function(h) {
        t(h.negative === 0), t(!h.isZero());
        var E = this, C = h.clone();
        E.negative !== 0 ? E = E.umod(h) : E = E.clone();
        for (var M = new i(1), x = new i(0), B = C.clone(); E.cmpn(1) > 0 && C.cmpn(1) > 0; ) {
          for (var j = 0, A = 1; !(E.words[0] & A) && j < 26; ++j, A <<= 1) ;
          if (j > 0)
            for (E.iushrn(j); j-- > 0; )
              M.isOdd() && M.iadd(B), M.iushrn(1);
          for (var v = 0, N = 1; !(C.words[0] & N) && v < 26; ++v, N <<= 1) ;
          if (v > 0)
            for (C.iushrn(v); v-- > 0; )
              x.isOdd() && x.iadd(B), x.iushrn(1);
          E.cmp(C) >= 0 ? (E.isub(C), M.isub(x)) : (C.isub(E), x.isub(M));
        }
        var te;
        return E.cmpn(1) === 0 ? te = M : te = x, te.cmpn(0) < 0 && te.iadd(h), te;
      }, i.prototype.gcd = function(h) {
        if (this.isZero()) return h.abs();
        if (h.isZero()) return this.abs();
        var E = this.clone(), C = h.clone();
        E.negative = 0, C.negative = 0;
        for (var M = 0; E.isEven() && C.isEven(); M++)
          E.iushrn(1), C.iushrn(1);
        do {
          for (; E.isEven(); )
            E.iushrn(1);
          for (; C.isEven(); )
            C.iushrn(1);
          var x = E.cmp(C);
          if (x < 0) {
            var B = E;
            E = C, C = B;
          } else if (x === 0 || C.cmpn(1) === 0)
            break;
          E.isub(C);
        } while (!0);
        return C.iushln(M);
      }, i.prototype.invm = function(h) {
        return this.egcd(h).a.umod(h);
      }, i.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, i.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, i.prototype.andln = function(h) {
        return this.words[0] & h;
      }, i.prototype.bincn = function(h) {
        t(typeof h == "number");
        var E = h % 26, C = (h - E) / 26, M = 1 << E;
        if (this.length <= C)
          return this._expand(C + 1), this.words[C] |= M, this;
        for (var x = M, B = C; x !== 0 && B < this.length; B++) {
          var j = this.words[B] | 0;
          j += x, x = j >>> 26, j &= 67108863, this.words[B] = j;
        }
        return x !== 0 && (this.words[B] = x, this.length++), this;
      }, i.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, i.prototype.cmpn = function(h) {
        var E = h < 0;
        if (this.negative !== 0 && !E) return -1;
        if (this.negative === 0 && E) return 1;
        this._strip();
        var C;
        if (this.length > 1)
          C = 1;
        else {
          E && (h = -h), t(h <= 67108863, "Number is too big");
          var M = this.words[0] | 0;
          C = M === h ? 0 : M < h ? -1 : 1;
        }
        return this.negative !== 0 ? -C | 0 : C;
      }, i.prototype.cmp = function(h) {
        if (this.negative !== 0 && h.negative === 0) return -1;
        if (this.negative === 0 && h.negative !== 0) return 1;
        var E = this.ucmp(h);
        return this.negative !== 0 ? -E | 0 : E;
      }, i.prototype.ucmp = function(h) {
        if (this.length > h.length) return 1;
        if (this.length < h.length) return -1;
        for (var E = 0, C = this.length - 1; C >= 0; C--) {
          var M = this.words[C] | 0, x = h.words[C] | 0;
          if (M !== x) {
            M < x ? E = -1 : M > x && (E = 1);
            break;
          }
        }
        return E;
      }, i.prototype.gtn = function(h) {
        return this.cmpn(h) === 1;
      }, i.prototype.gt = function(h) {
        return this.cmp(h) === 1;
      }, i.prototype.gten = function(h) {
        return this.cmpn(h) >= 0;
      }, i.prototype.gte = function(h) {
        return this.cmp(h) >= 0;
      }, i.prototype.ltn = function(h) {
        return this.cmpn(h) === -1;
      }, i.prototype.lt = function(h) {
        return this.cmp(h) === -1;
      }, i.prototype.lten = function(h) {
        return this.cmpn(h) <= 0;
      }, i.prototype.lte = function(h) {
        return this.cmp(h) <= 0;
      }, i.prototype.eqn = function(h) {
        return this.cmpn(h) === 0;
      }, i.prototype.eq = function(h) {
        return this.cmp(h) === 0;
      }, i.red = function(h) {
        return new Y(h);
      }, i.prototype.toRed = function(h) {
        return t(!this.red, "Already a number in reduction context"), t(this.negative === 0, "red works only with positives"), h.convertTo(this)._forceRed(h);
      }, i.prototype.fromRed = function() {
        return t(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, i.prototype._forceRed = function(h) {
        return this.red = h, this;
      }, i.prototype.forceRed = function(h) {
        return t(!this.red, "Already a number in reduction context"), this._forceRed(h);
      }, i.prototype.redAdd = function(h) {
        return t(this.red, "redAdd works only with red numbers"), this.red.add(this, h);
      }, i.prototype.redIAdd = function(h) {
        return t(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, h);
      }, i.prototype.redSub = function(h) {
        return t(this.red, "redSub works only with red numbers"), this.red.sub(this, h);
      }, i.prototype.redISub = function(h) {
        return t(this.red, "redISub works only with red numbers"), this.red.isub(this, h);
      }, i.prototype.redShl = function(h) {
        return t(this.red, "redShl works only with red numbers"), this.red.shl(this, h);
      }, i.prototype.redMul = function(h) {
        return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.mul(this, h);
      }, i.prototype.redIMul = function(h) {
        return t(this.red, "redMul works only with red numbers"), this.red._verify2(this, h), this.red.imul(this, h);
      }, i.prototype.redSqr = function() {
        return t(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, i.prototype.redISqr = function() {
        return t(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, i.prototype.redSqrt = function() {
        return t(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, i.prototype.redInvm = function() {
        return t(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, i.prototype.redNeg = function() {
        return t(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, i.prototype.redPow = function(h) {
        return t(this.red && !h.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, h);
      };
      var T = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function q(F, h) {
        this.name = F, this.p = new i(h, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      q.prototype._tmp = function() {
        var h = new i(null);
        return h.words = new Array(Math.ceil(this.n / 13)), h;
      }, q.prototype.ireduce = function(h) {
        var E = h, C;
        do
          this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), C = E.bitLength();
        while (C > this.n);
        var M = C < this.n ? -1 : E.ucmp(this.p);
        return M === 0 ? (E.words[0] = 0, E.length = 1) : M > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
      }, q.prototype.split = function(h, E) {
        h.iushrn(this.n, 0, E);
      }, q.prototype.imulK = function(h) {
        return h.imul(this.k);
      };
      function D() {
        q.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      g(D, q), D.prototype.split = function(h, E) {
        for (var C = 4194303, M = Math.min(h.length, 9), x = 0; x < M; x++)
          E.words[x] = h.words[x];
        if (E.length = M, h.length <= 9) {
          h.words[0] = 0, h.length = 1;
          return;
        }
        var B = h.words[9];
        for (E.words[E.length++] = B & C, x = 10; x < h.length; x++) {
          var j = h.words[x] | 0;
          h.words[x - 10] = (j & C) << 4 | B >>> 22, B = j;
        }
        B >>>= 22, h.words[x - 10] = B, B === 0 && h.length > 10 ? h.length -= 10 : h.length -= 9;
      }, D.prototype.imulK = function(h) {
        h.words[h.length] = 0, h.words[h.length + 1] = 0, h.length += 2;
        for (var E = 0, C = 0; C < h.length; C++) {
          var M = h.words[C] | 0;
          E += M * 977, h.words[C] = E & 67108863, E = M * 64 + (E / 67108864 | 0);
        }
        return h.words[h.length - 1] === 0 && (h.length--, h.words[h.length - 1] === 0 && h.length--), h;
      };
      function H() {
        q.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      g(H, q);
      function G() {
        q.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      g(G, q);
      function X() {
        q.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      g(X, q), X.prototype.imulK = function(h) {
        for (var E = 0, C = 0; C < h.length; C++) {
          var M = (h.words[C] | 0) * 19 + E, x = M & 67108863;
          M >>>= 26, h.words[C] = x, E = M;
        }
        return E !== 0 && (h.words[h.length++] = E), h;
      }, i._prime = function(h) {
        if (T[h]) return T[h];
        var E;
        if (h === "k256")
          E = new D();
        else if (h === "p224")
          E = new H();
        else if (h === "p192")
          E = new G();
        else if (h === "p25519")
          E = new X();
        else
          throw new Error("Unknown prime " + h);
        return T[h] = E, E;
      };
      function Y(F) {
        if (typeof F == "string") {
          var h = i._prime(F);
          this.m = h.p, this.prime = h;
        } else
          t(F.gtn(1), "modulus must be greater than 1"), this.m = F, this.prime = null;
      }
      Y.prototype._verify1 = function(h) {
        t(h.negative === 0, "red works only with positives"), t(h.red, "red works only with red numbers");
      }, Y.prototype._verify2 = function(h, E) {
        t((h.negative | E.negative) === 0, "red works only with positives"), t(
          h.red && h.red === E.red,
          "red works only with red numbers"
        );
      }, Y.prototype.imod = function(h) {
        return this.prime ? this.prime.ireduce(h)._forceRed(this) : (p(h, h.umod(this.m)._forceRed(this)), h);
      }, Y.prototype.neg = function(h) {
        return h.isZero() ? h.clone() : this.m.sub(h)._forceRed(this);
      }, Y.prototype.add = function(h, E) {
        this._verify2(h, E);
        var C = h.add(E);
        return C.cmp(this.m) >= 0 && C.isub(this.m), C._forceRed(this);
      }, Y.prototype.iadd = function(h, E) {
        this._verify2(h, E);
        var C = h.iadd(E);
        return C.cmp(this.m) >= 0 && C.isub(this.m), C;
      }, Y.prototype.sub = function(h, E) {
        this._verify2(h, E);
        var C = h.sub(E);
        return C.cmpn(0) < 0 && C.iadd(this.m), C._forceRed(this);
      }, Y.prototype.isub = function(h, E) {
        this._verify2(h, E);
        var C = h.isub(E);
        return C.cmpn(0) < 0 && C.iadd(this.m), C;
      }, Y.prototype.shl = function(h, E) {
        return this._verify1(h), this.imod(h.ushln(E));
      }, Y.prototype.imul = function(h, E) {
        return this._verify2(h, E), this.imod(h.imul(E));
      }, Y.prototype.mul = function(h, E) {
        return this._verify2(h, E), this.imod(h.mul(E));
      }, Y.prototype.isqr = function(h) {
        return this.imul(h, h.clone());
      }, Y.prototype.sqr = function(h) {
        return this.mul(h, h);
      }, Y.prototype.sqrt = function(h) {
        if (h.isZero()) return h.clone();
        var E = this.m.andln(3);
        if (t(E % 2 === 1), E === 3) {
          var C = this.m.add(new i(1)).iushrn(2);
          return this.pow(h, C);
        }
        for (var M = this.m.subn(1), x = 0; !M.isZero() && M.andln(1) === 0; )
          x++, M.iushrn(1);
        t(!M.isZero());
        var B = new i(1).toRed(this), j = B.redNeg(), A = this.m.subn(1).iushrn(1), v = this.m.bitLength();
        for (v = new i(2 * v * v).toRed(this); this.pow(v, A).cmp(j) !== 0; )
          v.redIAdd(j);
        for (var N = this.pow(v, M), te = this.pow(h, M.addn(1).iushrn(1)), K = this.pow(h, M), $ = x; K.cmp(B) !== 0; ) {
          for (var W = K, J = 0; W.cmp(B) !== 0; J++)
            W = W.redSqr();
          t(J < $);
          var ee = this.pow(N, new i(1).iushln($ - J - 1));
          te = te.redMul(ee), N = ee.redSqr(), K = K.redMul(N), $ = J;
        }
        return te;
      }, Y.prototype.invm = function(h) {
        var E = h._invmp(this.m);
        return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
      }, Y.prototype.pow = function(h, E) {
        if (E.isZero()) return new i(1).toRed(this);
        if (E.cmpn(1) === 0) return h.clone();
        var C = 4, M = new Array(1 << C);
        M[0] = new i(1).toRed(this), M[1] = h;
        for (var x = 2; x < M.length; x++)
          M[x] = this.mul(M[x - 1], h);
        var B = M[0], j = 0, A = 0, v = E.bitLength() % 26;
        for (v === 0 && (v = 26), x = E.length - 1; x >= 0; x--) {
          for (var N = E.words[x], te = v - 1; te >= 0; te--) {
            var K = N >> te & 1;
            if (B !== M[0] && (B = this.sqr(B)), K === 0 && j === 0) {
              A = 0;
              continue;
            }
            j <<= 1, j |= K, A++, !(A !== C && (x !== 0 || te !== 0)) && (B = this.mul(B, M[j]), A = 0, j = 0);
          }
          v = 26;
        }
        return B;
      }, Y.prototype.convertTo = function(h) {
        var E = h.umod(this.m);
        return E === h ? E.clone() : E;
      }, Y.prototype.convertFrom = function(h) {
        var E = h.clone();
        return E.red = null, E;
      }, i.mont = function(h) {
        return new re(h);
      };
      function re(F) {
        Y.call(this, F), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      g(re, Y), re.prototype.convertTo = function(h) {
        return this.imod(h.ushln(this.shift));
      }, re.prototype.convertFrom = function(h) {
        var E = this.imod(h.mul(this.rinv));
        return E.red = null, E;
      }, re.prototype.imul = function(h, E) {
        if (h.isZero() || E.isZero())
          return h.words[0] = 0, h.length = 1, h;
        var C = h.imul(E), M = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), x = C.isub(M).iushrn(this.shift), B = x;
        return x.cmp(this.m) >= 0 ? B = x.isub(this.m) : x.cmpn(0) < 0 && (B = x.iadd(this.m)), B._forceRed(this);
      }, re.prototype.mul = function(h, E) {
        if (h.isZero() || E.isZero()) return new i(0)._forceRed(this);
        var C = h.mul(E), M = C.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), x = C.isub(M).iushrn(this.shift), B = x;
        return x.cmp(this.m) >= 0 ? B = x.isub(this.m) : x.cmpn(0) < 0 && (B = x.iadd(this.m)), B._forceRed(this);
      }, re.prototype.invm = function(h) {
        var E = this.imod(h._invmp(this.m).mul(this.r2));
        return E._forceRed(this);
      };
    })(e, ql);
  }(hn)), hn.exports;
}
var An = {}, Et = {}, co;
function pn() {
  return co || (co = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.errorValues = Et.standardErrorCodes = void 0, Et.standardErrorCodes = {
    rpc: {
      invalidInput: -32e3,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603
    },
    provider: {
      userRejectedRequest: 4001,
      unauthorized: 4100,
      unsupportedMethod: 4200,
      disconnected: 4900,
      chainDisconnected: 4901,
      unsupportedChain: 4902
    }
  }, Et.errorValues = {
    "-32700": {
      standard: "JSON RPC 2.0",
      message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
      standard: "JSON RPC 2.0",
      message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
      standard: "JSON RPC 2.0",
      message: "The method does not exist / is not available."
    },
    "-32602": {
      standard: "JSON RPC 2.0",
      message: "Invalid method parameter(s)."
    },
    "-32603": {
      standard: "JSON RPC 2.0",
      message: "Internal JSON-RPC error."
    },
    "-32000": {
      standard: "EIP-1474",
      message: "Invalid input."
    },
    "-32001": {
      standard: "EIP-1474",
      message: "Resource not found."
    },
    "-32002": {
      standard: "EIP-1474",
      message: "Resource unavailable."
    },
    "-32003": {
      standard: "EIP-1474",
      message: "Transaction rejected."
    },
    "-32004": {
      standard: "EIP-1474",
      message: "Method not supported."
    },
    "-32005": {
      standard: "EIP-1474",
      message: "Request limit exceeded."
    },
    4001: {
      standard: "EIP-1193",
      message: "User rejected the request."
    },
    4100: {
      standard: "EIP-1193",
      message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
      standard: "EIP-1193",
      message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
      standard: "EIP-1193",
      message: "The provider is disconnected from all chains."
    },
    4901: {
      standard: "EIP-1193",
      message: "The provider is disconnected from the specified chain."
    },
    4902: {
      standard: "EIP-3085",
      message: "Unrecognized chain ID."
    }
  }), Et;
}
var ir = {}, Tn = {}, lo;
function Os() {
  return lo || (lo = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.serialize = e.getErrorCode = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const r = /* @__PURE__ */ pn(), n = "Unspecified error message.";
    e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function t(l, s = n) {
      if (l && Number.isInteger(l)) {
        const f = l.toString();
        if (p(r.errorValues, f))
          return r.errorValues[f].message;
        if (d(l))
          return e.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
      return s;
    }
    e.getMessageFromCode = t;
    function g(l) {
      if (!Number.isInteger(l))
        return !1;
      const s = l.toString();
      return !!(r.errorValues[s] || d(l));
    }
    e.isValidCode = g;
    function i(l) {
      var s;
      if (typeof l == "number")
        return l;
      if (c(l))
        return (s = l.code) !== null && s !== void 0 ? s : l.errorCode;
    }
    e.getErrorCode = i;
    function c(l) {
      return typeof l == "object" && l !== null && (typeof l.code == "number" || typeof l.errorCode == "number");
    }
    function a(l, { shouldIncludeStack: s = !1 } = {}) {
      const f = {};
      if (l && typeof l == "object" && !Array.isArray(l) && p(l, "code") && g(l.code)) {
        const b = l;
        f.code = b.code, b.message && typeof b.message == "string" ? (f.message = b.message, p(b, "data") && (f.data = b.data)) : (f.message = t(f.code), f.data = { originalError: m(l) });
      } else
        f.code = r.standardErrorCodes.rpc.internal, f.message = o(l, "message") ? l.message : n, f.data = { originalError: m(l) };
      return s && (f.stack = o(l, "stack") ? l.stack : void 0), f;
    }
    e.serialize = a;
    function d(l) {
      return l >= -32099 && l <= -32e3;
    }
    function m(l) {
      return l && typeof l == "object" && !Array.isArray(l) ? Object.assign({}, l) : l;
    }
    function p(l, s) {
      return Object.prototype.hasOwnProperty.call(l, s);
    }
    function o(l, s) {
      return typeof l == "object" && l !== null && s in l && typeof l[s] == "string";
    }
  }(Tn)), Tn;
}
var ho;
function jl() {
  if (ho) return ir;
  ho = 1, Object.defineProperty(ir, "__esModule", { value: !0 }), ir.standardErrors = void 0;
  const e = /* @__PURE__ */ pn(), r = /* @__PURE__ */ Os();
  ir.standardErrors = {
    rpc: {
      parse: (d) => n(e.standardErrorCodes.rpc.parse, d),
      invalidRequest: (d) => n(e.standardErrorCodes.rpc.invalidRequest, d),
      invalidParams: (d) => n(e.standardErrorCodes.rpc.invalidParams, d),
      methodNotFound: (d) => n(e.standardErrorCodes.rpc.methodNotFound, d),
      internal: (d) => n(e.standardErrorCodes.rpc.internal, d),
      server: (d) => {
        if (!d || typeof d != "object" || Array.isArray(d))
          throw new Error("Ethereum RPC Server errors must provide single object argument.");
        const { code: m } = d;
        if (!Number.isInteger(m) || m > -32005 || m < -32099)
          throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        return n(m, d);
      },
      invalidInput: (d) => n(e.standardErrorCodes.rpc.invalidInput, d),
      resourceNotFound: (d) => n(e.standardErrorCodes.rpc.resourceNotFound, d),
      resourceUnavailable: (d) => n(e.standardErrorCodes.rpc.resourceUnavailable, d),
      transactionRejected: (d) => n(e.standardErrorCodes.rpc.transactionRejected, d),
      methodNotSupported: (d) => n(e.standardErrorCodes.rpc.methodNotSupported, d),
      limitExceeded: (d) => n(e.standardErrorCodes.rpc.limitExceeded, d)
    },
    provider: {
      userRejectedRequest: (d) => t(e.standardErrorCodes.provider.userRejectedRequest, d),
      unauthorized: (d) => t(e.standardErrorCodes.provider.unauthorized, d),
      unsupportedMethod: (d) => t(e.standardErrorCodes.provider.unsupportedMethod, d),
      disconnected: (d) => t(e.standardErrorCodes.provider.disconnected, d),
      chainDisconnected: (d) => t(e.standardErrorCodes.provider.chainDisconnected, d),
      unsupportedChain: (d) => t(e.standardErrorCodes.provider.unsupportedChain, d),
      custom: (d) => {
        if (!d || typeof d != "object" || Array.isArray(d))
          throw new Error("Ethereum Provider custom errors must provide single object argument.");
        const { code: m, message: p, data: o } = d;
        if (!p || typeof p != "string")
          throw new Error('"message" must be a nonempty string');
        return new c(m, p, o);
      }
    }
  };
  function n(d, m) {
    const [p, o] = g(m);
    return new i(d, p || (0, r.getMessageFromCode)(d), o);
  }
  function t(d, m) {
    const [p, o] = g(m);
    return new c(d, p || (0, r.getMessageFromCode)(d), o);
  }
  function g(d) {
    if (d) {
      if (typeof d == "string")
        return [d];
      if (typeof d == "object" && !Array.isArray(d)) {
        const { message: m, data: p } = d;
        if (m && typeof m != "string")
          throw new Error("Must specify string message.");
        return [m || void 0, p];
      }
    }
    return [];
  }
  class i extends Error {
    constructor(m, p, o) {
      if (!Number.isInteger(m))
        throw new Error('"code" must be an integer.');
      if (!p || typeof p != "string")
        throw new Error('"message" must be a nonempty string.');
      super(p), this.code = m, o !== void 0 && (this.data = o);
    }
  }
  class c extends i {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     * `code` must be an integer in the 1000 <= 4999 range.
     */
    constructor(m, p, o) {
      if (!a(m))
        throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
      super(m, p, o);
    }
  }
  function a(d) {
    return Number.isInteger(d) && d >= 1e3 && d <= 4999;
  }
  return ir;
}
var sr = {}, or = {}, fo;
function Fs() {
  if (fo) return or;
  fo = 1, Object.defineProperty(or, "__esModule", { value: !0 }), or.isErrorResponse = void 0;
  function e(r) {
    return r.errorMessage !== void 0;
  }
  return or.isErrorResponse = e, or;
}
var ar = {}, po;
function Ds() {
  return po || (po = 1, Object.defineProperty(ar, "__esModule", { value: !0 }), ar.LIB_VERSION = void 0, ar.LIB_VERSION = "3.9.3"), ar;
}
var go;
function $l() {
  if (go) return sr;
  go = 1, Object.defineProperty(sr, "__esModule", { value: !0 }), sr.serializeError = void 0;
  const e = /* @__PURE__ */ Fs(), r = /* @__PURE__ */ Ds(), n = /* @__PURE__ */ pn(), t = /* @__PURE__ */ Os();
  function g(a, d) {
    const m = (0, t.serialize)(i(a), {
      shouldIncludeStack: !0
    }), p = new URL("https://docs.cloud.coinbase.com/wallet-sdk/docs/errors");
    p.searchParams.set("version", r.LIB_VERSION), p.searchParams.set("code", m.code.toString());
    const o = c(m.data, d);
    return o && p.searchParams.set("method", o), p.searchParams.set("message", m.message), Object.assign(Object.assign({}, m), { docUrl: p.href });
  }
  sr.serializeError = g;
  function i(a) {
    return typeof a == "string" ? {
      message: a,
      code: n.standardErrorCodes.rpc.internal
    } : (0, e.isErrorResponse)(a) ? Object.assign(Object.assign({}, a), { message: a.errorMessage, code: a.errorCode, data: { method: a.method } }) : a;
  }
  function c(a, d) {
    const m = a == null ? void 0 : a.method;
    if (m)
      return m;
    if (d !== void 0) {
      if (typeof d == "string")
        return d;
      if (Array.isArray(d)) {
        if (d.length > 0)
          return d[0].method;
      } else return d.method;
    }
  }
  return sr;
}
var mo;
function gn() {
  return mo || (mo = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.standardErrors = e.standardErrorCodes = e.serializeError = e.getMessageFromCode = e.getErrorCode = void 0;
    const r = /* @__PURE__ */ pn();
    Object.defineProperty(e, "standardErrorCodes", { enumerable: !0, get: function() {
      return r.standardErrorCodes;
    } });
    const n = /* @__PURE__ */ jl();
    Object.defineProperty(e, "standardErrors", { enumerable: !0, get: function() {
      return n.standardErrors;
    } });
    const t = /* @__PURE__ */ $l();
    Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
      return t.serializeError;
    } });
    const g = /* @__PURE__ */ Os();
    Object.defineProperty(e, "getErrorCode", { enumerable: !0, get: function() {
      return g.getErrorCode;
    } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
      return g.getMessageFromCode;
    } });
  }(An)), An;
}
var $e = {}, wo;
function mn() {
  if (wo) return $e;
  wo = 1, Object.defineProperty($e, "__esModule", { value: !0 }), $e.ProviderType = $e.RegExpString = $e.IntNumber = $e.BigIntString = $e.AddressString = $e.HexString = $e.OpaqueType = void 0;
  function e() {
    return (t) => t;
  }
  $e.OpaqueType = e, $e.HexString = e(), $e.AddressString = e(), $e.BigIntString = e();
  function r(t) {
    return Math.floor(t);
  }
  $e.IntNumber = r, $e.RegExpString = e();
  var n;
  return function(t) {
    t.CoinbaseWallet = "CoinbaseWallet", t.MetaMask = "MetaMask", t.Unselected = "";
  }(n || ($e.ProviderType = n = {})), $e;
}
var yo;
function tt() {
  if (yo) return ie;
  yo = 1;
  var e = ie.__importDefault || function(C) {
    return C && C.__esModule ? C : { default: C };
  };
  Object.defineProperty(ie, "__esModule", { value: !0 }), ie.isMobileWeb = ie.getLocation = ie.isInIFrame = ie.createQrUrl = ie.getFavicon = ie.range = ie.isBigNumber = ie.ensureParsedJSONObject = ie.ensureBN = ie.ensureRegExpString = ie.ensureIntNumber = ie.ensureBuffer = ie.ensureAddressString = ie.ensureEvenLengthHexString = ie.ensureHexString = ie.isHexString = ie.prepend0x = ie.strip0x = ie.has0xPrefix = ie.hexStringFromIntNumber = ie.intNumberFromHexString = ie.bigIntStringFromBN = ie.hexStringFromBuffer = ie.hexStringToUint8Array = ie.uint8ArrayToHex = ie.randomBytesHex = void 0;
  const r = e(fn()), n = /* @__PURE__ */ gn(), t = /* @__PURE__ */ mn(), g = /^[0-9]*$/, i = /^[a-f0-9]*$/;
  function c(C) {
    return a(crypto.getRandomValues(new Uint8Array(C)));
  }
  ie.randomBytesHex = c;
  function a(C) {
    return [...C].map((M) => M.toString(16).padStart(2, "0")).join("");
  }
  ie.uint8ArrayToHex = a;
  function d(C) {
    return new Uint8Array(C.match(/.{1,2}/g).map((M) => parseInt(M, 16)));
  }
  ie.hexStringToUint8Array = d;
  function m(C, M = !1) {
    const x = C.toString("hex");
    return (0, t.HexString)(M ? `0x${x}` : x);
  }
  ie.hexStringFromBuffer = m;
  function p(C) {
    return (0, t.BigIntString)(C.toString(10));
  }
  ie.bigIntStringFromBN = p;
  function o(C) {
    return (0, t.IntNumber)(new r.default(R(C, !1), 16).toNumber());
  }
  ie.intNumberFromHexString = o;
  function l(C) {
    return (0, t.HexString)(`0x${new r.default(C).toString(16)}`);
  }
  ie.hexStringFromIntNumber = l;
  function s(C) {
    return C.startsWith("0x") || C.startsWith("0X");
  }
  ie.has0xPrefix = s;
  function f(C) {
    return s(C) ? C.slice(2) : C;
  }
  ie.strip0x = f;
  function b(C) {
    return s(C) ? `0x${C.slice(2)}` : `0x${C}`;
  }
  ie.prepend0x = b;
  function y(C) {
    if (typeof C != "string")
      return !1;
    const M = f(C).toLowerCase();
    return i.test(M);
  }
  ie.isHexString = y;
  function u(C, M = !1) {
    if (typeof C == "string") {
      const x = f(C).toLowerCase();
      if (i.test(x))
        return (0, t.HexString)(M ? `0x${x}` : x);
    }
    throw n.standardErrors.rpc.invalidParams(`"${String(C)}" is not a hexadecimal string`);
  }
  ie.ensureHexString = u;
  function R(C, M = !1) {
    let x = u(C, !1);
    return x.length % 2 === 1 && (x = (0, t.HexString)(`0${x}`)), M ? (0, t.HexString)(`0x${x}`) : x;
  }
  ie.ensureEvenLengthHexString = R;
  function S(C) {
    if (typeof C == "string") {
      const M = f(C).toLowerCase();
      if (y(M) && M.length === 40)
        return (0, t.AddressString)(b(M));
    }
    throw n.standardErrors.rpc.invalidParams(`Invalid Ethereum address: ${String(C)}`);
  }
  ie.ensureAddressString = S;
  function I(C) {
    if (Buffer.isBuffer(C))
      return C;
    if (typeof C == "string") {
      if (y(C)) {
        const M = R(C, !1);
        return Buffer.from(M, "hex");
      }
      return Buffer.from(C, "utf8");
    }
    throw n.standardErrors.rpc.invalidParams(`Not binary data: ${String(C)}`);
  }
  ie.ensureBuffer = I;
  function T(C) {
    if (typeof C == "number" && Number.isInteger(C))
      return (0, t.IntNumber)(C);
    if (typeof C == "string") {
      if (g.test(C))
        return (0, t.IntNumber)(Number(C));
      if (y(C))
        return (0, t.IntNumber)(new r.default(R(C, !1), 16).toNumber());
    }
    throw n.standardErrors.rpc.invalidParams(`Not an integer: ${String(C)}`);
  }
  ie.ensureIntNumber = T;
  function q(C) {
    if (C instanceof RegExp)
      return (0, t.RegExpString)(C.toString());
    throw n.standardErrors.rpc.invalidParams(`Not a RegExp: ${String(C)}`);
  }
  ie.ensureRegExpString = q;
  function D(C) {
    if (C !== null && (r.default.isBN(C) || G(C)))
      return new r.default(C.toString(10), 10);
    if (typeof C == "number")
      return new r.default(T(C));
    if (typeof C == "string") {
      if (g.test(C))
        return new r.default(C, 10);
      if (y(C))
        return new r.default(R(C, !1), 16);
    }
    throw n.standardErrors.rpc.invalidParams(`Not an integer: ${String(C)}`);
  }
  ie.ensureBN = D;
  function H(C) {
    if (typeof C == "string")
      return JSON.parse(C);
    if (typeof C == "object")
      return C;
    throw n.standardErrors.rpc.invalidParams(`Not a JSON string or an object: ${String(C)}`);
  }
  ie.ensureParsedJSONObject = H;
  function G(C) {
    if (C == null || typeof C.constructor != "function")
      return !1;
    const { constructor: M } = C;
    return typeof M.config == "function" && typeof M.EUCLID == "number";
  }
  ie.isBigNumber = G;
  function X(C, M) {
    return Array.from({ length: M - C }, (x, B) => C + B);
  }
  ie.range = X;
  function Y() {
    const C = document.querySelector('link[sizes="192x192"]') || document.querySelector('link[sizes="180x180"]') || document.querySelector('link[rel="icon"]') || document.querySelector('link[rel="shortcut icon"]'), { protocol: M, host: x } = document.location, B = C ? C.getAttribute("href") : null;
    return !B || B.startsWith("javascript:") || B.startsWith("vbscript:") ? null : B.startsWith("http://") || B.startsWith("https://") || B.startsWith("data:") ? B : B.startsWith("//") ? M + B : `${M}//${x}${B}`;
  }
  ie.getFavicon = Y;
  function re(C, M, x, B, j, A) {
    const v = B ? "parent-id" : "id", N = new URLSearchParams({
      [v]: C,
      secret: M,
      server: x,
      v: j,
      chainId: A.toString()
    }).toString();
    return `${x}/#/link?${N}`;
  }
  ie.createQrUrl = re;
  function F() {
    try {
      return window.frameElement !== null;
    } catch {
      return !1;
    }
  }
  ie.isInIFrame = F;
  function h() {
    try {
      return F() && window.top ? window.top.location : window.location;
    } catch {
      return window.location;
    }
  }
  ie.getLocation = h;
  function E() {
    var C;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test((C = window == null ? void 0 : window.navigator) === null || C === void 0 ? void 0 : C.userAgent);
  }
  return ie.isMobileWeb = E, ie;
}
var ur = {}, bo;
function Ul() {
  if (bo) return ur;
  bo = 1, Object.defineProperty(ur, "__esModule", { value: !0 }), ur.ScopedLocalStorage = void 0;
  let e = class {
    // eslint-disable-next-line no-useless-constructor
    constructor(n) {
      this.scope = n;
    }
    setItem(n, t) {
      localStorage.setItem(this.scopedKey(n), t);
    }
    getItem(n) {
      return localStorage.getItem(this.scopedKey(n));
    }
    removeItem(n) {
      localStorage.removeItem(this.scopedKey(n));
    }
    clear() {
      const n = this.scopedKey(""), t = [];
      for (let g = 0; g < localStorage.length; g++) {
        const i = localStorage.key(g);
        typeof i == "string" && i.startsWith(n) && t.push(i);
      }
      t.forEach((g) => localStorage.removeItem(g));
    }
    scopedKey(n) {
      return `${this.scope}:${n}`;
    }
  };
  return ur.ScopedLocalStorage = e, ur;
}
var Dt = {}, cr = {}, lr = {}, hr = {}, vo;
function qs() {
  return vo || (vo = 1, Object.defineProperty(hr, "__esModule", { value: !0 }), hr.EVENTS = void 0, hr.EVENTS = {
    STARTED_CONNECTING: "walletlink_sdk.started.connecting",
    CONNECTED_STATE_CHANGE: "walletlink_sdk.connected",
    DISCONNECTED: "walletlink_sdk.disconnected",
    METADATA_DESTROYED: "walletlink_sdk_metadata_destroyed",
    LINKED: "walletlink_sdk.linked",
    FAILURE: "walletlink_sdk.generic_failure",
    SESSION_CONFIG_RECEIVED: "walletlink_sdk.session_config_event_received",
    ETH_ACCOUNTS_STATE: "walletlink_sdk.eth_accounts_state",
    SESSION_STATE_CHANGE: "walletlink_sdk.session_state_change",
    UNLINKED_ERROR_STATE: "walletlink_sdk.unlinked_error_state",
    SKIPPED_CLEARING_SESSION: "walletlink_sdk.skipped_clearing_session",
    GENERAL_ERROR: "walletlink_sdk.general_error",
    WEB3_REQUEST: "walletlink_sdk.web3.request",
    WEB3_REQUEST_PUBLISHED: "walletlink_sdk.web3.request_published",
    WEB3_RESPONSE: "walletlink_sdk.web3.response",
    METHOD_NOT_IMPLEMENTED: "walletlink_sdk.method_not_implemented",
    UNKNOWN_ADDRESS_ENCOUNTERED: "walletlink_sdk.unknown_address_encountered"
  }), hr;
}
var Je = {}, _o;
function js() {
  if (_o) return Je;
  _o = 1, Object.defineProperty(Je, "__esModule", { value: !0 }), Je.RelayAbstract = Je.APP_VERSION_KEY = Je.LOCAL_STORAGE_ADDRESSES_KEY = Je.WALLET_USER_NAME_KEY = void 0;
  const e = /* @__PURE__ */ gn();
  Je.WALLET_USER_NAME_KEY = "walletUsername", Je.LOCAL_STORAGE_ADDRESSES_KEY = "Addresses", Je.APP_VERSION_KEY = "AppVersion";
  let r = class {
    async makeEthereumJSONRPCRequest(t, g) {
      if (!g)
        throw new Error("Error: No jsonRpcUrl provided");
      return window.fetch(g, {
        method: "POST",
        body: JSON.stringify(t),
        mode: "cors",
        headers: { "Content-Type": "application/json" }
      }).then((i) => i.json()).then((i) => {
        if (!i)
          throw e.standardErrors.rpc.parse({});
        const c = i, { error: a } = c;
        if (a)
          throw (0, e.serializeError)(a, t.method);
        return c;
      });
    }
  };
  return Je.RelayAbstract = r, Je;
}
var dr = {}, Ln = { exports: {} }, Jr = { exports: {} }, Bn = {}, fr = {}, Eo;
function Hl() {
  if (Eo) return fr;
  Eo = 1, fr.byteLength = a, fr.toByteArray = m, fr.fromByteArray = l;
  for (var e = [], r = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = 0, i = t.length; g < i; ++g)
    e[g] = t[g], r[t.charCodeAt(g)] = g;
  r[45] = 62, r[95] = 63;
  function c(s) {
    var f = s.length;
    if (f % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var b = s.indexOf("=");
    b === -1 && (b = f);
    var y = b === f ? 0 : 4 - b % 4;
    return [b, y];
  }
  function a(s) {
    var f = c(s), b = f[0], y = f[1];
    return (b + y) * 3 / 4 - y;
  }
  function d(s, f, b) {
    return (f + b) * 3 / 4 - b;
  }
  function m(s) {
    var f, b = c(s), y = b[0], u = b[1], R = new n(d(s, y, u)), S = 0, I = u > 0 ? y - 4 : y, T;
    for (T = 0; T < I; T += 4)
      f = r[s.charCodeAt(T)] << 18 | r[s.charCodeAt(T + 1)] << 12 | r[s.charCodeAt(T + 2)] << 6 | r[s.charCodeAt(T + 3)], R[S++] = f >> 16 & 255, R[S++] = f >> 8 & 255, R[S++] = f & 255;
    return u === 2 && (f = r[s.charCodeAt(T)] << 2 | r[s.charCodeAt(T + 1)] >> 4, R[S++] = f & 255), u === 1 && (f = r[s.charCodeAt(T)] << 10 | r[s.charCodeAt(T + 1)] << 4 | r[s.charCodeAt(T + 2)] >> 2, R[S++] = f >> 8 & 255, R[S++] = f & 255), R;
  }
  function p(s) {
    return e[s >> 18 & 63] + e[s >> 12 & 63] + e[s >> 6 & 63] + e[s & 63];
  }
  function o(s, f, b) {
    for (var y, u = [], R = f; R < b; R += 3)
      y = (s[R] << 16 & 16711680) + (s[R + 1] << 8 & 65280) + (s[R + 2] & 255), u.push(p(y));
    return u.join("");
  }
  function l(s) {
    for (var f, b = s.length, y = b % 3, u = [], R = 16383, S = 0, I = b - y; S < I; S += R)
      u.push(o(s, S, S + R > I ? I : S + R));
    return y === 1 ? (f = s[b - 1], u.push(
      e[f >> 2] + e[f << 4 & 63] + "=="
    )) : y === 2 && (f = (s[b - 2] << 8) + s[b - 1], u.push(
      e[f >> 10] + e[f >> 4 & 63] + e[f << 2 & 63] + "="
    )), u.join("");
  }
  return fr;
}
var Gr = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Ro;
function Wl() {
  return Ro || (Ro = 1, Gr.read = function(e, r, n, t, g) {
    var i, c, a = g * 8 - t - 1, d = (1 << a) - 1, m = d >> 1, p = -7, o = n ? g - 1 : 0, l = n ? -1 : 1, s = e[r + o];
    for (o += l, i = s & (1 << -p) - 1, s >>= -p, p += a; p > 0; i = i * 256 + e[r + o], o += l, p -= 8)
      ;
    for (c = i & (1 << -p) - 1, i >>= -p, p += t; p > 0; c = c * 256 + e[r + o], o += l, p -= 8)
      ;
    if (i === 0)
      i = 1 - m;
    else {
      if (i === d)
        return c ? NaN : (s ? -1 : 1) * (1 / 0);
      c = c + Math.pow(2, t), i = i - m;
    }
    return (s ? -1 : 1) * c * Math.pow(2, i - t);
  }, Gr.write = function(e, r, n, t, g, i) {
    var c, a, d, m = i * 8 - g - 1, p = (1 << m) - 1, o = p >> 1, l = g === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, s = t ? 0 : i - 1, f = t ? 1 : -1, b = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
    for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (a = isNaN(r) ? 1 : 0, c = p) : (c = Math.floor(Math.log(r) / Math.LN2), r * (d = Math.pow(2, -c)) < 1 && (c--, d *= 2), c + o >= 1 ? r += l / d : r += l * Math.pow(2, 1 - o), r * d >= 2 && (c++, d /= 2), c + o >= p ? (a = 0, c = p) : c + o >= 1 ? (a = (r * d - 1) * Math.pow(2, g), c = c + o) : (a = r * Math.pow(2, o - 1) * Math.pow(2, g), c = 0)); g >= 8; e[n + s] = a & 255, s += f, a /= 256, g -= 8)
      ;
    for (c = c << g | a, m += g; m > 0; e[n + s] = c & 255, s += f, c /= 256, m -= 8)
      ;
    e[n + s - f] |= b * 128;
  }), Gr;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var So;
function wn() {
  return So || (So = 1, function(e) {
    const r = Hl(), n = Wl(), t = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = a, e.SlowBuffer = R, e.INSPECT_MAX_BYTES = 50;
    const g = 2147483647;
    e.kMaxLength = g, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function i() {
      try {
        const k = new Uint8Array(1), w = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(w, Uint8Array.prototype), Object.setPrototypeOf(k, w), k.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(a.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (a.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(a.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (a.isBuffer(this))
          return this.byteOffset;
      }
    });
    function c(k) {
      if (k > g)
        throw new RangeError('The value "' + k + '" is invalid for option "size"');
      const w = new Uint8Array(k);
      return Object.setPrototypeOf(w, a.prototype), w;
    }
    function a(k, w, _) {
      if (typeof k == "number") {
        if (typeof w == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return o(k);
      }
      return d(k, w, _);
    }
    a.poolSize = 8192;
    function d(k, w, _) {
      if (typeof k == "string")
        return l(k, w);
      if (ArrayBuffer.isView(k))
        return f(k);
      if (k == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof k
        );
      if (ve(k, ArrayBuffer) || k && ve(k.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ve(k, SharedArrayBuffer) || k && ve(k.buffer, SharedArrayBuffer)))
        return b(k, w, _);
      if (typeof k == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const L = k.valueOf && k.valueOf();
      if (L != null && L !== k)
        return a.from(L, w, _);
      const U = y(k);
      if (U) return U;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof k[Symbol.toPrimitive] == "function")
        return a.from(k[Symbol.toPrimitive]("string"), w, _);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof k
      );
    }
    a.from = function(k, w, _) {
      return d(k, w, _);
    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);
    function m(k) {
      if (typeof k != "number")
        throw new TypeError('"size" argument must be of type number');
      if (k < 0)
        throw new RangeError('The value "' + k + '" is invalid for option "size"');
    }
    function p(k, w, _) {
      return m(k), k <= 0 ? c(k) : w !== void 0 ? typeof _ == "string" ? c(k).fill(w, _) : c(k).fill(w) : c(k);
    }
    a.alloc = function(k, w, _) {
      return p(k, w, _);
    };
    function o(k) {
      return m(k), c(k < 0 ? 0 : u(k) | 0);
    }
    a.allocUnsafe = function(k) {
      return o(k);
    }, a.allocUnsafeSlow = function(k) {
      return o(k);
    };
    function l(k, w) {
      if ((typeof w != "string" || w === "") && (w = "utf8"), !a.isEncoding(w))
        throw new TypeError("Unknown encoding: " + w);
      const _ = S(k, w) | 0;
      let L = c(_);
      const U = L.write(k, w);
      return U !== _ && (L = L.slice(0, U)), L;
    }
    function s(k) {
      const w = k.length < 0 ? 0 : u(k.length) | 0, _ = c(w);
      for (let L = 0; L < w; L += 1)
        _[L] = k[L] & 255;
      return _;
    }
    function f(k) {
      if (ve(k, Uint8Array)) {
        const w = new Uint8Array(k);
        return b(w.buffer, w.byteOffset, w.byteLength);
      }
      return s(k);
    }
    function b(k, w, _) {
      if (w < 0 || k.byteLength < w)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (k.byteLength < w + (_ || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let L;
      return w === void 0 && _ === void 0 ? L = new Uint8Array(k) : _ === void 0 ? L = new Uint8Array(k, w) : L = new Uint8Array(k, w, _), Object.setPrototypeOf(L, a.prototype), L;
    }
    function y(k) {
      if (a.isBuffer(k)) {
        const w = u(k.length) | 0, _ = c(w);
        return _.length === 0 || k.copy(_, 0, 0, w), _;
      }
      if (k.length !== void 0)
        return typeof k.length != "number" || pe(k.length) ? c(0) : s(k);
      if (k.type === "Buffer" && Array.isArray(k.data))
        return s(k.data);
    }
    function u(k) {
      if (k >= g)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + g.toString(16) + " bytes");
      return k | 0;
    }
    function R(k) {
      return +k != k && (k = 0), a.alloc(+k);
    }
    a.isBuffer = function(w) {
      return w != null && w._isBuffer === !0 && w !== a.prototype;
    }, a.compare = function(w, _) {
      if (ve(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)), ve(_, Uint8Array) && (_ = a.from(_, _.offset, _.byteLength)), !a.isBuffer(w) || !a.isBuffer(_))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (w === _) return 0;
      let L = w.length, U = _.length;
      for (let V = 0, z = Math.min(L, U); V < z; ++V)
        if (w[V] !== _[V]) {
          L = w[V], U = _[V];
          break;
        }
      return L < U ? -1 : U < L ? 1 : 0;
    }, a.isEncoding = function(w) {
      switch (String(w).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, a.concat = function(w, _) {
      if (!Array.isArray(w))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (w.length === 0)
        return a.alloc(0);
      let L;
      if (_ === void 0)
        for (_ = 0, L = 0; L < w.length; ++L)
          _ += w[L].length;
      const U = a.allocUnsafe(_);
      let V = 0;
      for (L = 0; L < w.length; ++L) {
        let z = w[L];
        if (ve(z, Uint8Array))
          V + z.length > U.length ? (a.isBuffer(z) || (z = a.from(z)), z.copy(U, V)) : Uint8Array.prototype.set.call(
            U,
            z,
            V
          );
        else if (a.isBuffer(z))
          z.copy(U, V);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        V += z.length;
      }
      return U;
    };
    function S(k, w) {
      if (a.isBuffer(k))
        return k.length;
      if (ArrayBuffer.isView(k) || ve(k, ArrayBuffer))
        return k.byteLength;
      if (typeof k != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof k
        );
      const _ = k.length, L = arguments.length > 2 && arguments[2] === !0;
      if (!L && _ === 0) return 0;
      let U = !1;
      for (; ; )
        switch (w) {
          case "ascii":
          case "latin1":
          case "binary":
            return _;
          case "utf8":
          case "utf-8":
            return ne(k).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return _ * 2;
          case "hex":
            return _ >>> 1;
          case "base64":
            return me(k).length;
          default:
            if (U)
              return L ? -1 : ne(k).length;
            w = ("" + w).toLowerCase(), U = !0;
        }
    }
    a.byteLength = S;
    function I(k, w, _) {
      let L = !1;
      if ((w === void 0 || w < 0) && (w = 0), w > this.length || ((_ === void 0 || _ > this.length) && (_ = this.length), _ <= 0) || (_ >>>= 0, w >>>= 0, _ <= w))
        return "";
      for (k || (k = "utf8"); ; )
        switch (k) {
          case "hex":
            return B(this, w, _);
          case "utf8":
          case "utf-8":
            return h(this, w, _);
          case "ascii":
            return M(this, w, _);
          case "latin1":
          case "binary":
            return x(this, w, _);
          case "base64":
            return F(this, w, _);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return j(this, w, _);
          default:
            if (L) throw new TypeError("Unknown encoding: " + k);
            k = (k + "").toLowerCase(), L = !0;
        }
    }
    a.prototype._isBuffer = !0;
    function T(k, w, _) {
      const L = k[w];
      k[w] = k[_], k[_] = L;
    }
    a.prototype.swap16 = function() {
      const w = this.length;
      if (w % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let _ = 0; _ < w; _ += 2)
        T(this, _, _ + 1);
      return this;
    }, a.prototype.swap32 = function() {
      const w = this.length;
      if (w % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let _ = 0; _ < w; _ += 4)
        T(this, _, _ + 3), T(this, _ + 1, _ + 2);
      return this;
    }, a.prototype.swap64 = function() {
      const w = this.length;
      if (w % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let _ = 0; _ < w; _ += 8)
        T(this, _, _ + 7), T(this, _ + 1, _ + 6), T(this, _ + 2, _ + 5), T(this, _ + 3, _ + 4);
      return this;
    }, a.prototype.toString = function() {
      const w = this.length;
      return w === 0 ? "" : arguments.length === 0 ? h(this, 0, w) : I.apply(this, arguments);
    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(w) {
      if (!a.isBuffer(w)) throw new TypeError("Argument must be a Buffer");
      return this === w ? !0 : a.compare(this, w) === 0;
    }, a.prototype.inspect = function() {
      let w = "";
      const _ = e.INSPECT_MAX_BYTES;
      return w = this.toString("hex", 0, _).replace(/(.{2})/g, "$1 ").trim(), this.length > _ && (w += " ... "), "<Buffer " + w + ">";
    }, t && (a.prototype[t] = a.prototype.inspect), a.prototype.compare = function(w, _, L, U, V) {
      if (ve(w, Uint8Array) && (w = a.from(w, w.offset, w.byteLength)), !a.isBuffer(w))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof w
        );
      if (_ === void 0 && (_ = 0), L === void 0 && (L = w ? w.length : 0), U === void 0 && (U = 0), V === void 0 && (V = this.length), _ < 0 || L > w.length || U < 0 || V > this.length)
        throw new RangeError("out of range index");
      if (U >= V && _ >= L)
        return 0;
      if (U >= V)
        return -1;
      if (_ >= L)
        return 1;
      if (_ >>>= 0, L >>>= 0, U >>>= 0, V >>>= 0, this === w) return 0;
      let z = V - U, de = L - _;
      const ce = Math.min(z, de), ue = this.slice(U, V), be = w.slice(_, L);
      for (let se = 0; se < ce; ++se)
        if (ue[se] !== be[se]) {
          z = ue[se], de = be[se];
          break;
        }
      return z < de ? -1 : de < z ? 1 : 0;
    };
    function q(k, w, _, L, U) {
      if (k.length === 0) return -1;
      if (typeof _ == "string" ? (L = _, _ = 0) : _ > 2147483647 ? _ = 2147483647 : _ < -2147483648 && (_ = -2147483648), _ = +_, pe(_) && (_ = U ? 0 : k.length - 1), _ < 0 && (_ = k.length + _), _ >= k.length) {
        if (U) return -1;
        _ = k.length - 1;
      } else if (_ < 0)
        if (U) _ = 0;
        else return -1;
      if (typeof w == "string" && (w = a.from(w, L)), a.isBuffer(w))
        return w.length === 0 ? -1 : D(k, w, _, L, U);
      if (typeof w == "number")
        return w = w & 255, typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(k, w, _) : Uint8Array.prototype.lastIndexOf.call(k, w, _) : D(k, [w], _, L, U);
      throw new TypeError("val must be string, number or Buffer");
    }
    function D(k, w, _, L, U) {
      let V = 1, z = k.length, de = w.length;
      if (L !== void 0 && (L = String(L).toLowerCase(), L === "ucs2" || L === "ucs-2" || L === "utf16le" || L === "utf-16le")) {
        if (k.length < 2 || w.length < 2)
          return -1;
        V = 2, z /= 2, de /= 2, _ /= 2;
      }
      function ce(be, se) {
        return V === 1 ? be[se] : be.readUInt16BE(se * V);
      }
      let ue;
      if (U) {
        let be = -1;
        for (ue = _; ue < z; ue++)
          if (ce(k, ue) === ce(w, be === -1 ? 0 : ue - be)) {
            if (be === -1 && (be = ue), ue - be + 1 === de) return be * V;
          } else
            be !== -1 && (ue -= ue - be), be = -1;
      } else
        for (_ + de > z && (_ = z - de), ue = _; ue >= 0; ue--) {
          let be = !0;
          for (let se = 0; se < de; se++)
            if (ce(k, ue + se) !== ce(w, se)) {
              be = !1;
              break;
            }
          if (be) return ue;
        }
      return -1;
    }
    a.prototype.includes = function(w, _, L) {
      return this.indexOf(w, _, L) !== -1;
    }, a.prototype.indexOf = function(w, _, L) {
      return q(this, w, _, L, !0);
    }, a.prototype.lastIndexOf = function(w, _, L) {
      return q(this, w, _, L, !1);
    };
    function H(k, w, _, L) {
      _ = Number(_) || 0;
      const U = k.length - _;
      L ? (L = Number(L), L > U && (L = U)) : L = U;
      const V = w.length;
      L > V / 2 && (L = V / 2);
      let z;
      for (z = 0; z < L; ++z) {
        const de = parseInt(w.substr(z * 2, 2), 16);
        if (pe(de)) return z;
        k[_ + z] = de;
      }
      return z;
    }
    function G(k, w, _, L) {
      return he(ne(w, k.length - _), k, _, L);
    }
    function X(k, w, _, L) {
      return he(fe(w), k, _, L);
    }
    function Y(k, w, _, L) {
      return he(me(w), k, _, L);
    }
    function re(k, w, _, L) {
      return he(He(w, k.length - _), k, _, L);
    }
    a.prototype.write = function(w, _, L, U) {
      if (_ === void 0)
        U = "utf8", L = this.length, _ = 0;
      else if (L === void 0 && typeof _ == "string")
        U = _, L = this.length, _ = 0;
      else if (isFinite(_))
        _ = _ >>> 0, isFinite(L) ? (L = L >>> 0, U === void 0 && (U = "utf8")) : (U = L, L = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const V = this.length - _;
      if ((L === void 0 || L > V) && (L = V), w.length > 0 && (L < 0 || _ < 0) || _ > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      U || (U = "utf8");
      let z = !1;
      for (; ; )
        switch (U) {
          case "hex":
            return H(this, w, _, L);
          case "utf8":
          case "utf-8":
            return G(this, w, _, L);
          case "ascii":
          case "latin1":
          case "binary":
            return X(this, w, _, L);
          case "base64":
            return Y(this, w, _, L);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return re(this, w, _, L);
          default:
            if (z) throw new TypeError("Unknown encoding: " + U);
            U = ("" + U).toLowerCase(), z = !0;
        }
    }, a.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function F(k, w, _) {
      return w === 0 && _ === k.length ? r.fromByteArray(k) : r.fromByteArray(k.slice(w, _));
    }
    function h(k, w, _) {
      _ = Math.min(k.length, _);
      const L = [];
      let U = w;
      for (; U < _; ) {
        const V = k[U];
        let z = null, de = V > 239 ? 4 : V > 223 ? 3 : V > 191 ? 2 : 1;
        if (U + de <= _) {
          let ce, ue, be, se;
          switch (de) {
            case 1:
              V < 128 && (z = V);
              break;
            case 2:
              ce = k[U + 1], (ce & 192) === 128 && (se = (V & 31) << 6 | ce & 63, se > 127 && (z = se));
              break;
            case 3:
              ce = k[U + 1], ue = k[U + 2], (ce & 192) === 128 && (ue & 192) === 128 && (se = (V & 15) << 12 | (ce & 63) << 6 | ue & 63, se > 2047 && (se < 55296 || se > 57343) && (z = se));
              break;
            case 4:
              ce = k[U + 1], ue = k[U + 2], be = k[U + 3], (ce & 192) === 128 && (ue & 192) === 128 && (be & 192) === 128 && (se = (V & 15) << 18 | (ce & 63) << 12 | (ue & 63) << 6 | be & 63, se > 65535 && se < 1114112 && (z = se));
          }
        }
        z === null ? (z = 65533, de = 1) : z > 65535 && (z -= 65536, L.push(z >>> 10 & 1023 | 55296), z = 56320 | z & 1023), L.push(z), U += de;
      }
      return C(L);
    }
    const E = 4096;
    function C(k) {
      const w = k.length;
      if (w <= E)
        return String.fromCharCode.apply(String, k);
      let _ = "", L = 0;
      for (; L < w; )
        _ += String.fromCharCode.apply(
          String,
          k.slice(L, L += E)
        );
      return _;
    }
    function M(k, w, _) {
      let L = "";
      _ = Math.min(k.length, _);
      for (let U = w; U < _; ++U)
        L += String.fromCharCode(k[U] & 127);
      return L;
    }
    function x(k, w, _) {
      let L = "";
      _ = Math.min(k.length, _);
      for (let U = w; U < _; ++U)
        L += String.fromCharCode(k[U]);
      return L;
    }
    function B(k, w, _) {
      const L = k.length;
      (!w || w < 0) && (w = 0), (!_ || _ < 0 || _ > L) && (_ = L);
      let U = "";
      for (let V = w; V < _; ++V)
        U += we[k[V]];
      return U;
    }
    function j(k, w, _) {
      const L = k.slice(w, _);
      let U = "";
      for (let V = 0; V < L.length - 1; V += 2)
        U += String.fromCharCode(L[V] + L[V + 1] * 256);
      return U;
    }
    a.prototype.slice = function(w, _) {
      const L = this.length;
      w = ~~w, _ = _ === void 0 ? L : ~~_, w < 0 ? (w += L, w < 0 && (w = 0)) : w > L && (w = L), _ < 0 ? (_ += L, _ < 0 && (_ = 0)) : _ > L && (_ = L), _ < w && (_ = w);
      const U = this.subarray(w, _);
      return Object.setPrototypeOf(U, a.prototype), U;
    };
    function A(k, w, _) {
      if (k % 1 !== 0 || k < 0) throw new RangeError("offset is not uint");
      if (k + w > _) throw new RangeError("Trying to access beyond buffer length");
    }
    a.prototype.readUintLE = a.prototype.readUIntLE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = this[w], V = 1, z = 0;
      for (; ++z < _ && (V *= 256); )
        U += this[w + z] * V;
      return U;
    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = this[w + --_], V = 1;
      for (; _ > 0 && (V *= 256); )
        U += this[w + --_] * V;
      return U;
    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(w, _) {
      return w = w >>> 0, _ || A(w, 1, this.length), this[w];
    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(w, _) {
      return w = w >>> 0, _ || A(w, 2, this.length), this[w] | this[w + 1] << 8;
    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(w, _) {
      return w = w >>> 0, _ || A(w, 2, this.length), this[w] << 8 | this[w + 1];
    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), (this[w] | this[w + 1] << 8 | this[w + 2] << 16) + this[w + 3] * 16777216;
    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), this[w] * 16777216 + (this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3]);
    }, a.prototype.readBigUInt64LE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = _ + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24, V = this[++w] + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + L * 2 ** 24;
      return BigInt(U) + (BigInt(V) << BigInt(32));
    }), a.prototype.readBigUInt64BE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = _ * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w], V = this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + L;
      return (BigInt(U) << BigInt(32)) + BigInt(V);
    }), a.prototype.readIntLE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = this[w], V = 1, z = 0;
      for (; ++z < _ && (V *= 256); )
        U += this[w + z] * V;
      return V *= 128, U >= V && (U -= Math.pow(2, 8 * _)), U;
    }, a.prototype.readIntBE = function(w, _, L) {
      w = w >>> 0, _ = _ >>> 0, L || A(w, _, this.length);
      let U = _, V = 1, z = this[w + --U];
      for (; U > 0 && (V *= 256); )
        z += this[w + --U] * V;
      return V *= 128, z >= V && (z -= Math.pow(2, 8 * _)), z;
    }, a.prototype.readInt8 = function(w, _) {
      return w = w >>> 0, _ || A(w, 1, this.length), this[w] & 128 ? (255 - this[w] + 1) * -1 : this[w];
    }, a.prototype.readInt16LE = function(w, _) {
      w = w >>> 0, _ || A(w, 2, this.length);
      const L = this[w] | this[w + 1] << 8;
      return L & 32768 ? L | 4294901760 : L;
    }, a.prototype.readInt16BE = function(w, _) {
      w = w >>> 0, _ || A(w, 2, this.length);
      const L = this[w + 1] | this[w] << 8;
      return L & 32768 ? L | 4294901760 : L;
    }, a.prototype.readInt32LE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), this[w] | this[w + 1] << 8 | this[w + 2] << 16 | this[w + 3] << 24;
    }, a.prototype.readInt32BE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), this[w] << 24 | this[w + 1] << 16 | this[w + 2] << 8 | this[w + 3];
    }, a.prototype.readBigInt64LE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = this[w + 4] + this[w + 5] * 2 ** 8 + this[w + 6] * 2 ** 16 + (L << 24);
      return (BigInt(U) << BigInt(32)) + BigInt(_ + this[++w] * 2 ** 8 + this[++w] * 2 ** 16 + this[++w] * 2 ** 24);
    }), a.prototype.readBigInt64BE = je(function(w) {
      w = w >>> 0, Z(w, "offset");
      const _ = this[w], L = this[w + 7];
      (_ === void 0 || L === void 0) && Q(w, this.length - 8);
      const U = (_ << 24) + // Overflow
      this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + this[++w];
      return (BigInt(U) << BigInt(32)) + BigInt(this[++w] * 2 ** 24 + this[++w] * 2 ** 16 + this[++w] * 2 ** 8 + L);
    }), a.prototype.readFloatLE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), n.read(this, w, !0, 23, 4);
    }, a.prototype.readFloatBE = function(w, _) {
      return w = w >>> 0, _ || A(w, 4, this.length), n.read(this, w, !1, 23, 4);
    }, a.prototype.readDoubleLE = function(w, _) {
      return w = w >>> 0, _ || A(w, 8, this.length), n.read(this, w, !0, 52, 8);
    }, a.prototype.readDoubleBE = function(w, _) {
      return w = w >>> 0, _ || A(w, 8, this.length), n.read(this, w, !1, 52, 8);
    };
    function v(k, w, _, L, U, V) {
      if (!a.isBuffer(k)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (w > U || w < V) throw new RangeError('"value" argument is out of bounds');
      if (_ + L > k.length) throw new RangeError("Index out of range");
    }
    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, L = L >>> 0, !U) {
        const de = Math.pow(2, 8 * L) - 1;
        v(this, w, _, L, de, 0);
      }
      let V = 1, z = 0;
      for (this[_] = w & 255; ++z < L && (V *= 256); )
        this[_ + z] = w / V & 255;
      return _ + L;
    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, L = L >>> 0, !U) {
        const de = Math.pow(2, 8 * L) - 1;
        v(this, w, _, L, de, 0);
      }
      let V = L - 1, z = 1;
      for (this[_ + V] = w & 255; --V >= 0 && (z *= 256); )
        this[_ + V] = w / z & 255;
      return _ + L;
    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 1, 255, 0), this[_] = w & 255, _ + 1;
    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 2, 65535, 0), this[_] = w & 255, this[_ + 1] = w >>> 8, _ + 2;
    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 2, 65535, 0), this[_] = w >>> 8, this[_ + 1] = w & 255, _ + 2;
    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 4, 4294967295, 0), this[_ + 3] = w >>> 24, this[_ + 2] = w >>> 16, this[_ + 1] = w >>> 8, this[_] = w & 255, _ + 4;
    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 4, 4294967295, 0), this[_] = w >>> 24, this[_ + 1] = w >>> 16, this[_ + 2] = w >>> 8, this[_ + 3] = w & 255, _ + 4;
    };
    function N(k, w, _, L, U) {
      O(w, L, U, k, _, 7);
      let V = Number(w & BigInt(4294967295));
      k[_++] = V, V = V >> 8, k[_++] = V, V = V >> 8, k[_++] = V, V = V >> 8, k[_++] = V;
      let z = Number(w >> BigInt(32) & BigInt(4294967295));
      return k[_++] = z, z = z >> 8, k[_++] = z, z = z >> 8, k[_++] = z, z = z >> 8, k[_++] = z, _;
    }
    function te(k, w, _, L, U) {
      O(w, L, U, k, _, 7);
      let V = Number(w & BigInt(4294967295));
      k[_ + 7] = V, V = V >> 8, k[_ + 6] = V, V = V >> 8, k[_ + 5] = V, V = V >> 8, k[_ + 4] = V;
      let z = Number(w >> BigInt(32) & BigInt(4294967295));
      return k[_ + 3] = z, z = z >> 8, k[_ + 2] = z, z = z >> 8, k[_ + 1] = z, z = z >> 8, k[_] = z, _ + 8;
    }
    a.prototype.writeBigUInt64LE = je(function(w, _ = 0) {
      return N(this, w, _, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeBigUInt64BE = je(function(w, _ = 0) {
      return te(this, w, _, BigInt(0), BigInt("0xffffffffffffffff"));
    }), a.prototype.writeIntLE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, !U) {
        const ce = Math.pow(2, 8 * L - 1);
        v(this, w, _, L, ce - 1, -ce);
      }
      let V = 0, z = 1, de = 0;
      for (this[_] = w & 255; ++V < L && (z *= 256); )
        w < 0 && de === 0 && this[_ + V - 1] !== 0 && (de = 1), this[_ + V] = (w / z >> 0) - de & 255;
      return _ + L;
    }, a.prototype.writeIntBE = function(w, _, L, U) {
      if (w = +w, _ = _ >>> 0, !U) {
        const ce = Math.pow(2, 8 * L - 1);
        v(this, w, _, L, ce - 1, -ce);
      }
      let V = L - 1, z = 1, de = 0;
      for (this[_ + V] = w & 255; --V >= 0 && (z *= 256); )
        w < 0 && de === 0 && this[_ + V + 1] !== 0 && (de = 1), this[_ + V] = (w / z >> 0) - de & 255;
      return _ + L;
    }, a.prototype.writeInt8 = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 1, 127, -128), w < 0 && (w = 255 + w + 1), this[_] = w & 255, _ + 1;
    }, a.prototype.writeInt16LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 2, 32767, -32768), this[_] = w & 255, this[_ + 1] = w >>> 8, _ + 2;
    }, a.prototype.writeInt16BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 2, 32767, -32768), this[_] = w >>> 8, this[_ + 1] = w & 255, _ + 2;
    }, a.prototype.writeInt32LE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 4, 2147483647, -2147483648), this[_] = w & 255, this[_ + 1] = w >>> 8, this[_ + 2] = w >>> 16, this[_ + 3] = w >>> 24, _ + 4;
    }, a.prototype.writeInt32BE = function(w, _, L) {
      return w = +w, _ = _ >>> 0, L || v(this, w, _, 4, 2147483647, -2147483648), w < 0 && (w = 4294967295 + w + 1), this[_] = w >>> 24, this[_ + 1] = w >>> 16, this[_ + 2] = w >>> 8, this[_ + 3] = w & 255, _ + 4;
    }, a.prototype.writeBigInt64LE = je(function(w, _ = 0) {
      return N(this, w, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), a.prototype.writeBigInt64BE = je(function(w, _ = 0) {
      return te(this, w, _, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function K(k, w, _, L, U, V) {
      if (_ + L > k.length) throw new RangeError("Index out of range");
      if (_ < 0) throw new RangeError("Index out of range");
    }
    function $(k, w, _, L, U) {
      return w = +w, _ = _ >>> 0, U || K(k, w, _, 4), n.write(k, w, _, L, 23, 4), _ + 4;
    }
    a.prototype.writeFloatLE = function(w, _, L) {
      return $(this, w, _, !0, L);
    }, a.prototype.writeFloatBE = function(w, _, L) {
      return $(this, w, _, !1, L);
    };
    function W(k, w, _, L, U) {
      return w = +w, _ = _ >>> 0, U || K(k, w, _, 8), n.write(k, w, _, L, 52, 8), _ + 8;
    }
    a.prototype.writeDoubleLE = function(w, _, L) {
      return W(this, w, _, !0, L);
    }, a.prototype.writeDoubleBE = function(w, _, L) {
      return W(this, w, _, !1, L);
    }, a.prototype.copy = function(w, _, L, U) {
      if (!a.isBuffer(w)) throw new TypeError("argument should be a Buffer");
      if (L || (L = 0), !U && U !== 0 && (U = this.length), _ >= w.length && (_ = w.length), _ || (_ = 0), U > 0 && U < L && (U = L), U === L || w.length === 0 || this.length === 0) return 0;
      if (_ < 0)
        throw new RangeError("targetStart out of bounds");
      if (L < 0 || L >= this.length) throw new RangeError("Index out of range");
      if (U < 0) throw new RangeError("sourceEnd out of bounds");
      U > this.length && (U = this.length), w.length - _ < U - L && (U = w.length - _ + L);
      const V = U - L;
      return this === w && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(_, L, U) : Uint8Array.prototype.set.call(
        w,
        this.subarray(L, U),
        _
      ), V;
    }, a.prototype.fill = function(w, _, L, U) {
      if (typeof w == "string") {
        if (typeof _ == "string" ? (U = _, _ = 0, L = this.length) : typeof L == "string" && (U = L, L = this.length), U !== void 0 && typeof U != "string")
          throw new TypeError("encoding must be a string");
        if (typeof U == "string" && !a.isEncoding(U))
          throw new TypeError("Unknown encoding: " + U);
        if (w.length === 1) {
          const z = w.charCodeAt(0);
          (U === "utf8" && z < 128 || U === "latin1") && (w = z);
        }
      } else typeof w == "number" ? w = w & 255 : typeof w == "boolean" && (w = Number(w));
      if (_ < 0 || this.length < _ || this.length < L)
        throw new RangeError("Out of range index");
      if (L <= _)
        return this;
      _ = _ >>> 0, L = L === void 0 ? this.length : L >>> 0, w || (w = 0);
      let V;
      if (typeof w == "number")
        for (V = _; V < L; ++V)
          this[V] = w;
      else {
        const z = a.isBuffer(w) ? w : a.from(w, U), de = z.length;
        if (de === 0)
          throw new TypeError('The value "' + w + '" is invalid for argument "value"');
        for (V = 0; V < L - _; ++V)
          this[V + _] = z[V % de];
      }
      return this;
    };
    const J = {};
    function ee(k, w, _) {
      J[k] = class extends _ {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: w.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${k}]`, this.stack, delete this.name;
        }
        get code() {
          return k;
        }
        set code(U) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: U,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${k}]: ${this.message}`;
        }
      };
    }
    ee(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(k) {
        return k ? `${k} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), ee(
      "ERR_INVALID_ARG_TYPE",
      function(k, w) {
        return `The "${k}" argument must be of type number. Received type ${typeof w}`;
      },
      TypeError
    ), ee(
      "ERR_OUT_OF_RANGE",
      function(k, w, _) {
        let L = `The value of "${k}" is out of range.`, U = _;
        return Number.isInteger(_) && Math.abs(_) > 2 ** 32 ? U = oe(String(_)) : typeof _ == "bigint" && (U = String(_), (_ > BigInt(2) ** BigInt(32) || _ < -(BigInt(2) ** BigInt(32))) && (U = oe(U)), U += "n"), L += ` It must be ${w}. Received ${U}`, L;
      },
      RangeError
    );
    function oe(k) {
      let w = "", _ = k.length;
      const L = k[0] === "-" ? 1 : 0;
      for (; _ >= L + 4; _ -= 3)
        w = `_${k.slice(_ - 3, _)}${w}`;
      return `${k.slice(0, _)}${w}`;
    }
    function P(k, w, _) {
      Z(w, "offset"), (k[w] === void 0 || k[w + _] === void 0) && Q(w, k.length - (_ + 1));
    }
    function O(k, w, _, L, U, V) {
      if (k > _ || k < w) {
        const z = typeof w == "bigint" ? "n" : "";
        let de;
        throw w === 0 || w === BigInt(0) ? de = `>= 0${z} and < 2${z} ** ${(V + 1) * 8}${z}` : de = `>= -(2${z} ** ${(V + 1) * 8 - 1}${z}) and < 2 ** ${(V + 1) * 8 - 1}${z}`, new J.ERR_OUT_OF_RANGE("value", de, k);
      }
      P(L, U, V);
    }
    function Z(k, w) {
      if (typeof k != "number")
        throw new J.ERR_INVALID_ARG_TYPE(w, "number", k);
    }
    function Q(k, w, _) {
      throw Math.floor(k) !== k ? (Z(k, _), new J.ERR_OUT_OF_RANGE("offset", "an integer", k)) : w < 0 ? new J.ERR_BUFFER_OUT_OF_BOUNDS() : new J.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${w}`,
        k
      );
    }
    const ae = /[^+/0-9A-Za-z-_]/g;
    function le(k) {
      if (k = k.split("=")[0], k = k.trim().replace(ae, ""), k.length < 2) return "";
      for (; k.length % 4 !== 0; )
        k = k + "=";
      return k;
    }
    function ne(k, w) {
      w = w || 1 / 0;
      let _;
      const L = k.length;
      let U = null;
      const V = [];
      for (let z = 0; z < L; ++z) {
        if (_ = k.charCodeAt(z), _ > 55295 && _ < 57344) {
          if (!U) {
            if (_ > 56319) {
              (w -= 3) > -1 && V.push(239, 191, 189);
              continue;
            } else if (z + 1 === L) {
              (w -= 3) > -1 && V.push(239, 191, 189);
              continue;
            }
            U = _;
            continue;
          }
          if (_ < 56320) {
            (w -= 3) > -1 && V.push(239, 191, 189), U = _;
            continue;
          }
          _ = (U - 55296 << 10 | _ - 56320) + 65536;
        } else U && (w -= 3) > -1 && V.push(239, 191, 189);
        if (U = null, _ < 128) {
          if ((w -= 1) < 0) break;
          V.push(_);
        } else if (_ < 2048) {
          if ((w -= 2) < 0) break;
          V.push(
            _ >> 6 | 192,
            _ & 63 | 128
          );
        } else if (_ < 65536) {
          if ((w -= 3) < 0) break;
          V.push(
            _ >> 12 | 224,
            _ >> 6 & 63 | 128,
            _ & 63 | 128
          );
        } else if (_ < 1114112) {
          if ((w -= 4) < 0) break;
          V.push(
            _ >> 18 | 240,
            _ >> 12 & 63 | 128,
            _ >> 6 & 63 | 128,
            _ & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return V;
    }
    function fe(k) {
      const w = [];
      for (let _ = 0; _ < k.length; ++_)
        w.push(k.charCodeAt(_) & 255);
      return w;
    }
    function He(k, w) {
      let _, L, U;
      const V = [];
      for (let z = 0; z < k.length && !((w -= 2) < 0); ++z)
        _ = k.charCodeAt(z), L = _ >> 8, U = _ % 256, V.push(U), V.push(L);
      return V;
    }
    function me(k) {
      return r.toByteArray(le(k));
    }
    function he(k, w, _, L) {
      let U;
      for (U = 0; U < L && !(U + _ >= w.length || U >= k.length); ++U)
        w[U + _] = k[U];
      return U;
    }
    function ve(k, w) {
      return k instanceof w || k != null && k.constructor != null && k.constructor.name != null && k.constructor.name === w.name;
    }
    function pe(k) {
      return k !== k;
    }
    const we = function() {
      const k = "0123456789abcdef", w = new Array(256);
      for (let _ = 0; _ < 16; ++_) {
        const L = _ * 16;
        for (let U = 0; U < 16; ++U)
          w[L + U] = k[_] + k[U];
      }
      return w;
    }();
    function je(k) {
      return typeof BigInt > "u" ? ye : k;
    }
    function ye() {
      throw new Error("BigInt not supported");
    }
  }(Bn)), Bn;
}
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Co;
function st() {
  return Co || (Co = 1, function(e, r) {
    var n = wn(), t = n.Buffer;
    function g(c, a) {
      for (var d in c)
        a[d] = c[d];
    }
    t.from && t.alloc && t.allocUnsafe && t.allocUnsafeSlow ? e.exports = n : (g(n, r), r.Buffer = i);
    function i(c, a, d) {
      return t(c, a, d);
    }
    i.prototype = Object.create(t.prototype), g(t, i), i.from = function(c, a, d) {
      if (typeof c == "number")
        throw new TypeError("Argument must not be a number");
      return t(c, a, d);
    }, i.alloc = function(c, a, d) {
      if (typeof c != "number")
        throw new TypeError("Argument must be a number");
      var m = t(c);
      return a !== void 0 ? typeof d == "string" ? m.fill(a, d) : m.fill(a) : m.fill(0), m;
    }, i.allocUnsafe = function(c) {
      if (typeof c != "number")
        throw new TypeError("Argument must be a number");
      return t(c);
    }, i.allocUnsafeSlow = function(c) {
      if (typeof c != "number")
        throw new TypeError("Argument must be a number");
      return n.SlowBuffer(c);
    };
  }(Jr, Jr.exports)), Jr.exports;
}
var Nn, Mo;
function Qt() {
  if (Mo) return Nn;
  Mo = 1;
  var e = st().Buffer;
  function r(n, t) {
    this._block = e.alloc(n), this._finalSize = t, this._blockSize = n, this._len = 0;
  }
  return r.prototype.update = function(n, t) {
    typeof n == "string" && (t = t || "utf8", n = e.from(n, t));
    for (var g = this._block, i = this._blockSize, c = n.length, a = this._len, d = 0; d < c; ) {
      for (var m = a % i, p = Math.min(c - d, i - m), o = 0; o < p; o++)
        g[m + o] = n[d + o];
      a += p, d += p, a % i === 0 && this._update(g);
    }
    return this._len += c, this;
  }, r.prototype.digest = function(n) {
    var t = this._len % this._blockSize;
    this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var g = this._len * 8;
    if (g <= 4294967295)
      this._block.writeUInt32BE(g, this._blockSize - 4);
    else {
      var i = (g & 4294967295) >>> 0, c = (g - i) / 4294967296;
      this._block.writeUInt32BE(c, this._blockSize - 8), this._block.writeUInt32BE(i, this._blockSize - 4);
    }
    this._update(this._block);
    var a = this._hash();
    return n ? a.toString(n) : a;
  }, r.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, Nn = r, Nn;
}
var Pn, ko;
function Vl() {
  if (ko) return Pn;
  ko = 1;
  var e = Qe(), r = Qt(), n = st().Buffer, t = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], g = new Array(80);
  function i() {
    this.init(), this._w = g, r.call(this, 64, 56);
  }
  e(i, r), i.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function c(m) {
    return m << 5 | m >>> 27;
  }
  function a(m) {
    return m << 30 | m >>> 2;
  }
  function d(m, p, o, l) {
    return m === 0 ? p & o | ~p & l : m === 2 ? p & o | p & l | o & l : p ^ o ^ l;
  }
  return i.prototype._update = function(m) {
    for (var p = this._w, o = this._a | 0, l = this._b | 0, s = this._c | 0, f = this._d | 0, b = this._e | 0, y = 0; y < 16; ++y) p[y] = m.readInt32BE(y * 4);
    for (; y < 80; ++y) p[y] = p[y - 3] ^ p[y - 8] ^ p[y - 14] ^ p[y - 16];
    for (var u = 0; u < 80; ++u) {
      var R = ~~(u / 20), S = c(o) + d(R, l, s, f) + b + p[u] + t[R] | 0;
      b = f, f = s, s = a(l), l = o, o = S;
    }
    this._a = o + this._a | 0, this._b = l + this._b | 0, this._c = s + this._c | 0, this._d = f + this._d | 0, this._e = b + this._e | 0;
  }, i.prototype._hash = function() {
    var m = n.allocUnsafe(20);
    return m.writeInt32BE(this._a | 0, 0), m.writeInt32BE(this._b | 0, 4), m.writeInt32BE(this._c | 0, 8), m.writeInt32BE(this._d | 0, 12), m.writeInt32BE(this._e | 0, 16), m;
  }, Pn = i, Pn;
}
var On, Io;
function zl() {
  if (Io) return On;
  Io = 1;
  var e = Qe(), r = Qt(), n = st().Buffer, t = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], g = new Array(80);
  function i() {
    this.init(), this._w = g, r.call(this, 64, 56);
  }
  e(i, r), i.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function c(p) {
    return p << 1 | p >>> 31;
  }
  function a(p) {
    return p << 5 | p >>> 27;
  }
  function d(p) {
    return p << 30 | p >>> 2;
  }
  function m(p, o, l, s) {
    return p === 0 ? o & l | ~o & s : p === 2 ? o & l | o & s | l & s : o ^ l ^ s;
  }
  return i.prototype._update = function(p) {
    for (var o = this._w, l = this._a | 0, s = this._b | 0, f = this._c | 0, b = this._d | 0, y = this._e | 0, u = 0; u < 16; ++u) o[u] = p.readInt32BE(u * 4);
    for (; u < 80; ++u) o[u] = c(o[u - 3] ^ o[u - 8] ^ o[u - 14] ^ o[u - 16]);
    for (var R = 0; R < 80; ++R) {
      var S = ~~(R / 20), I = a(l) + m(S, s, f, b) + y + o[R] + t[S] | 0;
      y = b, b = f, f = d(s), s = l, l = I;
    }
    this._a = l + this._a | 0, this._b = s + this._b | 0, this._c = f + this._c | 0, this._d = b + this._d | 0, this._e = y + this._e | 0;
  }, i.prototype._hash = function() {
    var p = n.allocUnsafe(20);
    return p.writeInt32BE(this._a | 0, 0), p.writeInt32BE(this._b | 0, 4), p.writeInt32BE(this._c | 0, 8), p.writeInt32BE(this._d | 0, 12), p.writeInt32BE(this._e | 0, 16), p;
  }, On = i, On;
}
var Fn, xo;
function Vc() {
  if (xo) return Fn;
  xo = 1;
  var e = Qe(), r = Qt(), n = st().Buffer, t = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], g = new Array(64);
  function i() {
    this.init(), this._w = g, r.call(this, 64, 56);
  }
  e(i, r), i.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function c(l, s, f) {
    return f ^ l & (s ^ f);
  }
  function a(l, s, f) {
    return l & s | f & (l | s);
  }
  function d(l) {
    return (l >>> 2 | l << 30) ^ (l >>> 13 | l << 19) ^ (l >>> 22 | l << 10);
  }
  function m(l) {
    return (l >>> 6 | l << 26) ^ (l >>> 11 | l << 21) ^ (l >>> 25 | l << 7);
  }
  function p(l) {
    return (l >>> 7 | l << 25) ^ (l >>> 18 | l << 14) ^ l >>> 3;
  }
  function o(l) {
    return (l >>> 17 | l << 15) ^ (l >>> 19 | l << 13) ^ l >>> 10;
  }
  return i.prototype._update = function(l) {
    for (var s = this._w, f = this._a | 0, b = this._b | 0, y = this._c | 0, u = this._d | 0, R = this._e | 0, S = this._f | 0, I = this._g | 0, T = this._h | 0, q = 0; q < 16; ++q) s[q] = l.readInt32BE(q * 4);
    for (; q < 64; ++q) s[q] = o(s[q - 2]) + s[q - 7] + p(s[q - 15]) + s[q - 16] | 0;
    for (var D = 0; D < 64; ++D) {
      var H = T + m(R) + c(R, S, I) + t[D] + s[D] | 0, G = d(f) + a(f, b, y) | 0;
      T = I, I = S, S = R, R = u + H | 0, u = y, y = b, b = f, f = H + G | 0;
    }
    this._a = f + this._a | 0, this._b = b + this._b | 0, this._c = y + this._c | 0, this._d = u + this._d | 0, this._e = R + this._e | 0, this._f = S + this._f | 0, this._g = I + this._g | 0, this._h = T + this._h | 0;
  }, i.prototype._hash = function() {
    var l = n.allocUnsafe(32);
    return l.writeInt32BE(this._a, 0), l.writeInt32BE(this._b, 4), l.writeInt32BE(this._c, 8), l.writeInt32BE(this._d, 12), l.writeInt32BE(this._e, 16), l.writeInt32BE(this._f, 20), l.writeInt32BE(this._g, 24), l.writeInt32BE(this._h, 28), l;
  }, Fn = i, Fn;
}
var Dn, Ao;
function Jl() {
  if (Ao) return Dn;
  Ao = 1;
  var e = Qe(), r = Vc(), n = Qt(), t = st().Buffer, g = new Array(64);
  function i() {
    this.init(), this._w = g, n.call(this, 64, 56);
  }
  return e(i, r), i.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, i.prototype._hash = function() {
    var c = t.allocUnsafe(28);
    return c.writeInt32BE(this._a, 0), c.writeInt32BE(this._b, 4), c.writeInt32BE(this._c, 8), c.writeInt32BE(this._d, 12), c.writeInt32BE(this._e, 16), c.writeInt32BE(this._f, 20), c.writeInt32BE(this._g, 24), c;
  }, Dn = i, Dn;
}
var qn, To;
function zc() {
  if (To) return qn;
  To = 1;
  var e = Qe(), r = Qt(), n = st().Buffer, t = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], g = new Array(160);
  function i() {
    this.init(), this._w = g, r.call(this, 128, 112);
  }
  e(i, r), i.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function c(b, y, u) {
    return u ^ b & (y ^ u);
  }
  function a(b, y, u) {
    return b & y | u & (b | y);
  }
  function d(b, y) {
    return (b >>> 28 | y << 4) ^ (y >>> 2 | b << 30) ^ (y >>> 7 | b << 25);
  }
  function m(b, y) {
    return (b >>> 14 | y << 18) ^ (b >>> 18 | y << 14) ^ (y >>> 9 | b << 23);
  }
  function p(b, y) {
    return (b >>> 1 | y << 31) ^ (b >>> 8 | y << 24) ^ b >>> 7;
  }
  function o(b, y) {
    return (b >>> 1 | y << 31) ^ (b >>> 8 | y << 24) ^ (b >>> 7 | y << 25);
  }
  function l(b, y) {
    return (b >>> 19 | y << 13) ^ (y >>> 29 | b << 3) ^ b >>> 6;
  }
  function s(b, y) {
    return (b >>> 19 | y << 13) ^ (y >>> 29 | b << 3) ^ (b >>> 6 | y << 26);
  }
  function f(b, y) {
    return b >>> 0 < y >>> 0 ? 1 : 0;
  }
  return i.prototype._update = function(b) {
    for (var y = this._w, u = this._ah | 0, R = this._bh | 0, S = this._ch | 0, I = this._dh | 0, T = this._eh | 0, q = this._fh | 0, D = this._gh | 0, H = this._hh | 0, G = this._al | 0, X = this._bl | 0, Y = this._cl | 0, re = this._dl | 0, F = this._el | 0, h = this._fl | 0, E = this._gl | 0, C = this._hl | 0, M = 0; M < 32; M += 2)
      y[M] = b.readInt32BE(M * 4), y[M + 1] = b.readInt32BE(M * 4 + 4);
    for (; M < 160; M += 2) {
      var x = y[M - 30], B = y[M - 15 * 2 + 1], j = p(x, B), A = o(B, x);
      x = y[M - 2 * 2], B = y[M - 2 * 2 + 1];
      var v = l(x, B), N = s(B, x), te = y[M - 7 * 2], K = y[M - 7 * 2 + 1], $ = y[M - 16 * 2], W = y[M - 16 * 2 + 1], J = A + K | 0, ee = j + te + f(J, A) | 0;
      J = J + N | 0, ee = ee + v + f(J, N) | 0, J = J + W | 0, ee = ee + $ + f(J, W) | 0, y[M] = ee, y[M + 1] = J;
    }
    for (var oe = 0; oe < 160; oe += 2) {
      ee = y[oe], J = y[oe + 1];
      var P = a(u, R, S), O = a(G, X, Y), Z = d(u, G), Q = d(G, u), ae = m(T, F), le = m(F, T), ne = t[oe], fe = t[oe + 1], He = c(T, q, D), me = c(F, h, E), he = C + le | 0, ve = H + ae + f(he, C) | 0;
      he = he + me | 0, ve = ve + He + f(he, me) | 0, he = he + fe | 0, ve = ve + ne + f(he, fe) | 0, he = he + J | 0, ve = ve + ee + f(he, J) | 0;
      var pe = Q + O | 0, we = Z + P + f(pe, Q) | 0;
      H = D, C = E, D = q, E = h, q = T, h = F, F = re + he | 0, T = I + ve + f(F, re) | 0, I = S, re = Y, S = R, Y = X, R = u, X = G, G = he + pe | 0, u = ve + we + f(G, he) | 0;
    }
    this._al = this._al + G | 0, this._bl = this._bl + X | 0, this._cl = this._cl + Y | 0, this._dl = this._dl + re | 0, this._el = this._el + F | 0, this._fl = this._fl + h | 0, this._gl = this._gl + E | 0, this._hl = this._hl + C | 0, this._ah = this._ah + u + f(this._al, G) | 0, this._bh = this._bh + R + f(this._bl, X) | 0, this._ch = this._ch + S + f(this._cl, Y) | 0, this._dh = this._dh + I + f(this._dl, re) | 0, this._eh = this._eh + T + f(this._el, F) | 0, this._fh = this._fh + q + f(this._fl, h) | 0, this._gh = this._gh + D + f(this._gl, E) | 0, this._hh = this._hh + H + f(this._hl, C) | 0;
  }, i.prototype._hash = function() {
    var b = n.allocUnsafe(64);
    function y(u, R, S) {
      b.writeInt32BE(u, S), b.writeInt32BE(R, S + 4);
    }
    return y(this._ah, this._al, 0), y(this._bh, this._bl, 8), y(this._ch, this._cl, 16), y(this._dh, this._dl, 24), y(this._eh, this._el, 32), y(this._fh, this._fl, 40), y(this._gh, this._gl, 48), y(this._hh, this._hl, 56), b;
  }, qn = i, qn;
}
var jn, Lo;
function Gl() {
  if (Lo) return jn;
  Lo = 1;
  var e = Qe(), r = zc(), n = Qt(), t = st().Buffer, g = new Array(160);
  function i() {
    this.init(), this._w = g, n.call(this, 128, 112);
  }
  return e(i, r), i.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, i.prototype._hash = function() {
    var c = t.allocUnsafe(48);
    function a(d, m, p) {
      c.writeInt32BE(d, p), c.writeInt32BE(m, p + 4);
    }
    return a(this._ah, this._al, 0), a(this._bh, this._bl, 8), a(this._ch, this._cl, 16), a(this._dh, this._dl, 24), a(this._eh, this._el, 32), a(this._fh, this._fl, 40), c;
  }, jn = i, jn;
}
var Bo;
function Zl() {
  if (Bo) return Ln.exports;
  Bo = 1;
  var e = Ln.exports = function(n) {
    n = n.toLowerCase();
    var t = e[n];
    if (!t) throw new Error(n + " is not supported (we accept pull requests)");
    return new t();
  };
  return e.sha = Vl(), e.sha1 = zl(), e.sha224 = Jl(), e.sha256 = Vc(), e.sha384 = Gl(), e.sha512 = zc(), Ln.exports;
}
var No;
function $s() {
  if (No) return dr;
  No = 1, Object.defineProperty(dr, "__esModule", { value: !0 }), dr.Session = void 0;
  const e = Zl(), r = /* @__PURE__ */ tt(), n = "session:id", t = "session:secret", g = "session:linked";
  let i = class Jc {
    constructor(a, d, m, p) {
      this._storage = a, this._id = d || (0, r.randomBytesHex)(16), this._secret = m || (0, r.randomBytesHex)(32), this._key = new e.sha256().update(`${this._id}, ${this._secret} WalletLink`).digest("hex"), this._linked = !!p;
    }
    static load(a) {
      const d = a.getItem(n), m = a.getItem(g), p = a.getItem(t);
      return d && p ? new Jc(a, d, p, m === "1") : null;
    }
    /**
     * Takes in a session ID and returns the sha256 hash of it.
     * @param sessionId session ID
     */
    static hash(a) {
      return new e.sha256().update(a).digest("hex");
    }
    get id() {
      return this._id;
    }
    get secret() {
      return this._secret;
    }
    get key() {
      return this._key;
    }
    get linked() {
      return this._linked;
    }
    set linked(a) {
      this._linked = a, this.persistLinked();
    }
    save() {
      return this._storage.setItem(n, this._id), this._storage.setItem(t, this._secret), this.persistLinked(), this;
    }
    persistLinked() {
      this._storage.setItem(g, this._linked ? "1" : "0");
    }
  };
  return dr.Session = i, dr;
}
var pr = {}, gr = {}, Po;
function Kl() {
  if (Po) return gr;
  Po = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.Cipher = void 0;
  const e = /* @__PURE__ */ tt();
  let r = class {
    // @param secret hex representation of 32-byte secret
    constructor(t) {
      this.secret = t;
    }
    /**
     *
     * @param plainText string to be encrypted
     * returns hex string representation of bytes in the order: initialization vector (iv),
     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes. Remaining bytes are the
     * encrypted plainText.
     */
    async encrypt(t) {
      const g = this.secret;
      if (g.length !== 64)
        throw Error("secret must be 256 bits");
      const i = crypto.getRandomValues(new Uint8Array(12)), c = await crypto.subtle.importKey("raw", (0, e.hexStringToUint8Array)(g), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), a = new TextEncoder(), d = await window.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: i
      }, c, a.encode(t)), m = 16, p = d.slice(d.byteLength - m), o = d.slice(0, d.byteLength - m), l = new Uint8Array(p), s = new Uint8Array(o), f = new Uint8Array([...i, ...l, ...s]);
      return (0, e.uint8ArrayToHex)(f);
    }
    /**
     *
     * @param cipherText hex string representation of bytes in the order: initialization vector (iv),
     * auth tag, encrypted plaintext. IV is 12 bytes. Auth tag is 16 bytes.
     */
    async decrypt(t) {
      const g = this.secret;
      if (g.length !== 64)
        throw Error("secret must be 256 bits");
      return new Promise((i, c) => {
        (async function() {
          const a = await crypto.subtle.importKey("raw", (0, e.hexStringToUint8Array)(g), { name: "aes-gcm" }, !1, ["encrypt", "decrypt"]), d = (0, e.hexStringToUint8Array)(t), m = d.slice(0, 12), p = d.slice(12, 28), o = d.slice(28), l = new Uint8Array([...o, ...p]), s = {
            name: "AES-GCM",
            iv: new Uint8Array(m)
          };
          try {
            const f = await window.crypto.subtle.decrypt(s, a, l), b = new TextDecoder();
            i(b.decode(f));
          } catch (f) {
            c(f);
          }
        })();
      });
    }
  };
  return gr.Cipher = r, gr;
}
var mr = {}, Oo;
function Ql() {
  if (Oo) return mr;
  Oo = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.WalletLinkHTTP = void 0;
  let e = class {
    constructor(n, t, g) {
      this.linkAPIUrl = n, this.sessionId = t;
      const i = `${t}:${g}`;
      this.auth = `Basic ${btoa(i)}`;
    }
    // mark unseen events as seen
    async markUnseenEventsAsSeen(n) {
      return Promise.all(n.map((t) => fetch(`${this.linkAPIUrl}/events/${t.eventId}/seen`, {
        method: "POST",
        headers: {
          Authorization: this.auth
        }
      }))).catch((t) => console.error("Unabled to mark event as failed:", t));
    }
    async fetchUnseenEvents() {
      var n;
      const t = await fetch(`${this.linkAPIUrl}/events?unseen=true`, {
        headers: {
          Authorization: this.auth
        }
      });
      if (t.ok) {
        const { events: g, error: i } = await t.json();
        if (i)
          throw new Error(`Check unseen events failed: ${i}`);
        const c = (n = g == null ? void 0 : g.filter((a) => a.event === "Web3Response").map((a) => ({
          type: "Event",
          sessionId: this.sessionId,
          eventId: a.id,
          event: a.event,
          data: a.data
        }))) !== null && n !== void 0 ? n : [];
        return this.markUnseenEventsAsSeen(c), c;
      }
      throw new Error(`Check unseen events failed: ${t.status}`);
    }
  };
  return mr.WalletLinkHTTP = e, mr;
}
var Rt = {}, Fo;
function Yl() {
  if (Fo) return Rt;
  Fo = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.WalletLinkWebSocket = Rt.ConnectionState = void 0;
  var e;
  (function(n) {
    n[n.DISCONNECTED = 0] = "DISCONNECTED", n[n.CONNECTING = 1] = "CONNECTING", n[n.CONNECTED = 2] = "CONNECTED";
  })(e || (Rt.ConnectionState = e = {}));
  let r = class {
    setConnectionStateListener(t) {
      this.connectionStateListener = t;
    }
    setIncomingDataListener(t) {
      this.incomingDataListener = t;
    }
    /**
     * Constructor
     * @param url WebSocket server URL
     * @param [WebSocketClass] Custom WebSocket implementation
     */
    constructor(t, g = WebSocket) {
      this.WebSocketClass = g, this.webSocket = null, this.pendingData = [], this.url = t.replace(/^http/, "ws");
    }
    /**
     * Make a websocket connection
     * @returns a Promise that resolves when connected
     */
    async connect() {
      if (this.webSocket)
        throw new Error("webSocket object is not null");
      return new Promise((t, g) => {
        var i;
        let c;
        try {
          this.webSocket = c = new this.WebSocketClass(this.url);
        } catch (a) {
          g(a);
          return;
        }
        (i = this.connectionStateListener) === null || i === void 0 || i.call(this, e.CONNECTING), c.onclose = (a) => {
          var d;
          this.clearWebSocket(), g(new Error(`websocket error ${a.code}: ${a.reason}`)), (d = this.connectionStateListener) === null || d === void 0 || d.call(this, e.DISCONNECTED);
        }, c.onopen = (a) => {
          var d;
          t(), (d = this.connectionStateListener) === null || d === void 0 || d.call(this, e.CONNECTED), this.pendingData.length > 0 && ([...this.pendingData].forEach((p) => this.sendData(p)), this.pendingData = []);
        }, c.onmessage = (a) => {
          var d, m;
          if (a.data === "h")
            (d = this.incomingDataListener) === null || d === void 0 || d.call(this, {
              type: "Heartbeat"
            });
          else
            try {
              const p = JSON.parse(a.data);
              (m = this.incomingDataListener) === null || m === void 0 || m.call(this, p);
            } catch {
            }
        };
      });
    }
    /**
     * Disconnect from server
     */
    disconnect() {
      var t;
      const { webSocket: g } = this;
      if (g) {
        this.clearWebSocket(), (t = this.connectionStateListener) === null || t === void 0 || t.call(this, e.DISCONNECTED), this.connectionStateListener = void 0, this.incomingDataListener = void 0;
        try {
          g.close();
        } catch {
        }
      }
    }
    /**
     * Send data to server
     * @param data text to send
     */
    sendData(t) {
      const { webSocket: g } = this;
      if (!g) {
        this.pendingData.push(t), this.connect();
        return;
      }
      g.send(t);
    }
    clearWebSocket() {
      const { webSocket: t } = this;
      t && (this.webSocket = null, t.onclose = null, t.onerror = null, t.onmessage = null, t.onopen = null);
    }
  };
  return Rt.WalletLinkWebSocket = r, Rt;
}
var Do;
function Xl() {
  if (Do) return pr;
  Do = 1, Object.defineProperty(pr, "__esModule", { value: !0 }), pr.WalletLinkConnection = void 0;
  const e = /* @__PURE__ */ mn(), r = /* @__PURE__ */ Kl(), n = /* @__PURE__ */ qs(), t = /* @__PURE__ */ js(), g = /* @__PURE__ */ $s(), i = /* @__PURE__ */ Ql(), c = /* @__PURE__ */ Yl(), a = 1e4, d = 6e4;
  let m = class {
    /**
     * Constructor
     * @param session Session
     * @param linkAPIUrl Coinbase Wallet link server URL
     * @param listener WalletLinkConnectionUpdateListener
     * @param [WebSocketClass] Custom WebSocket implementation
     */
    constructor({ session: o, linkAPIUrl: l, listener: s, diagnostic: f, WebSocketClass: b = WebSocket }) {
      this.destroyed = !1, this.lastHeartbeatResponse = 0, this.nextReqId = (0, e.IntNumber)(1), this._connected = !1, this._linked = !1, this.shouldFetchUnseenEventsOnConnect = !1, this.requestResolutions = /* @__PURE__ */ new Map(), this.handleSessionMetadataUpdated = (u) => {
        if (!u)
          return;
        (/* @__PURE__ */ new Map([
          ["__destroyed", this.handleDestroyed],
          ["EthereumAddress", this.handleAccountUpdated],
          ["WalletUsername", this.handleWalletUsernameUpdated],
          ["AppVersion", this.handleAppVersionUpdated],
          [
            "ChainId",
            (S) => u.JsonRpcUrl && this.handleChainUpdated(S, u.JsonRpcUrl)
          ]
        ])).forEach((S, I) => {
          const T = u[I];
          T !== void 0 && S(T);
        });
      }, this.handleDestroyed = (u) => {
        var R, S;
        u === "1" && ((R = this.listener) === null || R === void 0 || R.resetAndReload(), (S = this.diagnostic) === null || S === void 0 || S.log(n.EVENTS.METADATA_DESTROYED, {
          alreadyDestroyed: this.isDestroyed,
          sessionIdHash: g.Session.hash(this.session.id)
        }));
      }, this.handleAccountUpdated = async (u) => {
        var R, S;
        try {
          const I = await this.cipher.decrypt(u);
          (R = this.listener) === null || R === void 0 || R.accountUpdated(I);
        } catch {
          (S = this.diagnostic) === null || S === void 0 || S.log(n.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "selectedAddress"
          });
        }
      }, this.handleMetadataUpdated = async (u, R) => {
        var S, I;
        try {
          const T = await this.cipher.decrypt(R);
          (S = this.listener) === null || S === void 0 || S.metadataUpdated(u, T);
        } catch {
          (I = this.diagnostic) === null || I === void 0 || I.log(n.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: u
          });
        }
      }, this.handleWalletUsernameUpdated = async (u) => {
        this.handleMetadataUpdated(t.WALLET_USER_NAME_KEY, u);
      }, this.handleAppVersionUpdated = async (u) => {
        this.handleMetadataUpdated(t.APP_VERSION_KEY, u);
      }, this.handleChainUpdated = async (u, R) => {
        var S, I;
        try {
          const T = await this.cipher.decrypt(u), q = await this.cipher.decrypt(R);
          (S = this.listener) === null || S === void 0 || S.chainUpdated(T, q);
        } catch {
          (I = this.diagnostic) === null || I === void 0 || I.log(n.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "chainId|jsonRpcUrl"
          });
        }
      }, this.session = o, this.cipher = new r.Cipher(o.secret), this.diagnostic = f, this.listener = s;
      const y = new c.WalletLinkWebSocket(`${l}/rpc`, b);
      y.setConnectionStateListener(async (u) => {
        var R;
        (R = this.diagnostic) === null || R === void 0 || R.log(n.EVENTS.CONNECTED_STATE_CHANGE, {
          state: u,
          sessionIdHash: g.Session.hash(o.id)
        });
        let S = !1;
        switch (u) {
          case c.ConnectionState.DISCONNECTED:
            if (!this.destroyed) {
              const I = async () => {
                await new Promise((T) => setTimeout(T, 5e3)), this.destroyed || y.connect().catch(() => {
                  I();
                });
              };
              I();
            }
            break;
          case c.ConnectionState.CONNECTED:
            try {
              await this.authenticate(), this.sendIsLinked(), this.sendGetSessionConfig(), S = !0;
            } catch {
            }
            this.updateLastHeartbeat(), setInterval(() => {
              this.heartbeat();
            }, a), this.shouldFetchUnseenEventsOnConnect && this.fetchUnseenEventsAPI();
            break;
          case c.ConnectionState.CONNECTING:
            break;
        }
        this.connected !== S && (this.connected = S);
      }), y.setIncomingDataListener((u) => {
        var R, S, I;
        switch (u.type) {
          // handle server's heartbeat responses
          case "Heartbeat":
            this.updateLastHeartbeat();
            return;
          // handle link status updates
          case "IsLinkedOK":
          case "Linked": {
            const T = u.type === "IsLinkedOK" ? u.linked : void 0;
            (R = this.diagnostic) === null || R === void 0 || R.log(n.EVENTS.LINKED, {
              sessionIdHash: g.Session.hash(o.id),
              linked: T,
              type: u.type,
              onlineGuests: u.onlineGuests
            }), this.linked = T || u.onlineGuests > 0;
            break;
          }
          // handle session config updates
          case "GetSessionConfigOK":
          case "SessionConfigUpdated": {
            (S = this.diagnostic) === null || S === void 0 || S.log(n.EVENTS.SESSION_CONFIG_RECEIVED, {
              sessionIdHash: g.Session.hash(o.id),
              metadata_keys: u && u.metadata ? Object.keys(u.metadata) : void 0
            }), this.handleSessionMetadataUpdated(u.metadata);
            break;
          }
          case "Event": {
            this.handleIncomingEvent(u);
            break;
          }
        }
        u.id !== void 0 && ((I = this.requestResolutions.get(u.id)) === null || I === void 0 || I(u));
      }), this.ws = y, this.http = new i.WalletLinkHTTP(l, o.id, o.key);
    }
    /**
     * Make a connection to the server
     */
    connect() {
      var o;
      if (this.destroyed)
        throw new Error("instance is destroyed");
      (o = this.diagnostic) === null || o === void 0 || o.log(n.EVENTS.STARTED_CONNECTING, {
        sessionIdHash: g.Session.hash(this.session.id)
      }), this.ws.connect();
    }
    /**
     * Terminate connection, and mark as destroyed. To reconnect, create a new
     * instance of WalletSDKConnection
     */
    destroy() {
      var o;
      this.destroyed = !0, this.ws.disconnect(), (o = this.diagnostic) === null || o === void 0 || o.log(n.EVENTS.DISCONNECTED, {
        sessionIdHash: g.Session.hash(this.session.id)
      }), this.listener = void 0;
    }
    get isDestroyed() {
      return this.destroyed;
    }
    get connected() {
      return this._connected;
    }
    set connected(o) {
      var l, s;
      this._connected = o, o && ((l = this.onceConnected) === null || l === void 0 || l.call(this)), (s = this.listener) === null || s === void 0 || s.connectedUpdated(o);
    }
    setOnceConnected(o) {
      return new Promise((l) => {
        this.connected ? o().then(l) : this.onceConnected = () => {
          o().then(l), this.onceConnected = void 0;
        };
      });
    }
    get linked() {
      return this._linked;
    }
    set linked(o) {
      var l, s;
      this._linked = o, o && ((l = this.onceLinked) === null || l === void 0 || l.call(this)), (s = this.listener) === null || s === void 0 || s.linkedUpdated(o);
    }
    setOnceLinked(o) {
      return new Promise((l) => {
        this.linked ? o().then(l) : this.onceLinked = () => {
          o().then(l), this.onceLinked = void 0;
        };
      });
    }
    async handleIncomingEvent(o) {
      var l, s;
      if (!(o.type !== "Event" || o.event !== "Web3Response"))
        try {
          const f = await this.cipher.decrypt(o.data), b = JSON.parse(f);
          if (b.type !== "WEB3_RESPONSE")
            return;
          (l = this.listener) === null || l === void 0 || l.handleWeb3ResponseMessage(b);
        } catch {
          (s = this.diagnostic) === null || s === void 0 || s.log(n.EVENTS.GENERAL_ERROR, {
            message: "Had error decrypting",
            value: "incomingEvent"
          });
        }
    }
    async checkUnseenEvents() {
      if (!this.connected) {
        this.shouldFetchUnseenEventsOnConnect = !0;
        return;
      }
      await new Promise((o) => setTimeout(o, 250));
      try {
        await this.fetchUnseenEventsAPI();
      } catch (o) {
        console.error("Unable to check for unseen events", o);
      }
    }
    async fetchUnseenEventsAPI() {
      this.shouldFetchUnseenEventsOnConnect = !1, (await this.http.fetchUnseenEvents()).forEach((l) => this.handleIncomingEvent(l));
    }
    /**
     * Set session metadata in SessionConfig object
     * @param key
     * @param value
     * @returns a Promise that completes when successful
     */
    async setSessionMetadata(o, l) {
      const s = {
        type: "SetSessionConfig",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        metadata: { [o]: l }
      };
      return this.setOnceConnected(async () => {
        const f = await this.makeRequest(s);
        if (f.type === "Fail")
          throw new Error(f.error || "failed to set session metadata");
      });
    }
    /**
     * Publish an event and emit event ID when successful
     * @param event event name
     * @param unencryptedData unencrypted event data
     * @param callWebhook whether the webhook should be invoked
     * @returns a Promise that emits event ID when successful
     */
    async publishEvent(o, l, s = !1) {
      const f = await this.cipher.encrypt(JSON.stringify(Object.assign(Object.assign({}, l), { origin: location.origin, relaySource: window.coinbaseWalletExtension ? "injected_sdk" : "sdk" }))), b = {
        type: "PublishEvent",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        event: o,
        data: f,
        callWebhook: s
      };
      return this.setOnceLinked(async () => {
        const y = await this.makeRequest(b);
        if (y.type === "Fail")
          throw new Error(y.error || "failed to publish event");
        return y.eventId;
      });
    }
    sendData(o) {
      this.ws.sendData(JSON.stringify(o));
    }
    updateLastHeartbeat() {
      this.lastHeartbeatResponse = Date.now();
    }
    heartbeat() {
      if (Date.now() - this.lastHeartbeatResponse > a * 2) {
        this.ws.disconnect();
        return;
      }
      try {
        this.ws.sendData("h");
      } catch {
      }
    }
    async makeRequest(o, l = d) {
      const s = o.id;
      this.sendData(o);
      let f;
      return Promise.race([
        new Promise((b, y) => {
          f = window.setTimeout(() => {
            y(new Error(`request ${s} timed out`));
          }, l);
        }),
        new Promise((b) => {
          this.requestResolutions.set(s, (y) => {
            clearTimeout(f), b(y), this.requestResolutions.delete(s);
          });
        })
      ]);
    }
    async authenticate() {
      const o = {
        type: "HostSession",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id,
        sessionKey: this.session.key
      }, l = await this.makeRequest(o);
      if (l.type === "Fail")
        throw new Error(l.error || "failed to authentcate");
    }
    sendIsLinked() {
      const o = {
        type: "IsLinked",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id
      };
      this.sendData(o);
    }
    sendGetSessionConfig() {
      const o = {
        type: "GetSessionConfig",
        id: (0, e.IntNumber)(this.nextReqId++),
        sessionId: this.session.id
      };
      this.sendData(o);
    }
  };
  return pr.WalletLinkConnection = m, pr;
}
var wr = {}, qt = {}, Zr = {}, qo;
function eh() {
  return qo || (qo = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.default = '@namespace svg "http://www.w3.org/2000/svg";.-cbwsdk-css-reset,.-cbwsdk-css-reset *{animation:none;animation-delay:0;animation-direction:normal;animation-duration:0;animation-fill-mode:none;animation-iteration-count:1;animation-name:none;animation-play-state:running;animation-timing-function:ease;backface-visibility:visible;background:0;background-attachment:scroll;background-clip:border-box;background-color:rgba(0,0,0,0);background-image:none;background-origin:padding-box;background-position:0 0;background-position-x:0;background-position-y:0;background-repeat:repeat;background-size:auto auto;border:0;border-style:none;border-width:medium;border-color:inherit;border-bottom:0;border-bottom-color:inherit;border-bottom-left-radius:0;border-bottom-right-radius:0;border-bottom-style:none;border-bottom-width:medium;border-collapse:separate;border-image:none;border-left:0;border-left-color:inherit;border-left-style:none;border-left-width:medium;border-radius:0;border-right:0;border-right-color:inherit;border-right-style:none;border-right-width:medium;border-spacing:0;border-top:0;border-top-color:inherit;border-top-left-radius:0;border-top-right-radius:0;border-top-style:none;border-top-width:medium;box-shadow:none;box-sizing:border-box;caption-side:top;clear:none;clip:auto;color:inherit;columns:auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium none currentColor;column-rule-color:currentColor;column-rule-style:none;column-rule-width:none;column-span:1;column-width:auto;counter-increment:none;counter-reset:none;direction:ltr;empty-cells:show;float:none;font:normal;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;font-size:medium;font-style:normal;font-variant:normal;font-weight:normal;height:auto;hyphens:none;letter-spacing:normal;line-height:normal;list-style:none;list-style-image:none;list-style-position:outside;list-style-type:disc;margin:0;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;opacity:1;orphans:0;outline:0;outline-color:invert;outline-style:none;outline-width:medium;overflow:visible;overflow-x:visible;overflow-y:visible;padding:0;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;page-break-after:auto;page-break-before:auto;page-break-inside:auto;perspective:none;perspective-origin:50% 50%;pointer-events:auto;position:static;quotes:"\\201C" "\\201D" "\\2018" "\\2019";tab-size:8;table-layout:auto;text-align:inherit;text-align-last:auto;text-decoration:none;text-decoration-color:inherit;text-decoration-line:none;text-decoration-style:solid;text-indent:0;text-shadow:none;text-transform:none;transform:none;transform-style:flat;transition:none;transition-delay:0s;transition-duration:0s;transition-property:none;transition-timing-function:ease;unicode-bidi:normal;vertical-align:baseline;visibility:visible;white-space:normal;widows:0;word-spacing:normal;z-index:auto}.-cbwsdk-css-reset strong{font-weight:bold}.-cbwsdk-css-reset *{box-sizing:border-box;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Helvetica Neue",Arial,sans-serif;line-height:1}.-cbwsdk-css-reset [class*=container]{margin:0;padding:0}.-cbwsdk-css-reset style{display:none}'), Zr;
}
var jo;
function Gc() {
  if (jo) return qt;
  jo = 1;
  var e = qt.__importDefault || function(t) {
    return t && t.__esModule ? t : { default: t };
  };
  Object.defineProperty(qt, "__esModule", { value: !0 }), qt.injectCssReset = void 0;
  const r = e(/* @__PURE__ */ eh());
  function n() {
    const t = document.createElement("style");
    t.type = "text/css", t.appendChild(document.createTextNode(r.default)), document.documentElement.appendChild(t);
  }
  return qt.injectCssReset = n, qt;
}
var yr = {};
const We = /* @__PURE__ */ $r(Pl);
var jt = {};
function Zc(e) {
  var r, n, t = "";
  if (typeof e == "string" || typeof e == "number") t += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (r = 0; r < e.length; r++) e[r] && (n = Zc(e[r])) && (t && (t += " "), t += n);
  else for (r in e) e[r] && (t && (t += " "), t += r);
  return t;
}
function $o() {
  for (var e, r, n = 0, t = ""; n < arguments.length; ) (e = arguments[n++]) && (r = Zc(e)) && (t && (t += " "), t += r);
  return t;
}
const th = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clsx: $o,
  default: $o
}, Symbol.toStringTag, { value: "Module" })), Ur = /* @__PURE__ */ $r(th), yn = /* @__PURE__ */ $r(Ol);
var rt = {}, br = {}, Uo;
function rh() {
  if (Uo) return br;
  Uo = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.CloseIcon = void 0;
  const e = We;
  function r(n) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, n),
      (0, e.h)("path", { d: "M13.7677 13L12.3535 14.4142L18.3535 20.4142L12.3535 26.4142L13.7677 27.8284L19.7677 21.8284L25.7677 27.8284L27.1819 26.4142L21.1819 20.4142L27.1819 14.4142L25.7677 13L19.7677 19L13.7677 13Z" })
    );
  }
  return br.CloseIcon = r, br;
}
var vr = {}, Ho;
function nh() {
  if (Ho) return vr;
  Ho = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.CoinbaseWalletRound = void 0;
  const e = We;
  function r(n) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "28", height: "28", viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, n),
      (0, e.h)("circle", { cx: "14", cy: "14", r: "14", fill: "#0052FF" }),
      (0, e.h)("path", { d: "M23.8521 14.0003C23.8521 19.455 19.455 23.8521 14.0003 23.8521C8.54559 23.8521 4.14844 19.455 4.14844 14.0003C4.14844 8.54559 8.54559 4.14844 14.0003 4.14844C19.455 4.14844 23.8521 8.54559 23.8521 14.0003Z", fill: "white" }),
      (0, e.h)("path", { d: "M11.1855 12.5042C11.1855 12.0477 11.1855 11.7942 11.2835 11.642C11.3814 11.4899 11.4793 11.3377 11.6261 11.287C11.8219 11.1855 12.0178 11.1855 12.5073 11.1855H15.4934C15.983 11.1855 16.1788 11.1855 16.3746 11.287C16.5215 11.3884 16.6683 11.4899 16.7173 11.642C16.8152 11.8449 16.8152 12.0477 16.8152 12.5042V15.4965C16.8152 15.953 16.8152 16.2066 16.7173 16.3587C16.6194 16.5109 16.5215 16.663 16.3746 16.7137C16.1788 16.8152 15.983 16.8152 15.4934 16.8152H12.5073C12.0178 16.8152 11.8219 16.8152 11.6261 16.7137C11.4793 16.6123 11.3324 16.5109 11.2835 16.3587C11.1855 16.1558 11.1855 15.953 11.1855 15.4965V12.5042Z", fill: "#0052FF" })
    );
  }
  return vr.CoinbaseWalletRound = r, vr;
}
var _r = {}, Wo;
function ih() {
  if (Wo) return _r;
  Wo = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.QRCodeIcon = void 0;
  const e = We;
  function r(n) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "18", height: "18", viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg" }, n),
      (0, e.h)("path", { d: "M3 3V8.99939L5 8.99996V5H9V3H3Z" }),
      (0, e.h)("path", { d: "M15 21L21 21V15.0006L19 15V19L15 19V21Z" }),
      (0, e.h)("path", { d: "M21 9H19V5H15.0006L15 3H21V9Z" }),
      (0, e.h)("path", { d: "M3 15V21H8.99939L8.99996 19H5L5 15H3Z" })
    );
  }
  return _r.QRCodeIcon = r, _r;
}
var $t = {}, $n, Vo;
function sh() {
  if (Vo) return $n;
  Vo = 1;
  function e(s) {
    this.mode = n.MODE_8BIT_BYTE, this.data = s, this.parsedData = [];
    for (var f = 0, b = this.data.length; f < b; f++) {
      var y = [], u = this.data.charCodeAt(f);
      u > 65536 ? (y[0] = 240 | (u & 1835008) >>> 18, y[1] = 128 | (u & 258048) >>> 12, y[2] = 128 | (u & 4032) >>> 6, y[3] = 128 | u & 63) : u > 2048 ? (y[0] = 224 | (u & 61440) >>> 12, y[1] = 128 | (u & 4032) >>> 6, y[2] = 128 | u & 63) : u > 128 ? (y[0] = 192 | (u & 1984) >>> 6, y[1] = 128 | u & 63) : y[0] = u, this.parsedData.push(y);
    }
    this.parsedData = Array.prototype.concat.apply([], this.parsedData), this.parsedData.length != this.data.length && (this.parsedData.unshift(191), this.parsedData.unshift(187), this.parsedData.unshift(239));
  }
  e.prototype = {
    getLength: function(s) {
      return this.parsedData.length;
    },
    write: function(s) {
      for (var f = 0, b = this.parsedData.length; f < b; f++)
        s.put(this.parsedData[f], 8);
    }
  };
  function r(s, f) {
    this.typeNumber = s, this.errorCorrectLevel = f, this.modules = null, this.moduleCount = 0, this.dataCache = null, this.dataList = [];
  }
  r.prototype = { addData: function(s) {
    var f = new e(s);
    this.dataList.push(f), this.dataCache = null;
  }, isDark: function(s, f) {
    if (s < 0 || this.moduleCount <= s || f < 0 || this.moduleCount <= f)
      throw new Error(s + "," + f);
    return this.modules[s][f];
  }, getModuleCount: function() {
    return this.moduleCount;
  }, make: function() {
    this.makeImpl(!1, this.getBestMaskPattern());
  }, makeImpl: function(s, f) {
    this.moduleCount = this.typeNumber * 4 + 17, this.modules = new Array(this.moduleCount);
    for (var b = 0; b < this.moduleCount; b++) {
      this.modules[b] = new Array(this.moduleCount);
      for (var y = 0; y < this.moduleCount; y++)
        this.modules[b][y] = null;
    }
    this.setupPositionProbePattern(0, 0), this.setupPositionProbePattern(this.moduleCount - 7, 0), this.setupPositionProbePattern(0, this.moduleCount - 7), this.setupPositionAdjustPattern(), this.setupTimingPattern(), this.setupTypeInfo(s, f), this.typeNumber >= 7 && this.setupTypeNumber(s), this.dataCache == null && (this.dataCache = r.createData(this.typeNumber, this.errorCorrectLevel, this.dataList)), this.mapData(this.dataCache, f);
  }, setupPositionProbePattern: function(s, f) {
    for (var b = -1; b <= 7; b++)
      if (!(s + b <= -1 || this.moduleCount <= s + b))
        for (var y = -1; y <= 7; y++)
          f + y <= -1 || this.moduleCount <= f + y || (0 <= b && b <= 6 && (y == 0 || y == 6) || 0 <= y && y <= 6 && (b == 0 || b == 6) || 2 <= b && b <= 4 && 2 <= y && y <= 4 ? this.modules[s + b][f + y] = !0 : this.modules[s + b][f + y] = !1);
  }, getBestMaskPattern: function() {
    for (var s = 0, f = 0, b = 0; b < 8; b++) {
      this.makeImpl(!0, b);
      var y = i.getLostPoint(this);
      (b == 0 || s > y) && (s = y, f = b);
    }
    return f;
  }, createMovieClip: function(s, f, b) {
    var y = s.createEmptyMovieClip(f, b), u = 1;
    this.make();
    for (var R = 0; R < this.modules.length; R++)
      for (var S = R * u, I = 0; I < this.modules[R].length; I++) {
        var T = I * u, q = this.modules[R][I];
        q && (y.beginFill(0, 100), y.moveTo(T, S), y.lineTo(T + u, S), y.lineTo(T + u, S + u), y.lineTo(T, S + u), y.endFill());
      }
    return y;
  }, setupTimingPattern: function() {
    for (var s = 8; s < this.moduleCount - 8; s++)
      this.modules[s][6] == null && (this.modules[s][6] = s % 2 == 0);
    for (var f = 8; f < this.moduleCount - 8; f++)
      this.modules[6][f] == null && (this.modules[6][f] = f % 2 == 0);
  }, setupPositionAdjustPattern: function() {
    for (var s = i.getPatternPosition(this.typeNumber), f = 0; f < s.length; f++)
      for (var b = 0; b < s.length; b++) {
        var y = s[f], u = s[b];
        if (this.modules[y][u] == null)
          for (var R = -2; R <= 2; R++)
            for (var S = -2; S <= 2; S++)
              R == -2 || R == 2 || S == -2 || S == 2 || R == 0 && S == 0 ? this.modules[y + R][u + S] = !0 : this.modules[y + R][u + S] = !1;
      }
  }, setupTypeNumber: function(s) {
    for (var f = i.getBCHTypeNumber(this.typeNumber), b = 0; b < 18; b++) {
      var y = !s && (f >> b & 1) == 1;
      this.modules[Math.floor(b / 3)][b % 3 + this.moduleCount - 8 - 3] = y;
    }
    for (var b = 0; b < 18; b++) {
      var y = !s && (f >> b & 1) == 1;
      this.modules[b % 3 + this.moduleCount - 8 - 3][Math.floor(b / 3)] = y;
    }
  }, setupTypeInfo: function(s, f) {
    for (var b = this.errorCorrectLevel << 3 | f, y = i.getBCHTypeInfo(b), u = 0; u < 15; u++) {
      var R = !s && (y >> u & 1) == 1;
      u < 6 ? this.modules[u][8] = R : u < 8 ? this.modules[u + 1][8] = R : this.modules[this.moduleCount - 15 + u][8] = R;
    }
    for (var u = 0; u < 15; u++) {
      var R = !s && (y >> u & 1) == 1;
      u < 8 ? this.modules[8][this.moduleCount - u - 1] = R : u < 9 ? this.modules[8][15 - u - 1 + 1] = R : this.modules[8][15 - u - 1] = R;
    }
    this.modules[this.moduleCount - 8][8] = !s;
  }, mapData: function(s, f) {
    for (var b = -1, y = this.moduleCount - 1, u = 7, R = 0, S = this.moduleCount - 1; S > 0; S -= 2)
      for (S == 6 && S--; ; ) {
        for (var I = 0; I < 2; I++)
          if (this.modules[y][S - I] == null) {
            var T = !1;
            R < s.length && (T = (s[R] >>> u & 1) == 1);
            var q = i.getMask(f, y, S - I);
            q && (T = !T), this.modules[y][S - I] = T, u--, u == -1 && (R++, u = 7);
          }
        if (y += b, y < 0 || this.moduleCount <= y) {
          y -= b, b = -b;
          break;
        }
      }
  } }, r.PAD0 = 236, r.PAD1 = 17, r.createData = function(s, f, b) {
    for (var y = m.getRSBlocks(s, f), u = new p(), R = 0; R < b.length; R++) {
      var S = b[R];
      u.put(S.mode, 4), u.put(S.getLength(), i.getLengthInBits(S.mode, s)), S.write(u);
    }
    for (var I = 0, R = 0; R < y.length; R++)
      I += y[R].dataCount;
    if (u.getLengthInBits() > I * 8)
      throw new Error("code length overflow. (" + u.getLengthInBits() + ">" + I * 8 + ")");
    for (u.getLengthInBits() + 4 <= I * 8 && u.put(0, 4); u.getLengthInBits() % 8 != 0; )
      u.putBit(!1);
    for (; !(u.getLengthInBits() >= I * 8 || (u.put(r.PAD0, 8), u.getLengthInBits() >= I * 8)); )
      u.put(r.PAD1, 8);
    return r.createBytes(u, y);
  }, r.createBytes = function(s, f) {
    for (var b = 0, y = 0, u = 0, R = new Array(f.length), S = new Array(f.length), I = 0; I < f.length; I++) {
      var T = f[I].dataCount, q = f[I].totalCount - T;
      y = Math.max(y, T), u = Math.max(u, q), R[I] = new Array(T);
      for (var D = 0; D < R[I].length; D++)
        R[I][D] = 255 & s.buffer[D + b];
      b += T;
      var H = i.getErrorCorrectPolynomial(q), G = new d(R[I], H.getLength() - 1), X = G.mod(H);
      S[I] = new Array(H.getLength() - 1);
      for (var D = 0; D < S[I].length; D++) {
        var Y = D + X.getLength() - S[I].length;
        S[I][D] = Y >= 0 ? X.get(Y) : 0;
      }
    }
    for (var re = 0, D = 0; D < f.length; D++)
      re += f[D].totalCount;
    for (var F = new Array(re), h = 0, D = 0; D < y; D++)
      for (var I = 0; I < f.length; I++)
        D < R[I].length && (F[h++] = R[I][D]);
    for (var D = 0; D < u; D++)
      for (var I = 0; I < f.length; I++)
        D < S[I].length && (F[h++] = S[I][D]);
    return F;
  };
  for (var n = { MODE_NUMBER: 1, MODE_ALPHA_NUM: 2, MODE_8BIT_BYTE: 4, MODE_KANJI: 8 }, t = { L: 1, M: 0, Q: 3, H: 2 }, g = { PATTERN000: 0, PATTERN001: 1, PATTERN010: 2, PATTERN011: 3, PATTERN100: 4, PATTERN101: 5, PATTERN110: 6, PATTERN111: 7 }, i = { PATTERN_POSITION_TABLE: [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], G15: 1335, G18: 7973, G15_MASK: 21522, getBCHTypeInfo: function(s) {
    for (var f = s << 10; i.getBCHDigit(f) - i.getBCHDigit(i.G15) >= 0; )
      f ^= i.G15 << i.getBCHDigit(f) - i.getBCHDigit(i.G15);
    return (s << 10 | f) ^ i.G15_MASK;
  }, getBCHTypeNumber: function(s) {
    for (var f = s << 12; i.getBCHDigit(f) - i.getBCHDigit(i.G18) >= 0; )
      f ^= i.G18 << i.getBCHDigit(f) - i.getBCHDigit(i.G18);
    return s << 12 | f;
  }, getBCHDigit: function(s) {
    for (var f = 0; s != 0; )
      f++, s >>>= 1;
    return f;
  }, getPatternPosition: function(s) {
    return i.PATTERN_POSITION_TABLE[s - 1];
  }, getMask: function(s, f, b) {
    switch (s) {
      case g.PATTERN000:
        return (f + b) % 2 == 0;
      case g.PATTERN001:
        return f % 2 == 0;
      case g.PATTERN010:
        return b % 3 == 0;
      case g.PATTERN011:
        return (f + b) % 3 == 0;
      case g.PATTERN100:
        return (Math.floor(f / 2) + Math.floor(b / 3)) % 2 == 0;
      case g.PATTERN101:
        return f * b % 2 + f * b % 3 == 0;
      case g.PATTERN110:
        return (f * b % 2 + f * b % 3) % 2 == 0;
      case g.PATTERN111:
        return (f * b % 3 + (f + b) % 2) % 2 == 0;
      default:
        throw new Error("bad maskPattern:" + s);
    }
  }, getErrorCorrectPolynomial: function(s) {
    for (var f = new d([1], 0), b = 0; b < s; b++)
      f = f.multiply(new d([1, c.gexp(b)], 0));
    return f;
  }, getLengthInBits: function(s, f) {
    if (1 <= f && f < 10)
      switch (s) {
        case n.MODE_NUMBER:
          return 10;
        case n.MODE_ALPHA_NUM:
          return 9;
        case n.MODE_8BIT_BYTE:
          return 8;
        case n.MODE_KANJI:
          return 8;
        default:
          throw new Error("mode:" + s);
      }
    else if (f < 27)
      switch (s) {
        case n.MODE_NUMBER:
          return 12;
        case n.MODE_ALPHA_NUM:
          return 11;
        case n.MODE_8BIT_BYTE:
          return 16;
        case n.MODE_KANJI:
          return 10;
        default:
          throw new Error("mode:" + s);
      }
    else if (f < 41)
      switch (s) {
        case n.MODE_NUMBER:
          return 14;
        case n.MODE_ALPHA_NUM:
          return 13;
        case n.MODE_8BIT_BYTE:
          return 16;
        case n.MODE_KANJI:
          return 12;
        default:
          throw new Error("mode:" + s);
      }
    else
      throw new Error("type:" + f);
  }, getLostPoint: function(s) {
    for (var f = s.getModuleCount(), b = 0, y = 0; y < f; y++)
      for (var u = 0; u < f; u++) {
        for (var R = 0, S = s.isDark(y, u), I = -1; I <= 1; I++)
          if (!(y + I < 0 || f <= y + I))
            for (var T = -1; T <= 1; T++)
              u + T < 0 || f <= u + T || I == 0 && T == 0 || S == s.isDark(y + I, u + T) && R++;
        R > 5 && (b += 3 + R - 5);
      }
    for (var y = 0; y < f - 1; y++)
      for (var u = 0; u < f - 1; u++) {
        var q = 0;
        s.isDark(y, u) && q++, s.isDark(y + 1, u) && q++, s.isDark(y, u + 1) && q++, s.isDark(y + 1, u + 1) && q++, (q == 0 || q == 4) && (b += 3);
      }
    for (var y = 0; y < f; y++)
      for (var u = 0; u < f - 6; u++)
        s.isDark(y, u) && !s.isDark(y, u + 1) && s.isDark(y, u + 2) && s.isDark(y, u + 3) && s.isDark(y, u + 4) && !s.isDark(y, u + 5) && s.isDark(y, u + 6) && (b += 40);
    for (var u = 0; u < f; u++)
      for (var y = 0; y < f - 6; y++)
        s.isDark(y, u) && !s.isDark(y + 1, u) && s.isDark(y + 2, u) && s.isDark(y + 3, u) && s.isDark(y + 4, u) && !s.isDark(y + 5, u) && s.isDark(y + 6, u) && (b += 40);
    for (var D = 0, u = 0; u < f; u++)
      for (var y = 0; y < f; y++)
        s.isDark(y, u) && D++;
    var H = Math.abs(100 * D / f / f - 50) / 5;
    return b += H * 10, b;
  } }, c = { glog: function(s) {
    if (s < 1)
      throw new Error("glog(" + s + ")");
    return c.LOG_TABLE[s];
  }, gexp: function(s) {
    for (; s < 0; )
      s += 255;
    for (; s >= 256; )
      s -= 255;
    return c.EXP_TABLE[s];
  }, EXP_TABLE: new Array(256), LOG_TABLE: new Array(256) }, a = 0; a < 8; a++)
    c.EXP_TABLE[a] = 1 << a;
  for (var a = 8; a < 256; a++)
    c.EXP_TABLE[a] = c.EXP_TABLE[a - 4] ^ c.EXP_TABLE[a - 5] ^ c.EXP_TABLE[a - 6] ^ c.EXP_TABLE[a - 8];
  for (var a = 0; a < 255; a++)
    c.LOG_TABLE[c.EXP_TABLE[a]] = a;
  function d(s, f) {
    if (s.length == null)
      throw new Error(s.length + "/" + f);
    for (var b = 0; b < s.length && s[b] == 0; )
      b++;
    this.num = new Array(s.length - b + f);
    for (var y = 0; y < s.length - b; y++)
      this.num[y] = s[y + b];
  }
  d.prototype = { get: function(s) {
    return this.num[s];
  }, getLength: function() {
    return this.num.length;
  }, multiply: function(s) {
    for (var f = new Array(this.getLength() + s.getLength() - 1), b = 0; b < this.getLength(); b++)
      for (var y = 0; y < s.getLength(); y++)
        f[b + y] ^= c.gexp(c.glog(this.get(b)) + c.glog(s.get(y)));
    return new d(f, 0);
  }, mod: function(s) {
    if (this.getLength() - s.getLength() < 0)
      return this;
    for (var f = c.glog(this.get(0)) - c.glog(s.get(0)), b = new Array(this.getLength()), y = 0; y < this.getLength(); y++)
      b[y] = this.get(y);
    for (var y = 0; y < s.getLength(); y++)
      b[y] ^= c.gexp(c.glog(s.get(y)) + f);
    return new d(b, 0).mod(s);
  } };
  function m(s, f) {
    this.totalCount = s, this.dataCount = f;
  }
  m.RS_BLOCK_TABLE = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], m.getRSBlocks = function(s, f) {
    var b = m.getRsBlockTable(s, f);
    if (b == null)
      throw new Error("bad rs block @ typeNumber:" + s + "/errorCorrectLevel:" + f);
    for (var y = b.length / 3, u = [], R = 0; R < y; R++)
      for (var S = b[R * 3 + 0], I = b[R * 3 + 1], T = b[R * 3 + 2], q = 0; q < S; q++)
        u.push(new m(I, T));
    return u;
  }, m.getRsBlockTable = function(s, f) {
    switch (f) {
      case t.L:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 0];
      case t.M:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 1];
      case t.Q:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 2];
      case t.H:
        return m.RS_BLOCK_TABLE[(s - 1) * 4 + 3];
      default:
        return;
    }
  };
  function p() {
    this.buffer = [], this.length = 0;
  }
  p.prototype = { get: function(s) {
    var f = Math.floor(s / 8);
    return (this.buffer[f] >>> 7 - s % 8 & 1) == 1;
  }, put: function(s, f) {
    for (var b = 0; b < f; b++)
      this.putBit((s >>> f - b - 1 & 1) == 1);
  }, getLengthInBits: function() {
    return this.length;
  }, putBit: function(s) {
    var f = Math.floor(this.length / 8);
    this.buffer.length <= f && this.buffer.push(0), s && (this.buffer[f] |= 128 >>> this.length % 8), this.length++;
  } };
  var o = [[17, 14, 11, 7], [32, 26, 20, 14], [53, 42, 32, 24], [78, 62, 46, 34], [106, 84, 60, 44], [134, 106, 74, 58], [154, 122, 86, 64], [192, 152, 108, 84], [230, 180, 130, 98], [271, 213, 151, 119], [321, 251, 177, 137], [367, 287, 203, 155], [425, 331, 241, 177], [458, 362, 258, 194], [520, 412, 292, 220], [586, 450, 322, 250], [644, 504, 364, 280], [718, 560, 394, 310], [792, 624, 442, 338], [858, 666, 482, 382], [929, 711, 509, 403], [1003, 779, 565, 439], [1091, 857, 611, 461], [1171, 911, 661, 511], [1273, 997, 715, 535], [1367, 1059, 751, 593], [1465, 1125, 805, 625], [1528, 1190, 868, 658], [1628, 1264, 908, 698], [1732, 1370, 982, 742], [1840, 1452, 1030, 790], [1952, 1538, 1112, 842], [2068, 1628, 1168, 898], [2188, 1722, 1228, 958], [2303, 1809, 1283, 983], [2431, 1911, 1351, 1051], [2563, 1989, 1423, 1093], [2699, 2099, 1499, 1139], [2809, 2213, 1579, 1219], [2953, 2331, 1663, 1273]];
  function l(s) {
    if (this.options = {
      padding: 4,
      width: 256,
      height: 256,
      typeNumber: 4,
      color: "#000000",
      background: "#ffffff",
      ecl: "M",
      image: {
        svg: "",
        width: 0,
        height: 0
      }
    }, typeof s == "string" && (s = {
      content: s
    }), s)
      for (var f in s)
        this.options[f] = s[f];
    if (typeof this.options.content != "string")
      throw new Error("Expected 'content' as string!");
    if (this.options.content.length === 0)
      throw new Error("Expected 'content' to be non-empty!");
    if (!(this.options.padding >= 0))
      throw new Error("Expected 'padding' value to be non-negative!");
    if (!(this.options.width > 0) || !(this.options.height > 0))
      throw new Error("Expected 'width' or 'height' value to be higher than zero!");
    function b(T) {
      switch (T) {
        case "L":
          return t.L;
        case "M":
          return t.M;
        case "Q":
          return t.Q;
        case "H":
          return t.H;
        default:
          throw new Error("Unknwon error correction level: " + T);
      }
    }
    function y(T, q) {
      for (var D = u(T), H = 1, G = 0, X = 0, Y = o.length; X <= Y; X++) {
        var re = o[X];
        if (!re)
          throw new Error("Content too long: expected " + G + " but got " + D);
        switch (q) {
          case "L":
            G = re[0];
            break;
          case "M":
            G = re[1];
            break;
          case "Q":
            G = re[2];
            break;
          case "H":
            G = re[3];
            break;
          default:
            throw new Error("Unknwon error correction level: " + q);
        }
        if (D <= G)
          break;
        H++;
      }
      if (H > o.length)
        throw new Error("Content too long");
      return H;
    }
    function u(T) {
      var q = encodeURI(T).toString().replace(/\%[0-9a-fA-F]{2}/g, "a");
      return q.length + (q.length != T ? 3 : 0);
    }
    var R = this.options.content, S = y(R, this.options.ecl), I = b(this.options.ecl);
    this.qrcode = new r(S, I), this.qrcode.addData(R), this.qrcode.make();
  }
  return l.prototype.svg = function(s) {
    var f = this.options || {}, b = this.qrcode.modules;
    typeof s > "u" && (s = { container: f.container || "svg" });
    for (var y = typeof f.pretty < "u" ? !!f.pretty : !0, u = y ? "  " : "", R = y ? `\r
` : "", S = f.width, I = f.height, T = b.length, q = S / (T + 2 * f.padding), D = I / (T + 2 * f.padding), H = typeof f.join < "u" ? !!f.join : !1, G = typeof f.swap < "u" ? !!f.swap : !1, X = typeof f.xmlDeclaration < "u" ? !!f.xmlDeclaration : !0, Y = typeof f.predefined < "u" ? !!f.predefined : !1, re = Y ? u + '<defs><path id="qrmodule" d="M0 0 h' + D + " v" + q + ' H0 z" style="fill:' + f.color + ';shape-rendering:crispEdges;" /></defs>' + R : "", F = u + '<rect x="0" y="0" width="' + S + '" height="' + I + '" style="fill:' + f.background + ';shape-rendering:crispEdges;"/>' + R, h = "", E = "", C = 0; C < T; C++)
      for (var M = 0; M < T; M++) {
        var x = b[M][C];
        if (x) {
          var B = M * q + f.padding * q, j = C * D + f.padding * D;
          if (G) {
            var A = B;
            B = j, j = A;
          }
          if (H) {
            var v = q + B, N = D + j;
            B = Number.isInteger(B) ? Number(B) : B.toFixed(2), j = Number.isInteger(j) ? Number(j) : j.toFixed(2), v = Number.isInteger(v) ? Number(v) : v.toFixed(2), N = Number.isInteger(N) ? Number(N) : N.toFixed(2), E += "M" + B + "," + j + " V" + N + " H" + v + " V" + j + " H" + B + " Z ";
          } else Y ? h += u + '<use x="' + B.toString() + '" y="' + j.toString() + '" href="#qrmodule" />' + R : h += u + '<rect x="' + B.toString() + '" y="' + j.toString() + '" width="' + q + '" height="' + D + '" style="fill:' + f.color + ';shape-rendering:crispEdges;"/>' + R;
        }
      }
    H && (h = u + '<path x="0" y="0" style="fill:' + f.color + ';shape-rendering:crispEdges;" d="' + E + '" />');
    let te = "";
    if (this.options.image !== void 0 && this.options.image.svg) {
      const $ = S * this.options.image.width / 100, W = I * this.options.image.height / 100, J = S / 2 - $ / 2, ee = I / 2 - W / 2;
      te += `<svg x="${J}" y="${ee}" width="${$}" height="${W}" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">`, te += this.options.image.svg + R, te += "</svg>";
    }
    var K = "";
    switch (s.container) {
      //Wrapped in SVG document
      case "svg":
        X && (K += '<?xml version="1.0" standalone="yes"?>' + R), K += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="' + S + '" height="' + I + '">' + R, K += re + F + h, K += te, K += "</svg>";
        break;
      //Viewbox for responsive use in a browser, thanks to @danioso
      case "svg-viewbox":
        X && (K += '<?xml version="1.0" standalone="yes"?>' + R), K += '<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 ' + S + " " + I + '">' + R, K += re + F + h, K += te, K += "</svg>";
        break;
      //Wrapped in group element
      case "g":
        K += '<g width="' + S + '" height="' + I + '">' + R, K += re + F + h, K += te, K += "</g>";
        break;
      //Without a container
      default:
        K += (re + F + h + te).replace(/^\s+/, "");
        break;
    }
    return K;
  }, $n = l, $n;
}
var zo;
function oh() {
  if (zo) return $t;
  zo = 1;
  var e = $t.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty($t, "__esModule", { value: !0 }), $t.QRCode = void 0;
  const r = We, n = yn, t = e(/* @__PURE__ */ sh()), g = (i) => {
    const [c, a] = (0, n.useState)("");
    return (0, n.useEffect)(() => {
      var d, m;
      const p = new t.default({
        content: i.content,
        background: i.bgColor || "#ffffff",
        color: i.fgColor || "#000000",
        container: "svg",
        ecl: "M",
        width: (d = i.width) !== null && d !== void 0 ? d : 256,
        height: (m = i.height) !== null && m !== void 0 ? m : 256,
        padding: 0,
        image: i.image
      }), o = Buffer.from(p.svg(), "utf8").toString("base64");
      a(`data:image/svg+xml;base64,${o}`);
    }, [i.bgColor, i.content, i.fgColor, i.height, i.image, i.width]), c ? (0, r.h)("img", { src: c, alt: "QR Code" }) : null;
  };
  return $t.QRCode = g, $t;
}
var Ut = {}, Kr = {}, Jo;
function ah() {
  return Jo || (Jo = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.default = ".-cbwsdk-css-reset .-cbwsdk-spinner{display:inline-block}.-cbwsdk-css-reset .-cbwsdk-spinner svg{display:inline-block;animation:2s linear infinite -cbwsdk-spinner-svg}.-cbwsdk-css-reset .-cbwsdk-spinner svg circle{animation:1.9s ease-in-out infinite both -cbwsdk-spinner-circle;display:block;fill:rgba(0,0,0,0);stroke-dasharray:283;stroke-dashoffset:280;stroke-linecap:round;stroke-width:10px;transform-origin:50% 50%}@keyframes -cbwsdk-spinner-svg{0%{transform:rotateZ(0deg)}100%{transform:rotateZ(360deg)}}@keyframes -cbwsdk-spinner-circle{0%,25%{stroke-dashoffset:280;transform:rotate(0)}50%,75%{stroke-dashoffset:75;transform:rotate(45deg)}100%{stroke-dashoffset:280;transform:rotate(360deg)}}"), Kr;
}
var Go;
function uh() {
  if (Go) return Ut;
  Go = 1;
  var e = Ut.__importDefault || function(g) {
    return g && g.__esModule ? g : { default: g };
  };
  Object.defineProperty(Ut, "__esModule", { value: !0 }), Ut.Spinner = void 0;
  const r = We, n = e(/* @__PURE__ */ ah()), t = (g) => {
    var i;
    const c = (i = g.size) !== null && i !== void 0 ? i : 64, a = g.color || "#000";
    return (0, r.h)(
      "div",
      { class: "-cbwsdk-spinner" },
      (0, r.h)("style", null, n.default),
      (0, r.h)(
        "svg",
        { viewBox: "0 0 100 100", xmlns: "http://www.w3.org/2000/svg", style: { width: c, height: c } },
        (0, r.h)("circle", { style: { cx: 50, cy: 50, r: 45, stroke: a } })
      )
    );
  };
  return Ut.Spinner = t, Ut;
}
var Qr = {}, Zo;
function ch() {
  return Zo || (Zo = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.default = ".-cbwsdk-css-reset .-cbwsdk-connect-content{height:430px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-connect-content.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-header{display:flex;align-items:center;justify-content:space-between;margin:0 0 30px}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading{font-style:normal;font-weight:500;font-size:28px;line-height:36px;margin:0}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-layout{display:flex;flex-direction:row}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-left{margin-right:30px;display:flex;flex-direction:column;justify-content:space-between}.-cbwsdk-css-reset .-cbwsdk-connect-content-column-right{flex:25%;margin-right:34px}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-wrapper{width:220px;height:220px;border-radius:12px;display:flex;justify-content:center;align-items:center;background:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting{position:absolute;top:0;bottom:0;left:0;right:0;display:flex;flex-direction:column;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light{background-color:rgba(255,255,255,.95)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.light>p{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark{background-color:rgba(10,11,13,.9)}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting.dark>p{color:#fff}.-cbwsdk-css-reset .-cbwsdk-connect-content-qr-connecting>p{font-size:12px;font-weight:bold;margin-top:16px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app{border-radius:8px;font-size:14px;line-height:20px;padding:12px;width:339px}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.light{background:#eef0f3;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-connect-content-update-app.dark{background:#1e2025;color:#8a919e}.-cbwsdk-css-reset .-cbwsdk-cancel-button{-webkit-appearance:none;border:none;background:none;cursor:pointer;padding:0;margin:0}.-cbwsdk-css-reset .-cbwsdk-cancel-button-x{position:relative;display:block;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-wallet-steps{padding:0 0 0 16px;margin:0;width:100%;list-style:decimal}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item{list-style-type:decimal;display:list-item;font-style:normal;font-weight:400;font-size:16px;line-height:24px;margin-top:20px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-item-wrapper{display:flex;align-items:center}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-pad-left{margin-left:6px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon{display:flex;border-radius:50%;height:24px;width:24px}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.light{background:#0052ff}.-cbwsdk-css-reset .-cbwsdk-wallet-steps-icon.dark{background:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item{align-items:center;display:flex;flex-direction:row;padding:16px 24px;gap:12px;cursor:pointer;border-radius:100px;font-weight:600}.-cbwsdk-css-reset .-cbwsdk-connect-item.light{background:#f5f8ff;color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-connect-item.dark{background:#001033;color:#588af5}.-cbwsdk-css-reset .-cbwsdk-connect-item-copy-wrapper{margin:0 4px 0 8px}.-cbwsdk-css-reset .-cbwsdk-connect-item-title{margin:0 0 0;font-size:16px;line-height:24px;font-weight:500}.-cbwsdk-css-reset .-cbwsdk-connect-item-description{font-weight:400;font-size:14px;line-height:20px;margin:0}"), Qr;
}
var Ko;
function lh() {
  if (Ko) return rt;
  Ko = 1;
  var e = rt.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(rt, "__esModule", { value: !0 }), rt.CoinbaseWalletSteps = rt.ConnectContent = void 0;
  const r = e(Ur), n = We, t = /* @__PURE__ */ tt(), g = /* @__PURE__ */ Ds(), i = /* @__PURE__ */ rh(), c = /* @__PURE__ */ nh(), a = /* @__PURE__ */ ih(), d = /* @__PURE__ */ oh(), m = /* @__PURE__ */ uh(), p = e(/* @__PURE__ */ ch()), o = {
    title: "Coinbase Wallet app",
    description: "Connect with your self-custody wallet",
    steps: b
  }, l = (y) => y === "light" ? "#FFFFFF" : "#0A0B0D";
  function s(y) {
    const { theme: u } = y, R = (0, t.createQrUrl)(y.sessionId, y.sessionSecret, y.linkAPIUrl, y.isParentConnection, y.version, y.chainId), S = o.steps;
    return (0, n.h)(
      "div",
      { "data-testid": "connect-content", className: (0, r.default)("-cbwsdk-connect-content", u) },
      (0, n.h)("style", null, p.default),
      (0, n.h)(
        "div",
        { className: "-cbwsdk-connect-content-header" },
        (0, n.h)("h2", { className: (0, r.default)("-cbwsdk-connect-content-heading", u) }, "Scan to connect with our mobile app"),
        y.onCancel && (0, n.h)(
          "button",
          { type: "button", className: "-cbwsdk-cancel-button", onClick: y.onCancel },
          (0, n.h)(i.CloseIcon, { fill: u === "light" ? "#0A0B0D" : "#FFFFFF" })
        )
      ),
      (0, n.h)(
        "div",
        { className: "-cbwsdk-connect-content-layout" },
        (0, n.h)(
          "div",
          { className: "-cbwsdk-connect-content-column-left" },
          (0, n.h)(f, { title: o.title, description: o.description, theme: u })
        ),
        (0, n.h)(
          "div",
          { className: "-cbwsdk-connect-content-column-right" },
          (0, n.h)(
            "div",
            { className: "-cbwsdk-connect-content-qr-wrapper" },
            (0, n.h)(d.QRCode, { content: R, width: 200, height: 200, fgColor: "#000", bgColor: "transparent" }),
            (0, n.h)("input", { type: "hidden", name: "cbw-cbwsdk-version", value: g.LIB_VERSION }),
            (0, n.h)("input", { type: "hidden", value: R })
          ),
          (0, n.h)(S, { theme: u }),
          !y.isConnected && (0, n.h)(
            "div",
            { "data-testid": "connecting-spinner", className: (0, r.default)("-cbwsdk-connect-content-qr-connecting", u) },
            (0, n.h)(m.Spinner, { size: 36, color: u === "dark" ? "#FFF" : "#000" }),
            (0, n.h)("p", null, "Connecting...")
          )
        )
      )
    );
  }
  rt.ConnectContent = s;
  function f({ title: y, description: u, theme: R }) {
    return (0, n.h)(
      "div",
      { className: (0, r.default)("-cbwsdk-connect-item", R) },
      (0, n.h)(
        "div",
        null,
        (0, n.h)(c.CoinbaseWalletRound, null)
      ),
      (0, n.h)(
        "div",
        { className: "-cbwsdk-connect-item-copy-wrapper" },
        (0, n.h)("h3", { className: "-cbwsdk-connect-item-title" }, y),
        (0, n.h)("p", { className: "-cbwsdk-connect-item-description" }, u)
      )
    );
  }
  function b({ theme: y }) {
    return (0, n.h)(
      "ol",
      { className: "-cbwsdk-wallet-steps" },
      (0, n.h)(
        "li",
        { className: (0, r.default)("-cbwsdk-wallet-steps-item", y) },
        (0, n.h)("div", { className: "-cbwsdk-wallet-steps-item-wrapper" }, "Open Coinbase Wallet app")
      ),
      (0, n.h)(
        "li",
        { className: (0, r.default)("-cbwsdk-wallet-steps-item", y) },
        (0, n.h)(
          "div",
          { className: "-cbwsdk-wallet-steps-item-wrapper" },
          (0, n.h)(
            "span",
            null,
            "Tap ",
            (0, n.h)("strong", null, "Scan"),
            " "
          ),
          (0, n.h)(
            "span",
            { className: (0, r.default)("-cbwsdk-wallet-steps-pad-left", "-cbwsdk-wallet-steps-icon", y) },
            (0, n.h)(a.QRCodeIcon, { fill: l(y) })
          )
        )
      )
    );
  }
  return rt.CoinbaseWalletSteps = b, rt;
}
var Ht = {}, Er = {}, Qo;
function hh() {
  if (Qo) return Er;
  Qo = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.ArrowLeftIcon = void 0;
  const e = We;
  function r(n) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "16", height: "16", viewBox: "0 0 16 16", xmlns: "http://www.w3.org/2000/svg" }, n),
      (0, e.h)("path", { d: "M8.60675 0.155884L7.37816 1.28209L12.7723 7.16662H0V8.83328H12.6548L6.82149 14.6666L8 15.8451L15.8201 8.02501L8.60675 0.155884Z" })
    );
  }
  return Er.ArrowLeftIcon = r, Er;
}
var Rr = {}, Yo;
function dh() {
  if (Yo) return Rr;
  Yo = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.LaptopIcon = void 0;
  const e = We;
  function r(n) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, n),
      (0, e.h)("path", { d: "M1.8001 2.2002H12.2001V9.40019H1.8001V2.2002ZM3.4001 3.8002V7.80019H10.6001V3.8002H3.4001Z" }),
      (0, e.h)("path", { d: "M13.4001 10.2002H0.600098C0.600098 11.0838 1.31644 11.8002 2.2001 11.8002H11.8001C12.6838 11.8002 13.4001 11.0838 13.4001 10.2002Z" })
    );
  }
  return Rr.LaptopIcon = r, Rr;
}
var Sr = {}, Xo;
function fh() {
  if (Xo) return Sr;
  Xo = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.SafeIcon = void 0;
  const e = We;
  function r(n) {
    return (0, e.h)(
      "svg",
      Object.assign({ width: "14", height: "14", viewBox: "0 0 14 14", xmlns: "http://www.w3.org/2000/svg" }, n),
      (0, e.h)("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M0.600098 0.600098V11.8001H13.4001V0.600098H0.600098ZM7.0001 9.2001C5.3441 9.2001 4.0001 7.8561 4.0001 6.2001C4.0001 4.5441 5.3441 3.2001 7.0001 3.2001C8.6561 3.2001 10.0001 4.5441 10.0001 6.2001C10.0001 7.8561 8.6561 9.2001 7.0001 9.2001ZM0.600098 12.6001H3.8001V13.4001H0.600098V12.6001ZM10.2001 12.6001H13.4001V13.4001H10.2001V12.6001ZM8.8001 6.2001C8.8001 7.19421 7.99421 8.0001 7.0001 8.0001C6.00598 8.0001 5.2001 7.19421 5.2001 6.2001C5.2001 5.20598 6.00598 4.4001 7.0001 4.4001C7.99421 4.4001 8.8001 5.20598 8.8001 6.2001Z" })
    );
  }
  return Sr.SafeIcon = r, Sr;
}
var Yr = {}, ea;
function ph() {
  return ea || (ea = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.default = ".-cbwsdk-css-reset .-cbwsdk-try-extension{display:flex;margin-top:12px;height:202px;width:700px;border-radius:12px;padding:30px}.-cbwsdk-css-reset .-cbwsdk-try-extension.light{background:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension.dark{background:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-column-half{flex:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading{font-style:normal;font-weight:500;font-size:25px;line-height:32px;margin:0;max-width:204px}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.light{color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-try-extension-heading.dark{color:#fff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta{appearance:none;border:none;background:none;color:#0052ff;cursor:pointer;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.light{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta.dark{color:#588af5}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-wrapper{display:flex;align-items:center;margin-top:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-cta-icon{display:block;margin-left:4px;height:14px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list{display:flex;flex-direction:column;justify-content:center;align-items:center;margin:0;padding:0;list-style:none;height:100%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item{display:flex;align-items:center;flex-flow:nowrap;margin-top:24px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item:first-of-type{margin-top:0}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon-wrapper{display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon{display:flex;height:32px;width:32px;border-radius:50%}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon svg{margin:auto;display:block}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.light{background:#eef0f3}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-icon.dark{background:#1e2025}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy{display:block;font-weight:400;font-size:14px;line-height:20px;padding-left:12px}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.light{color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-try-extension-list-item-copy.dark{color:#8a919e}"), Yr;
}
var ta;
function gh() {
  if (ta) return Ht;
  ta = 1;
  var e = Ht.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(Ht, "__esModule", { value: !0 }), Ht.TryExtensionContent = void 0;
  const r = e(Ur), n = We, t = yn, g = /* @__PURE__ */ hh(), i = /* @__PURE__ */ dh(), c = /* @__PURE__ */ fh(), a = e(/* @__PURE__ */ ph());
  function d({ theme: m }) {
    const [p, o] = (0, t.useState)(!1), l = (0, t.useCallback)(() => {
      window.open("https://api.wallet.coinbase.com/rpc/v2/desktop/chrome", "_blank");
    }, []), s = (0, t.useCallback)(() => {
      p ? window.location.reload() : (l(), o(!0));
    }, [l, p]);
    return (0, n.h)(
      "div",
      { class: (0, r.default)("-cbwsdk-try-extension", m) },
      (0, n.h)("style", null, a.default),
      (0, n.h)(
        "div",
        { class: "-cbwsdk-try-extension-column-half" },
        (0, n.h)("h3", { class: (0, r.default)("-cbwsdk-try-extension-heading", m) }, "Or try the Coinbase Wallet browser extension"),
        (0, n.h)(
          "div",
          { class: "-cbwsdk-try-extension-cta-wrapper" },
          (0, n.h)("button", { class: (0, r.default)("-cbwsdk-try-extension-cta", m), onClick: s }, p ? "Refresh" : "Install"),
          (0, n.h)("div", null, !p && (0, n.h)(g.ArrowLeftIcon, { class: "-cbwsdk-try-extension-cta-icon", fill: m === "light" ? "#0052FF" : "#588AF5" }))
        )
      ),
      (0, n.h)(
        "div",
        { class: "-cbwsdk-try-extension-column-half" },
        (0, n.h)(
          "ul",
          { class: "-cbwsdk-try-extension-list" },
          (0, n.h)(
            "li",
            { class: "-cbwsdk-try-extension-list-item" },
            (0, n.h)(
              "div",
              { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
              (0, n.h)(
                "span",
                { class: (0, r.default)("-cbwsdk-try-extension-list-item-icon", m) },
                (0, n.h)(i.LaptopIcon, { fill: m === "light" ? "#0A0B0D" : "#FFFFFF" })
              )
            ),
            (0, n.h)("div", { class: (0, r.default)("-cbwsdk-try-extension-list-item-copy", m) }, "Connect with dapps with just one click on your desktop browser")
          ),
          (0, n.h)(
            "li",
            { class: "-cbwsdk-try-extension-list-item" },
            (0, n.h)(
              "div",
              { class: "-cbwsdk-try-extension-list-item-icon-wrapper" },
              (0, n.h)(
                "span",
                { class: (0, r.default)("-cbwsdk-try-extension-list-item-icon", m) },
                (0, n.h)(c.SafeIcon, { fill: m === "light" ? "#0A0B0D" : "#FFFFFF" })
              )
            ),
            (0, n.h)("div", { class: (0, r.default)("-cbwsdk-try-extension-list-item-copy", m) }, "Add an additional layer of security by using a supported Ledger hardware wallet")
          )
        )
      )
    );
  }
  return Ht.TryExtensionContent = d, Ht;
}
var Xr = {}, ra;
function mh() {
  return ra || (ra = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.default = ".-cbwsdk-css-reset .-cbwsdk-connect-dialog{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop{z-index:2147483647;position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.light{background-color:rgba(0,0,0,.5)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop.dark{background-color:rgba(50,53,61,.4)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box{display:flex;position:relative;flex-direction:column;transform:scale(1);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-box-hidden{opacity:0;transform:scale(0.85)}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container{display:block}.-cbwsdk-css-reset .-cbwsdk-connect-dialog-container-hidden{display:none}"), Xr;
}
var na;
function wh() {
  if (na) return jt;
  na = 1;
  var e = jt.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(jt, "__esModule", { value: !0 }), jt.ConnectDialog = void 0;
  const r = e(Ur), n = We, t = yn, g = /* @__PURE__ */ lh(), i = /* @__PURE__ */ gh(), c = e(/* @__PURE__ */ mh()), a = (d) => {
    const { isOpen: m, darkMode: p } = d, [o, l] = (0, t.useState)(!m), [s, f] = (0, t.useState)(!m);
    (0, t.useEffect)(() => {
      const y = [
        window.setTimeout(() => {
          f(!m);
        }, 10)
      ];
      return m ? l(!1) : y.push(window.setTimeout(() => {
        l(!0);
      }, 360)), () => {
        y.forEach(window.clearTimeout);
      };
    }, [m]);
    const b = p ? "dark" : "light";
    return (0, n.h)(
      "div",
      { class: (0, r.default)("-cbwsdk-connect-dialog-container", o && "-cbwsdk-connect-dialog-container-hidden") },
      (0, n.h)("style", null, c.default),
      (0, n.h)("div", { class: (0, r.default)("-cbwsdk-connect-dialog-backdrop", b, s && "-cbwsdk-connect-dialog-backdrop-hidden") }),
      (0, n.h)(
        "div",
        { class: "-cbwsdk-connect-dialog" },
        (0, n.h)(
          "div",
          { class: (0, r.default)("-cbwsdk-connect-dialog-box", s && "-cbwsdk-connect-dialog-box-hidden") },
          d.connectDisabled ? null : (0, n.h)(g.ConnectContent, { theme: b, version: d.version, sessionId: d.sessionId, sessionSecret: d.sessionSecret, linkAPIUrl: d.linkAPIUrl, isConnected: d.isConnected, isParentConnection: d.isParentConnection, chainId: d.chainId, onCancel: d.onCancel }),
          (0, n.h)(i.TryExtensionContent, { theme: b })
        )
      )
    );
  };
  return jt.ConnectDialog = a, jt;
}
var ia;
function yh() {
  if (ia) return yr;
  ia = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.LinkFlow = void 0;
  const e = We, r = /* @__PURE__ */ wh();
  let n = class {
    constructor(g) {
      this.connected = !1, this.chainId = 1, this.isOpen = !1, this.onCancel = null, this.root = null, this.connectDisabled = !1, this.darkMode = g.darkMode, this.version = g.version, this.sessionId = g.sessionId, this.sessionSecret = g.sessionSecret, this.linkAPIUrl = g.linkAPIUrl, this.isParentConnection = g.isParentConnection;
    }
    attach(g) {
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-link-flow-root", g.appendChild(this.root), this.render();
    }
    setConnected(g) {
      this.connected !== g && (this.connected = g, this.render());
    }
    setChainId(g) {
      this.chainId !== g && (this.chainId = g, this.render());
    }
    detach() {
      var g;
      this.root && ((0, e.render)(null, this.root), (g = this.root.parentElement) === null || g === void 0 || g.removeChild(this.root));
    }
    setConnectDisabled(g) {
      this.connectDisabled = g;
    }
    open(g) {
      this.isOpen = !0, this.onCancel = g.onCancel, this.render();
    }
    close() {
      this.isOpen = !1, this.onCancel = null, this.render();
    }
    render() {
      this.root && (0, e.render)((0, e.h)(r.ConnectDialog, { darkMode: this.darkMode, version: this.version, sessionId: this.sessionId, sessionSecret: this.sessionSecret, linkAPIUrl: this.linkAPIUrl, isOpen: this.isOpen, isConnected: this.connected, isParentConnection: this.isParentConnection, chainId: this.chainId, onCancel: this.onCancel, connectDisabled: this.connectDisabled }), this.root);
    }
  };
  return yr.LinkFlow = n, yr;
}
var en = {}, tn = {}, sa;
function bh() {
  return sa || (sa = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.default = ".-cbwsdk-css-reset .-gear-container{margin-left:16px !important;margin-right:9px !important;display:flex;align-items:center;justify-content:center;width:24px;height:24px;transition:opacity .25s}.-cbwsdk-css-reset .-gear-container *{user-select:none}.-cbwsdk-css-reset .-gear-container svg{opacity:0;position:absolute}.-cbwsdk-css-reset .-gear-icon{height:12px;width:12px;z-index:10000}.-cbwsdk-css-reset .-cbwsdk-snackbar{align-items:flex-end;display:flex;flex-direction:column;position:fixed;right:0;top:0;z-index:2147483647}.-cbwsdk-css-reset .-cbwsdk-snackbar *{user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance{display:flex;flex-direction:column;margin:8px 16px 0 16px;overflow:visible;text-align:left;transform:translateX(0);transition:opacity .25s,transform .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header:hover .-gear-container svg{opacity:1}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header{display:flex;align-items:center;background:#fff;overflow:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-cblogo{margin:8px 8px 8px 8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-header-message{color:#000;font-size:13px;line-height:1.5;user-select:none}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu{background:#fff;transition:opacity .25s ease-in-out,transform .25s linear,visibility 0s;visibility:hidden;border:1px solid #e7ebee;box-sizing:border-box;border-radius:8px;opacity:0;flex-direction:column;padding-left:8px;padding-right:8px}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:last-child{margin-bottom:8px !important}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover{background:#f5f7f8;border-radius:6px;transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover span{color:#050f19;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item:hover svg path{fill:#000;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item{visibility:inherit;height:35px;margin-top:8px;margin-bottom:0;display:flex;flex-direction:row;align-items:center;padding:8px;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item *{visibility:inherit;cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover{background:rgba(223,95,103,.2);transition:background .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover *{cursor:pointer}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover svg path{fill:#df5f67;transition:fill .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-is-red:hover span{color:#df5f67;transition:color .25s}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-menu-item-info{color:#aaa;font-size:13px;margin:0 8px 0 32px;position:absolute}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-hidden{opacity:0;text-align:left;transform:translateX(25%);transition:opacity .5s linear}.-cbwsdk-css-reset .-cbwsdk-snackbar-instance-expanded .-cbwsdk-snackbar-instance-menu{opacity:1;display:flex;transform:translateY(8px);visibility:visible}"), tn;
}
var oa;
function Kc() {
  return oa || (oa = 1, function(e) {
    var r = en.__importDefault || function(o) {
      return o && o.__esModule ? o : { default: o };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SnackbarInstance = e.SnackbarContainer = e.Snackbar = void 0;
    const n = r(Ur), t = We, g = yn, i = r(/* @__PURE__ */ bh()), c = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEuNDkyIDEwLjQxOWE4LjkzIDguOTMgMCAwMTguOTMtOC45M2gxMS4xNjNhOC45MyA4LjkzIDAgMDE4LjkzIDguOTN2MTEuMTYzYTguOTMgOC45MyAwIDAxLTguOTMgOC45M0gxMC40MjJhOC45MyA4LjkzIDAgMDEtOC45My04LjkzVjEwLjQxOXoiIGZpbGw9IiMxNjUyRjAiLz48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEwLjQxOSAwSDIxLjU4QzI3LjMzNSAwIDMyIDQuNjY1IDMyIDEwLjQxOVYyMS41OEMzMiAyNy4zMzUgMjcuMzM1IDMyIDIxLjU4MSAzMkgxMC40MkM0LjY2NSAzMiAwIDI3LjMzNSAwIDIxLjU4MVYxMC40MkMwIDQuNjY1IDQuNjY1IDAgMTAuNDE5IDB6bTAgMS40ODhhOC45MyA4LjkzIDAgMDAtOC45MyA4LjkzdjExLjE2M2E4LjkzIDguOTMgMCAwMDguOTMgOC45M0gyMS41OGE4LjkzIDguOTMgMCAwMDguOTMtOC45M1YxMC40MmE4LjkzIDguOTMgMCAwMC04LjkzLTguOTNIMTAuNDJ6IiBmaWxsPSIjZmZmIi8+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNS45OTggMjYuMDQ5Yy01LjU0OSAwLTEwLjA0Ny00LjQ5OC0xMC4wNDctMTAuMDQ3IDAtNS41NDggNC40OTgtMTAuMDQ2IDEwLjA0Ny0xMC4wNDYgNS41NDggMCAxMC4wNDYgNC40OTggMTAuMDQ2IDEwLjA0NiAwIDUuNTQ5LTQuNDk4IDEwLjA0Ny0xMC4wNDYgMTAuMDQ3eiIgZmlsbD0iI2ZmZiIvPjxwYXRoIGQ9Ik0xMi43NjIgMTQuMjU0YzAtLjgyMi42NjctMS40ODkgMS40ODktMS40ODloMy40OTdjLjgyMiAwIDEuNDg4LjY2NiAxLjQ4OCAxLjQ4OXYzLjQ5N2MwIC44MjItLjY2NiAxLjQ4OC0xLjQ4OCAxLjQ4OGgtMy40OTdhMS40ODggMS40ODggMCAwMS0xLjQ4OS0xLjQ4OHYtMy40OTh6IiBmaWxsPSIjMTY1MkYwIi8+PC9zdmc+", a = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIiIGhlaWdodD0iMTIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTEyIDYuNzV2LTEuNWwtMS43Mi0uNTdjLS4wOC0uMjctLjE5LS41Mi0uMzItLjc3bC44MS0xLjYyLTEuMDYtMS4wNi0xLjYyLjgxYy0uMjQtLjEzLS41LS4yNC0uNzctLjMyTDYuNzUgMGgtMS41bC0uNTcgMS43MmMtLjI3LjA4LS41My4xOS0uNzcuMzJsLTEuNjItLjgxLTEuMDYgMS4wNi44MSAxLjYyYy0uMTMuMjQtLjI0LjUtLjMyLjc3TDAgNS4yNXYxLjVsMS43Mi41N2MuMDguMjcuMTkuNTMuMzIuNzdsLS44MSAxLjYyIDEuMDYgMS4wNiAxLjYyLS44MWMuMjQuMTMuNS4yMy43Ny4zMkw1LjI1IDEyaDEuNWwuNTctMS43MmMuMjctLjA4LjUyLS4xOS43Ny0uMzJsMS42Mi44MSAxLjA2LTEuMDYtLjgxLTEuNjJjLjEzLS4yNC4yMy0uNS4zMi0uNzdMMTIgNi43NXpNNiA4LjVhMi41IDIuNSAwIDAxMC01IDIuNSAyLjUgMCAwMTAgNXoiIGZpbGw9IiMwNTBGMTkiLz48L3N2Zz4=";
    class d {
      constructor(l) {
        this.items = /* @__PURE__ */ new Map(), this.nextItemKey = 0, this.root = null, this.darkMode = l.darkMode;
      }
      attach(l) {
        this.root = document.createElement("div"), this.root.className = "-cbwsdk-snackbar-root", l.appendChild(this.root), this.render();
      }
      presentItem(l) {
        const s = this.nextItemKey++;
        return this.items.set(s, l), this.render(), () => {
          this.items.delete(s), this.render();
        };
      }
      clear() {
        this.items.clear(), this.render();
      }
      render() {
        this.root && (0, t.render)((0, t.h)(
          "div",
          null,
          (0, t.h)(e.SnackbarContainer, { darkMode: this.darkMode }, Array.from(this.items.entries()).map(([l, s]) => (0, t.h)(e.SnackbarInstance, Object.assign({}, s, { key: l }))))
        ), this.root);
      }
    }
    e.Snackbar = d;
    const m = (o) => (0, t.h)(
      "div",
      { class: (0, n.default)("-cbwsdk-snackbar-container") },
      (0, t.h)("style", null, i.default),
      (0, t.h)("div", { class: "-cbwsdk-snackbar" }, o.children)
    );
    e.SnackbarContainer = m;
    const p = ({ autoExpand: o, message: l, menuItems: s }) => {
      const [f, b] = (0, g.useState)(!0), [y, u] = (0, g.useState)(o ?? !1);
      (0, g.useEffect)(() => {
        const S = [
          window.setTimeout(() => {
            b(!1);
          }, 1),
          window.setTimeout(() => {
            u(!0);
          }, 1e4)
        ];
        return () => {
          S.forEach(window.clearTimeout);
        };
      });
      const R = () => {
        u(!y);
      };
      return (0, t.h)(
        "div",
        { class: (0, n.default)("-cbwsdk-snackbar-instance", f && "-cbwsdk-snackbar-instance-hidden", y && "-cbwsdk-snackbar-instance-expanded") },
        (0, t.h)(
          "div",
          { class: "-cbwsdk-snackbar-instance-header", onClick: R },
          (0, t.h)("img", { src: c, class: "-cbwsdk-snackbar-instance-header-cblogo" }),
          " ",
          (0, t.h)("div", { class: "-cbwsdk-snackbar-instance-header-message" }, l),
          (0, t.h)(
            "div",
            { class: "-gear-container" },
            !y && (0, t.h)(
              "svg",
              { width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              (0, t.h)("circle", { cx: "12", cy: "12", r: "12", fill: "#F5F7F8" })
            ),
            (0, t.h)("img", { src: a, class: "-gear-icon", title: "Expand" })
          )
        ),
        s && s.length > 0 && (0, t.h)("div", { class: "-cbwsdk-snackbar-instance-menu" }, s.map((S, I) => (0, t.h)(
          "div",
          { class: (0, n.default)("-cbwsdk-snackbar-instance-menu-item", S.isRed && "-cbwsdk-snackbar-instance-menu-item-is-red"), onClick: S.onClick, key: I },
          (0, t.h)(
            "svg",
            { width: S.svgWidth, height: S.svgHeight, viewBox: "0 0 10 11", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            (0, t.h)("path", { "fill-rule": S.defaultFillRule, "clip-rule": S.defaultClipRule, d: S.path, fill: "#AAAAAA" })
          ),
          (0, t.h)("span", { class: (0, n.default)("-cbwsdk-snackbar-instance-menu-item-info", S.isRed && "-cbwsdk-snackbar-instance-menu-item-info-is-red") }, S.info)
        )))
      );
    };
    e.SnackbarInstance = p;
  }(en)), en;
}
var aa;
function Qc() {
  if (aa) return wr;
  aa = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.WalletLinkRelayUI = void 0;
  const e = /* @__PURE__ */ Gc(), r = /* @__PURE__ */ yh(), n = /* @__PURE__ */ Kc();
  let t = class {
    constructor(i) {
      this.standalone = null, this.attached = !1, this.snackbar = new n.Snackbar({
        darkMode: i.darkMode
      }), this.linkFlow = new r.LinkFlow({
        darkMode: i.darkMode,
        version: i.version,
        sessionId: i.session.id,
        sessionSecret: i.session.secret,
        linkAPIUrl: i.linkAPIUrl,
        isParentConnection: !1
      });
    }
    attach() {
      if (this.attached)
        throw new Error("Coinbase Wallet SDK UI is already attached");
      const i = document.documentElement, c = document.createElement("div");
      c.className = "-cbwsdk-css-reset", i.appendChild(c), this.linkFlow.attach(c), this.snackbar.attach(c), this.attached = !0, (0, e.injectCssReset)();
    }
    setConnected(i) {
      this.linkFlow.setConnected(i);
    }
    setChainId(i) {
      this.linkFlow.setChainId(i);
    }
    setConnectDisabled(i) {
      this.linkFlow.setConnectDisabled(i);
    }
    /* istanbul ignore next */
    addEthereumChain() {
    }
    // no-op
    /* istanbul ignore next */
    watchAsset() {
    }
    // no-op
    /* istanbul ignore next */
    switchEthereumChain() {
    }
    // no-op
    requestEthereumAccounts(i) {
      this.linkFlow.open({ onCancel: i.onCancel });
    }
    hideRequestEthereumAccounts() {
      this.linkFlow.close();
    }
    /* istanbul ignore next */
    signEthereumMessage() {
    }
    // no-op
    /* istanbul ignore next */
    signEthereumTransaction() {
    }
    // no-op
    /* istanbul ignore next */
    submitEthereumTransaction() {
    }
    // no-op
    /* istanbul ignore next */
    ethereumAddressFromSignedMessage() {
    }
    // no-op
    showConnecting(i) {
      let c;
      return i.isUnlinkedErrorState ? c = {
        autoExpand: !0,
        message: "Connection lost",
        menuItems: [
          {
            isRed: !1,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: i.onResetConnection
          }
        ]
      } : c = {
        message: "Confirm on phone",
        menuItems: [
          {
            isRed: !0,
            info: "Cancel transaction",
            svgWidth: "11",
            svgHeight: "11",
            path: "M10.3711 1.52346L9.21775 0.370117L5.37109 4.21022L1.52444 0.370117L0.371094 1.52346L4.2112 5.37012L0.371094 9.21677L1.52444 10.3701L5.37109 6.53001L9.21775 10.3701L10.3711 9.21677L6.53099 5.37012L10.3711 1.52346Z",
            defaultFillRule: "inherit",
            defaultClipRule: "inherit",
            onClick: i.onCancel
          },
          {
            isRed: !1,
            info: "Reset connection",
            svgWidth: "10",
            svgHeight: "11",
            path: "M5.00008 0.96875C6.73133 0.96875 8.23758 1.94375 9.00008 3.375L10.0001 2.375V5.5H9.53133H7.96883H6.87508L7.80633 4.56875C7.41258 3.3875 6.31258 2.53125 5.00008 2.53125C3.76258 2.53125 2.70633 3.2875 2.25633 4.36875L0.812576 3.76875C1.50008 2.125 3.11258 0.96875 5.00008 0.96875ZM2.19375 6.43125C2.5875 7.6125 3.6875 8.46875 5 8.46875C6.2375 8.46875 7.29375 7.7125 7.74375 6.63125L9.1875 7.23125C8.5 8.875 6.8875 10.0312 5 10.0312C3.26875 10.0312 1.7625 9.05625 1 7.625L0 8.625V5.5H0.46875H2.03125H3.125L2.19375 6.43125Z",
            defaultFillRule: "evenodd",
            defaultClipRule: "evenodd",
            onClick: i.onResetConnection
          }
        ]
      }, this.snackbar.presentItem(c);
    }
    /* istanbul ignore next */
    reloadUI() {
      document.location.reload();
    }
    /* istanbul ignore next */
    inlineAccountsResponse() {
      return !1;
    }
    /* istanbul ignore next */
    inlineAddEthereumChain() {
      return !1;
    }
    /* istanbul ignore next */
    inlineWatchAsset() {
      return !1;
    }
    /* istanbul ignore next */
    inlineSwitchEthereumChain() {
      return !1;
    }
    /* istanbul ignore next */
    setStandalone(i) {
      this.standalone = i;
    }
    /* istanbul ignore next */
    isStandalone() {
      var i;
      return (i = this.standalone) !== null && i !== void 0 ? i : !1;
    }
  };
  return wr.WalletLinkRelayUI = t, wr;
}
var ua;
function Yc() {
  if (ua) return lr;
  ua = 1, Object.defineProperty(lr, "__esModule", { value: !0 }), lr.WalletLinkRelay = void 0;
  const e = /* @__PURE__ */ gn(), r = /* @__PURE__ */ mn(), n = /* @__PURE__ */ tt(), t = /* @__PURE__ */ qs(), g = /* @__PURE__ */ js(), i = /* @__PURE__ */ $s(), c = /* @__PURE__ */ Xl(), a = /* @__PURE__ */ Fs(), d = /* @__PURE__ */ Qc();
  let m = class kt extends g.RelayAbstract {
    constructor(o) {
      var l;
      super(), this.accountsCallback = null, this.chainCallbackParams = { chainId: "", jsonRpcUrl: "" }, this.chainCallback = null, this.dappDefaultChain = 1, this.appName = "", this.appLogoUrl = null, this.linkedUpdated = (y) => {
        var u;
        this.isLinked = y;
        const R = this.storage.getItem(g.LOCAL_STORAGE_ADDRESSES_KEY);
        if (y && (this.session.linked = y), this.isUnlinkedErrorState = !1, R) {
          const S = R.split(" "), I = this.storage.getItem("IsStandaloneSigning") === "true";
          if (S[0] !== "" && !y && this.session.linked && !I) {
            this.isUnlinkedErrorState = !0;
            const T = this.getSessionIdHash();
            (u = this.diagnostic) === null || u === void 0 || u.log(t.EVENTS.UNLINKED_ERROR_STATE, {
              sessionIdHash: T
            });
          }
        }
      }, this.metadataUpdated = (y, u) => {
        this.storage.setItem(y, u);
      }, this.chainUpdated = (y, u) => {
        this.chainCallbackParams.chainId === y && this.chainCallbackParams.jsonRpcUrl === u || (this.chainCallbackParams = {
          chainId: y,
          jsonRpcUrl: u
        }, this.chainCallback && this.chainCallback(y, u));
      }, this.accountUpdated = (y) => {
        this.accountsCallback && this.accountsCallback([y]), kt.accountRequestCallbackIds.size > 0 && (Array.from(kt.accountRequestCallbackIds.values()).forEach((u) => {
          const R = {
            type: "WEB3_RESPONSE",
            id: u,
            response: {
              method: "requestEthereumAccounts",
              result: [y]
            }
          };
          this.invokeCallback(Object.assign(Object.assign({}, R), { id: u }));
        }), kt.accountRequestCallbackIds.clear());
      }, this.connectedUpdated = (y) => {
        this.ui.setConnected(y);
      }, this.resetAndReload = this.resetAndReload.bind(this), this.linkAPIUrl = o.linkAPIUrl, this.storage = o.storage, this.options = o;
      const { session: s, ui: f, connection: b } = this.subscribe();
      this._session = s, this.connection = b, this.relayEventManager = o.relayEventManager, this.diagnostic = o.diagnosticLogger, this._reloadOnDisconnect = (l = o.reloadOnDisconnect) !== null && l !== void 0 ? l : !0, this.ui = f;
    }
    subscribe() {
      const o = i.Session.load(this.storage) || new i.Session(this.storage).save(), { linkAPIUrl: l, diagnostic: s } = this, f = new c.WalletLinkConnection({
        session: o,
        linkAPIUrl: l,
        diagnostic: s,
        listener: this
      }), { version: b, darkMode: y } = this.options, u = this.options.uiConstructor({
        linkAPIUrl: l,
        version: b,
        darkMode: y,
        session: o
      });
      return f.connect(), { session: o, ui: u, connection: f };
    }
    attachUI() {
      this.ui.attach();
    }
    resetAndReload() {
      Promise.race([
        this.connection.setSessionMetadata("__destroyed", "1"),
        new Promise((o) => setTimeout(() => o(null), 1e3))
      ]).then(() => {
        var o, l;
        const s = this.ui.isStandalone();
        (o = this.diagnostic) === null || o === void 0 || o.log(t.EVENTS.SESSION_STATE_CHANGE, {
          method: "relay::resetAndReload",
          sessionMetadataChange: "__destroyed, 1",
          sessionIdHash: this.getSessionIdHash()
        }), this.connection.destroy();
        const f = i.Session.load(this.storage);
        if ((f == null ? void 0 : f.id) === this._session.id ? this.storage.clear() : f && ((l = this.diagnostic) === null || l === void 0 || l.log(t.EVENTS.SKIPPED_CLEARING_SESSION, {
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: i.Session.hash(f.id)
        })), this._reloadOnDisconnect) {
          this.ui.reloadUI();
          return;
        }
        this.accountsCallback && this.accountsCallback([], !0);
        const { session: b, ui: y, connection: u } = this.subscribe();
        this._session = b, this.connection = u, this.ui = y, s && this.ui.setStandalone && this.ui.setStandalone(!0), this.options.headlessMode || this.attachUI();
      }).catch((o) => {
        var l;
        (l = this.diagnostic) === null || l === void 0 || l.log(t.EVENTS.FAILURE, {
          method: "relay::resetAndReload",
          message: `failed to reset and reload with ${o}`,
          sessionIdHash: this.getSessionIdHash()
        });
      });
    }
    setAppInfo(o, l) {
      this.appName = o, this.appLogoUrl = l;
    }
    getStorageItem(o) {
      return this.storage.getItem(o);
    }
    get session() {
      return this._session;
    }
    setStorageItem(o, l) {
      this.storage.setItem(o, l);
    }
    signEthereumMessage(o, l, s, f) {
      return this.sendRequest({
        method: "signEthereumMessage",
        params: {
          message: (0, n.hexStringFromBuffer)(o, !0),
          address: l,
          addPrefix: s,
          typedDataJson: f || null
        }
      });
    }
    ethereumAddressFromSignedMessage(o, l, s) {
      return this.sendRequest({
        method: "ethereumAddressFromSignedMessage",
        params: {
          message: (0, n.hexStringFromBuffer)(o, !0),
          signature: (0, n.hexStringFromBuffer)(l, !0),
          addPrefix: s
        }
      });
    }
    signEthereumTransaction(o) {
      return this.sendRequest({
        method: "signEthereumTransaction",
        params: {
          fromAddress: o.fromAddress,
          toAddress: o.toAddress,
          weiValue: (0, n.bigIntStringFromBN)(o.weiValue),
          data: (0, n.hexStringFromBuffer)(o.data, !0),
          nonce: o.nonce,
          gasPriceInWei: o.gasPriceInWei ? (0, n.bigIntStringFromBN)(o.gasPriceInWei) : null,
          maxFeePerGas: o.gasPriceInWei ? (0, n.bigIntStringFromBN)(o.gasPriceInWei) : null,
          maxPriorityFeePerGas: o.gasPriceInWei ? (0, n.bigIntStringFromBN)(o.gasPriceInWei) : null,
          gasLimit: o.gasLimit ? (0, n.bigIntStringFromBN)(o.gasLimit) : null,
          chainId: o.chainId,
          shouldSubmit: !1
        }
      });
    }
    signAndSubmitEthereumTransaction(o) {
      return this.sendRequest({
        method: "signEthereumTransaction",
        params: {
          fromAddress: o.fromAddress,
          toAddress: o.toAddress,
          weiValue: (0, n.bigIntStringFromBN)(o.weiValue),
          data: (0, n.hexStringFromBuffer)(o.data, !0),
          nonce: o.nonce,
          gasPriceInWei: o.gasPriceInWei ? (0, n.bigIntStringFromBN)(o.gasPriceInWei) : null,
          maxFeePerGas: o.maxFeePerGas ? (0, n.bigIntStringFromBN)(o.maxFeePerGas) : null,
          maxPriorityFeePerGas: o.maxPriorityFeePerGas ? (0, n.bigIntStringFromBN)(o.maxPriorityFeePerGas) : null,
          gasLimit: o.gasLimit ? (0, n.bigIntStringFromBN)(o.gasLimit) : null,
          chainId: o.chainId,
          shouldSubmit: !0
        }
      });
    }
    submitEthereumTransaction(o, l) {
      return this.sendRequest({
        method: "submitEthereumTransaction",
        params: {
          signedTransaction: (0, n.hexStringFromBuffer)(o, !0),
          chainId: l
        }
      });
    }
    scanQRCode(o) {
      return this.sendRequest({
        method: "scanQRCode",
        params: {
          regExp: o
        }
      });
    }
    getQRCodeUrl() {
      return (0, n.createQrUrl)(this._session.id, this._session.secret, this.linkAPIUrl, !1, this.options.version, this.dappDefaultChain);
    }
    genericRequest(o, l) {
      return this.sendRequest({
        method: "generic",
        params: {
          action: l,
          data: o
        }
      });
    }
    sendGenericMessage(o) {
      return this.sendRequest(o);
    }
    sendRequest(o) {
      let l = null;
      const s = (0, n.randomBytesHex)(8), f = (y) => {
        this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, o.method, y), l == null || l();
      };
      return { promise: new Promise((y, u) => {
        this.ui.isStandalone() || (l = this.ui.showConnecting({
          isUnlinkedErrorState: this.isUnlinkedErrorState,
          onCancel: f,
          onResetConnection: this.resetAndReload
          // eslint-disable-line @typescript-eslint/unbound-method
        })), this.relayEventManager.callbacks.set(s, (R) => {
          if (l == null || l(), (0, a.isErrorResponse)(R))
            return u(new Error(R.errorMessage));
          y(R);
        }), this.ui.isStandalone() ? this.sendRequestStandalone(s, o) : this.publishWeb3RequestEvent(s, o);
      }), cancel: f };
    }
    setConnectDisabled(o) {
      this.ui.setConnectDisabled(o);
    }
    setAccountsCallback(o) {
      this.accountsCallback = o;
    }
    setChainCallback(o) {
      this.chainCallback = o;
    }
    setDappDefaultChainCallback(o) {
      this.dappDefaultChain = o, this.ui instanceof d.WalletLinkRelayUI && this.ui.setChainId(o);
    }
    publishWeb3RequestEvent(o, l) {
      var s;
      const f = { type: "WEB3_REQUEST", id: o, request: l }, b = i.Session.load(this.storage);
      (s = this.diagnostic) === null || s === void 0 || s.log(t.EVENTS.WEB3_REQUEST, {
        eventId: f.id,
        method: `relay::${l.method}`,
        sessionIdHash: this.getSessionIdHash(),
        storedSessionIdHash: b ? i.Session.hash(b.id) : "",
        isSessionMismatched: ((b == null ? void 0 : b.id) !== this._session.id).toString()
      }), this.publishEvent("Web3Request", f, !0).then((y) => {
        var u;
        (u = this.diagnostic) === null || u === void 0 || u.log(t.EVENTS.WEB3_REQUEST_PUBLISHED, {
          eventId: f.id,
          method: `relay::${l.method}`,
          sessionIdHash: this.getSessionIdHash(),
          storedSessionIdHash: b ? i.Session.hash(b.id) : "",
          isSessionMismatched: ((b == null ? void 0 : b.id) !== this._session.id).toString()
        });
      }).catch((y) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: f.id,
          response: {
            method: l.method,
            errorMessage: y.message
          }
        });
      });
    }
    publishWeb3RequestCanceledEvent(o) {
      const l = {
        type: "WEB3_REQUEST_CANCELED",
        id: o
      };
      this.publishEvent("Web3RequestCanceled", l, !1).then();
    }
    publishEvent(o, l, s) {
      return this.connection.publishEvent(o, l, s);
    }
    handleWeb3ResponseMessage(o) {
      var l;
      const { response: s } = o;
      if ((l = this.diagnostic) === null || l === void 0 || l.log(t.EVENTS.WEB3_RESPONSE, {
        eventId: o.id,
        method: `relay::${s.method}`,
        sessionIdHash: this.getSessionIdHash()
      }), s.method === "requestEthereumAccounts") {
        kt.accountRequestCallbackIds.forEach((f) => this.invokeCallback(Object.assign(Object.assign({}, o), { id: f }))), kt.accountRequestCallbackIds.clear();
        return;
      }
      this.invokeCallback(o);
    }
    handleErrorResponse(o, l, s, f) {
      var b;
      const y = (b = s == null ? void 0 : s.message) !== null && b !== void 0 ? b : (0, e.getMessageFromCode)(f);
      this.handleWeb3ResponseMessage({
        type: "WEB3_RESPONSE",
        id: o,
        response: {
          method: l,
          errorMessage: y,
          errorCode: f
        }
      });
    }
    invokeCallback(o) {
      const l = this.relayEventManager.callbacks.get(o.id);
      l && (l(o.response), this.relayEventManager.callbacks.delete(o.id));
    }
    requestEthereumAccounts() {
      const o = {
        method: "requestEthereumAccounts",
        params: {
          appName: this.appName,
          appLogoUrl: this.appLogoUrl || null
        }
      }, l = (0, n.randomBytesHex)(8), s = (b) => {
        this.publishWeb3RequestCanceledEvent(l), this.handleErrorResponse(l, o.method, b);
      };
      return { promise: new Promise((b, y) => {
        if (this.relayEventManager.callbacks.set(l, (u) => {
          if (this.ui.hideRequestEthereumAccounts(), (0, a.isErrorResponse)(u))
            return y(new Error(u.errorMessage));
          b(u);
        }), this.ui.inlineAccountsResponse()) {
          const u = (R) => {
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: l,
              response: { method: "requestEthereumAccounts", result: R }
            });
          };
          this.ui.requestEthereumAccounts({
            onCancel: s,
            onAccounts: u
          });
        } else {
          const u = e.standardErrors.provider.userRejectedRequest("User denied account authorization");
          this.ui.requestEthereumAccounts({
            onCancel: () => s(u)
          });
        }
        kt.accountRequestCallbackIds.add(l), !this.ui.inlineAccountsResponse() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(l, o);
      }), cancel: s };
    }
    selectProvider(o) {
      const l = {
        method: "selectProvider",
        params: {
          providerOptions: o
        }
      }, s = (0, n.randomBytesHex)(8), f = (y) => {
        this.publishWeb3RequestCanceledEvent(s), this.handleErrorResponse(s, l.method, y);
      }, b = new Promise((y, u) => {
        this.relayEventManager.callbacks.set(s, (I) => {
          if ((0, a.isErrorResponse)(I))
            return u(new Error(I.errorMessage));
          y(I);
        });
        const R = (I) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: s,
            response: { method: "selectProvider", result: r.ProviderType.Unselected }
          });
        }, S = (I) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: s,
            response: { method: "selectProvider", result: I }
          });
        };
        this.ui.selectProvider && this.ui.selectProvider({
          onApprove: S,
          onCancel: R,
          providerOptions: o
        });
      });
      return { cancel: f, promise: b };
    }
    watchAsset(o, l, s, f, b, y) {
      const u = {
        method: "watchAsset",
        params: {
          type: o,
          options: {
            address: l,
            symbol: s,
            decimals: f,
            image: b
          },
          chainId: y
        }
      };
      let R = null;
      const S = (0, n.randomBytesHex)(8), I = (q) => {
        this.publishWeb3RequestCanceledEvent(S), this.handleErrorResponse(S, u.method, q), R == null || R();
      };
      this.ui.inlineWatchAsset() || (R = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: I,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      }));
      const T = new Promise((q, D) => {
        this.relayEventManager.callbacks.set(S, (X) => {
          if (R == null || R(), (0, a.isErrorResponse)(X))
            return D(new Error(X.errorMessage));
          q(X);
        });
        const H = (X) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "watchAsset",
              result: !1
            }
          });
        }, G = () => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "watchAsset",
              result: !0
            }
          });
        };
        this.ui.inlineWatchAsset() && this.ui.watchAsset({
          onApprove: G,
          onCancel: H,
          type: o,
          address: l,
          symbol: s,
          decimals: f,
          image: b,
          chainId: y
        }), !this.ui.inlineWatchAsset() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(S, u);
      });
      return { cancel: I, promise: T };
    }
    addEthereumChain(o, l, s, f, b, y) {
      const u = {
        method: "addEthereumChain",
        params: {
          chainId: o,
          rpcUrls: l,
          blockExplorerUrls: f,
          chainName: b,
          iconUrls: s,
          nativeCurrency: y
        }
      };
      let R = null;
      const S = (0, n.randomBytesHex)(8), I = (q) => {
        this.publishWeb3RequestCanceledEvent(S), this.handleErrorResponse(S, u.method, q), R == null || R();
      };
      return this.ui.inlineAddEthereumChain(o) || (R = this.ui.showConnecting({
        isUnlinkedErrorState: this.isUnlinkedErrorState,
        onCancel: I,
        onResetConnection: this.resetAndReload
        // eslint-disable-line @typescript-eslint/unbound-method
      })), { promise: new Promise((q, D) => {
        this.relayEventManager.callbacks.set(S, (X) => {
          if (R == null || R(), (0, a.isErrorResponse)(X))
            return D(new Error(X.errorMessage));
          q(X);
        });
        const H = (X) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "addEthereumChain",
              result: {
                isApproved: !1,
                rpcUrl: ""
              }
            }
          });
        }, G = (X) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: S,
            response: {
              method: "addEthereumChain",
              result: {
                isApproved: !0,
                rpcUrl: X
              }
            }
          });
        };
        this.ui.inlineAddEthereumChain(o) && this.ui.addEthereumChain({
          onCancel: H,
          onApprove: G,
          chainId: u.params.chainId,
          rpcUrls: u.params.rpcUrls,
          blockExplorerUrls: u.params.blockExplorerUrls,
          chainName: u.params.chainName,
          iconUrls: u.params.iconUrls,
          nativeCurrency: u.params.nativeCurrency
        }), !this.ui.inlineAddEthereumChain(o) && !this.ui.isStandalone() && this.publishWeb3RequestEvent(S, u);
      }), cancel: I };
    }
    switchEthereumChain(o, l) {
      const s = {
        method: "switchEthereumChain",
        params: Object.assign({ chainId: o }, { address: l })
      }, f = (0, n.randomBytesHex)(8), b = (u) => {
        this.publishWeb3RequestCanceledEvent(f), this.handleErrorResponse(f, s.method, u);
      };
      return { promise: new Promise((u, R) => {
        this.relayEventManager.callbacks.set(f, (T) => {
          if ((0, a.isErrorResponse)(T) && T.errorCode)
            return R(e.standardErrors.provider.custom({
              code: T.errorCode,
              message: "Unrecognized chain ID. Try adding the chain using addEthereumChain first."
            }));
          if ((0, a.isErrorResponse)(T))
            return R(new Error(T.errorMessage));
          u(T);
        });
        const S = (T) => {
          var q;
          if (T) {
            const D = (q = (0, e.getErrorCode)(T)) !== null && q !== void 0 ? q : e.standardErrorCodes.provider.unsupportedChain;
            this.handleErrorResponse(f, "switchEthereumChain", T instanceof Error ? T : e.standardErrors.provider.unsupportedChain(o), D);
          } else
            this.handleWeb3ResponseMessage({
              type: "WEB3_RESPONSE",
              id: f,
              response: {
                method: "switchEthereumChain",
                result: {
                  isApproved: !1,
                  rpcUrl: ""
                }
              }
            });
        }, I = (T) => {
          this.handleWeb3ResponseMessage({
            type: "WEB3_RESPONSE",
            id: f,
            response: {
              method: "switchEthereumChain",
              result: {
                isApproved: !0,
                rpcUrl: T
              }
            }
          });
        };
        this.ui.switchEthereumChain({
          onCancel: S,
          onApprove: I,
          chainId: s.params.chainId,
          address: s.params.address
        }), !this.ui.inlineSwitchEthereumChain() && !this.ui.isStandalone() && this.publishWeb3RequestEvent(f, s);
      }), cancel: b };
    }
    inlineAddEthereumChain(o) {
      return this.ui.inlineAddEthereumChain(o);
    }
    getSessionIdHash() {
      return i.Session.hash(this._session.id);
    }
    sendRequestStandalone(o, l) {
      const s = (b) => {
        this.handleErrorResponse(o, l.method, b);
      }, f = (b) => {
        this.handleWeb3ResponseMessage({
          type: "WEB3_RESPONSE",
          id: o,
          response: b
        });
      };
      switch (l.method) {
        case "signEthereumMessage":
          this.ui.signEthereumMessage({
            request: l,
            onSuccess: f,
            onCancel: s
          });
          break;
        case "signEthereumTransaction":
          this.ui.signEthereumTransaction({
            request: l,
            onSuccess: f,
            onCancel: s
          });
          break;
        case "submitEthereumTransaction":
          this.ui.submitEthereumTransaction({
            request: l,
            onSuccess: f,
            onCancel: s
          });
          break;
        case "ethereumAddressFromSignedMessage":
          this.ui.ethereumAddressFromSignedMessage({
            request: l,
            onSuccess: f
          });
          break;
        default:
          s();
          break;
      }
    }
  };
  return lr.WalletLinkRelay = m, m.accountRequestCallbackIds = /* @__PURE__ */ new Set(), lr;
}
var Cr = {}, Wt = {}, Mr = {}, ca;
function vh() {
  return ca || (ca = 1, function(e) {
    var r = Mr.__createBinding || (Object.create ? function(t, g, i, c) {
      c === void 0 && (c = i);
      var a = Object.getOwnPropertyDescriptor(g, i);
      (!a || ("get" in a ? !g.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
        return g[i];
      } }), Object.defineProperty(t, c, a);
    } : function(t, g, i, c) {
      c === void 0 && (c = i), t[c] = g[i];
    }), n = Mr.__exportStar || function(t, g) {
      for (var i in t) i !== "default" && !Object.prototype.hasOwnProperty.call(g, i) && r(g, t, i);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), n(/* @__PURE__ */ Kc(), e);
  }(Mr)), Mr;
}
var rn = {}, la;
function _h() {
  return la || (la = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.default = ".-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop{position:fixed;top:0;left:0;right:0;bottom:0;transition:opacity .25s;background-color:rgba(10,11,13,.5)}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-backdrop-hidden{opacity:0}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box{display:block;position:fixed;top:50%;left:50%;transform:translate(-50%, -50%);padding:20px;border-radius:8px;background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box p{display:block;font-weight:400;font-size:14px;line-height:20px;padding-bottom:12px;color:#5b636e}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box button{appearance:none;border:none;background:none;color:#0052ff;padding:0;text-decoration:none;display:block;font-weight:600;font-size:16px;line-height:24px}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark{background-color:#0a0b0d;color:#fff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.dark button{color:#0052ff}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light{background-color:#fff;color:#0a0b0d}.-cbwsdk-css-reset .-cbwsdk-redirect-dialog-box.light button{color:#0052ff}"), rn;
}
var ha;
function Eh() {
  if (ha) return Wt;
  ha = 1;
  var e = Wt.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(Wt, "__esModule", { value: !0 }), Wt.RedirectDialog = void 0;
  const r = e(Ur), n = We, t = /* @__PURE__ */ Gc(), g = /* @__PURE__ */ vh(), i = e(/* @__PURE__ */ _h());
  let c = class {
    constructor() {
      this.root = null;
    }
    attach() {
      const m = document.documentElement;
      this.root = document.createElement("div"), this.root.className = "-cbwsdk-css-reset", m.appendChild(this.root), (0, t.injectCssReset)();
    }
    present(m) {
      this.render(m);
    }
    clear() {
      this.render(null);
    }
    render(m) {
      this.root && ((0, n.render)(null, this.root), m && (0, n.render)((0, n.h)(a, Object.assign({}, m, { onDismiss: () => {
        this.clear();
      } })), this.root));
    }
  };
  Wt.RedirectDialog = c;
  const a = ({ title: d, buttonText: m, darkMode: p, onButtonClick: o, onDismiss: l }) => {
    const s = p ? "dark" : "light";
    return (0, n.h)(
      g.SnackbarContainer,
      { darkMode: p },
      (0, n.h)(
        "div",
        { class: "-cbwsdk-redirect-dialog" },
        (0, n.h)("style", null, i.default),
        (0, n.h)("div", { class: "-cbwsdk-redirect-dialog-backdrop", onClick: l }),
        (0, n.h)(
          "div",
          { class: (0, r.default)("-cbwsdk-redirect-dialog-box", s) },
          (0, n.h)("p", null, d),
          (0, n.h)("button", { onClick: o }, m)
        )
      )
    );
  };
  return Wt;
}
var da;
function Xc() {
  if (da) return Cr;
  da = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.MobileRelayUI = void 0;
  const e = /* @__PURE__ */ Eh();
  let r = class {
    constructor(t) {
      this.attached = !1, this.darkMode = !1, this.redirectDialog = new e.RedirectDialog(), this.darkMode = t.darkMode;
    }
    attach() {
      if (this.attached)
        throw new Error("Coinbase Wallet SDK UI is already attached");
      this.redirectDialog.attach(), this.attached = !0;
    }
    setConnected(t) {
    }
    // no-op
    redirectToCoinbaseWallet(t) {
      const g = new URL("https://go.cb-w.com/walletlink");
      g.searchParams.append("redirect_url", window.location.href), t && g.searchParams.append("wl_url", t);
      const i = document.createElement("a");
      i.target = "cbw-opener", i.href = g.href, i.rel = "noreferrer noopener", i.click();
    }
    openCoinbaseWalletDeeplink(t) {
      this.redirectDialog.present({
        title: "Redirecting to Coinbase Wallet...",
        buttonText: "Open",
        darkMode: this.darkMode,
        onButtonClick: () => {
          this.redirectToCoinbaseWallet(t);
        }
      }), setTimeout(() => {
        this.redirectToCoinbaseWallet(t);
      }, 99);
    }
    showConnecting(t) {
      return () => {
        this.redirectDialog.clear();
      };
    }
    hideRequestEthereumAccounts() {
      this.redirectDialog.clear();
    }
    // -- Methods below are not needed for mobile
    requestEthereumAccounts() {
    }
    // no-op
    addEthereumChain() {
    }
    // no-op
    watchAsset() {
    }
    // no-op
    selectProvider() {
    }
    // no-op
    switchEthereumChain() {
    }
    // no-op
    signEthereumMessage() {
    }
    // no-op
    signEthereumTransaction() {
    }
    // no-op
    submitEthereumTransaction() {
    }
    // no-op
    ethereumAddressFromSignedMessage() {
    }
    // no-op
    reloadUI() {
    }
    // no-op
    setStandalone() {
    }
    // no-op
    setConnectDisabled() {
    }
    // no-op
    inlineAccountsResponse() {
      return !1;
    }
    inlineAddEthereumChain() {
      return !1;
    }
    inlineWatchAsset() {
      return !1;
    }
    inlineSwitchEthereumChain() {
      return !1;
    }
    isStandalone() {
      return !1;
    }
  };
  return Cr.MobileRelayUI = r, Cr;
}
var fa;
function el() {
  if (fa) return cr;
  fa = 1, Object.defineProperty(cr, "__esModule", { value: !0 }), cr.MobileRelay = void 0;
  const e = /* @__PURE__ */ tt(), r = /* @__PURE__ */ Yc(), n = /* @__PURE__ */ Xc();
  let t = class extends r.WalletLinkRelay {
    constructor(i) {
      var c;
      super(i), this._enableMobileWalletLink = (c = i.enableMobileWalletLink) !== null && c !== void 0 ? c : !1;
    }
    // override
    requestEthereumAccounts() {
      return this._enableMobileWalletLink ? super.requestEthereumAccounts() : {
        promise: new Promise(() => {
          const i = (0, e.getLocation)();
          i.href = `https://go.cb-w.com/dapp?cb_url=${encodeURIComponent(i.href)}`;
        }),
        cancel: () => {
        }
      };
    }
    // override
    publishWeb3RequestEvent(i, c) {
      if (super.publishWeb3RequestEvent(i, c), !(this._enableMobileWalletLink && this.ui instanceof n.MobileRelayUI))
        return;
      let a = !1;
      switch (c.method) {
        case "requestEthereumAccounts":
        case "connectAndSignIn":
          a = !0, this.ui.openCoinbaseWalletDeeplink(this.getQRCodeUrl());
          break;
        case "switchEthereumChain":
          return;
        default:
          a = !0, this.ui.openCoinbaseWalletDeeplink();
          break;
      }
      a && window.addEventListener("blur", () => {
        window.addEventListener("focus", () => {
          this.connection.checkUnseenEvents();
        }, { once: !0 });
      }, { once: !0 });
    }
    // override
    handleWeb3ResponseMessage(i) {
      super.handleWeb3ResponseMessage(i);
    }
    connectAndSignIn(i) {
      if (!this._enableMobileWalletLink)
        throw new Error("connectAndSignIn is supported only when enableMobileWalletLink is on");
      return this.sendRequest({
        method: "connectAndSignIn",
        params: {
          appName: this.appName,
          appLogoUrl: this.appLogoUrl,
          domain: window.location.hostname,
          aud: window.location.href,
          version: "1",
          type: "eip4361",
          nonce: i.nonce,
          iat: (/* @__PURE__ */ new Date()).toISOString(),
          chainId: `eip155:${this.dappDefaultChain}`,
          statement: i.statement,
          resources: i.resources
        }
      });
    }
  };
  return cr.MobileRelay = t, cr;
}
var nn = { exports: {} }, Un, pa;
function tl() {
  return pa || (pa = 1, Un = dn().EventEmitter), Un;
}
var Hn, ga;
function Rh() {
  if (ga) return Hn;
  ga = 1;
  function e(f, b) {
    var y = Object.keys(f);
    if (Object.getOwnPropertySymbols) {
      var u = Object.getOwnPropertySymbols(f);
      b && (u = u.filter(function(R) {
        return Object.getOwnPropertyDescriptor(f, R).enumerable;
      })), y.push.apply(y, u);
    }
    return y;
  }
  function r(f) {
    for (var b = 1; b < arguments.length; b++) {
      var y = arguments[b] != null ? arguments[b] : {};
      b % 2 ? e(Object(y), !0).forEach(function(u) {
        n(f, u, y[u]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(f, Object.getOwnPropertyDescriptors(y)) : e(Object(y)).forEach(function(u) {
        Object.defineProperty(f, u, Object.getOwnPropertyDescriptor(y, u));
      });
    }
    return f;
  }
  function n(f, b, y) {
    return b = c(b), b in f ? Object.defineProperty(f, b, { value: y, enumerable: !0, configurable: !0, writable: !0 }) : f[b] = y, f;
  }
  function t(f, b) {
    if (!(f instanceof b))
      throw new TypeError("Cannot call a class as a function");
  }
  function g(f, b) {
    for (var y = 0; y < b.length; y++) {
      var u = b[y];
      u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(f, c(u.key), u);
    }
  }
  function i(f, b, y) {
    return g(f.prototype, b), Object.defineProperty(f, "prototype", { writable: !1 }), f;
  }
  function c(f) {
    var b = a(f, "string");
    return typeof b == "symbol" ? b : String(b);
  }
  function a(f, b) {
    if (typeof f != "object" || f === null) return f;
    var y = f[Symbol.toPrimitive];
    if (y !== void 0) {
      var u = y.call(f, b);
      if (typeof u != "object") return u;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(f);
  }
  var d = wn(), m = d.Buffer, p = Ps, o = p.inspect, l = o && o.custom || "inspect";
  function s(f, b, y) {
    m.prototype.copy.call(f, b, y);
  }
  return Hn = /* @__PURE__ */ function() {
    function f() {
      t(this, f), this.head = null, this.tail = null, this.length = 0;
    }
    return i(f, [{
      key: "push",
      value: function(y) {
        var u = {
          data: y,
          next: null
        };
        this.length > 0 ? this.tail.next = u : this.head = u, this.tail = u, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(y) {
        var u = {
          data: y,
          next: this.head
        };
        this.length === 0 && (this.tail = u), this.head = u, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var y = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, y;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(y) {
        if (this.length === 0) return "";
        for (var u = this.head, R = "" + u.data; u = u.next; ) R += y + u.data;
        return R;
      }
    }, {
      key: "concat",
      value: function(y) {
        if (this.length === 0) return m.alloc(0);
        for (var u = m.allocUnsafe(y >>> 0), R = this.head, S = 0; R; )
          s(R.data, u, S), S += R.data.length, R = R.next;
        return u;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(y, u) {
        var R;
        return y < this.head.data.length ? (R = this.head.data.slice(0, y), this.head.data = this.head.data.slice(y)) : y === this.head.data.length ? R = this.shift() : R = u ? this._getString(y) : this._getBuffer(y), R;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(y) {
        var u = this.head, R = 1, S = u.data;
        for (y -= S.length; u = u.next; ) {
          var I = u.data, T = y > I.length ? I.length : y;
          if (T === I.length ? S += I : S += I.slice(0, y), y -= T, y === 0) {
            T === I.length ? (++R, u.next ? this.head = u.next : this.head = this.tail = null) : (this.head = u, u.data = I.slice(T));
            break;
          }
          ++R;
        }
        return this.length -= R, S;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(y) {
        var u = m.allocUnsafe(y), R = this.head, S = 1;
        for (R.data.copy(u), y -= R.data.length; R = R.next; ) {
          var I = R.data, T = y > I.length ? I.length : y;
          if (I.copy(u, u.length - y, 0, T), y -= T, y === 0) {
            T === I.length ? (++S, R.next ? this.head = R.next : this.head = this.tail = null) : (this.head = R, R.data = I.slice(T));
            break;
          }
          ++S;
        }
        return this.length -= S, u;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: l,
      value: function(y, u) {
        return o(this, r(r({}, u), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), f;
  }(), Hn;
}
var Wn, ma;
function rl() {
  if (ma) return Wn;
  ma = 1;
  function e(c, a) {
    var d = this, m = this._readableState && this._readableState.destroyed, p = this._writableState && this._writableState.destroyed;
    return m || p ? (a ? a(c) : c && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(g, this, c)) : process.nextTick(g, this, c)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(c || null, function(o) {
      !a && o ? d._writableState ? d._writableState.errorEmitted ? process.nextTick(n, d) : (d._writableState.errorEmitted = !0, process.nextTick(r, d, o)) : process.nextTick(r, d, o) : a ? (process.nextTick(n, d), a(o)) : process.nextTick(n, d);
    }), this);
  }
  function r(c, a) {
    g(c, a), n(c);
  }
  function n(c) {
    c._writableState && !c._writableState.emitClose || c._readableState && !c._readableState.emitClose || c.emit("close");
  }
  function t() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function g(c, a) {
    c.emit("error", a);
  }
  function i(c, a) {
    var d = c._readableState, m = c._writableState;
    d && d.autoDestroy || m && m.autoDestroy ? c.destroy(a) : c.emit("error", a);
  }
  return Wn = {
    destroy: e,
    undestroy: t,
    errorOrDestroy: i
  }, Wn;
}
var Vn = {}, wa;
function Yt() {
  if (wa) return Vn;
  wa = 1;
  function e(a, d) {
    a.prototype = Object.create(d.prototype), a.prototype.constructor = a, a.__proto__ = d;
  }
  var r = {};
  function n(a, d, m) {
    m || (m = Error);
    function p(l, s, f) {
      return typeof d == "string" ? d : d(l, s, f);
    }
    var o = /* @__PURE__ */ function(l) {
      e(s, l);
      function s(f, b, y) {
        return l.call(this, p(f, b, y)) || this;
      }
      return s;
    }(m);
    o.prototype.name = m.name, o.prototype.code = a, r[a] = o;
  }
  function t(a, d) {
    if (Array.isArray(a)) {
      var m = a.length;
      return a = a.map(function(p) {
        return String(p);
      }), m > 2 ? "one of ".concat(d, " ").concat(a.slice(0, m - 1).join(", "), ", or ") + a[m - 1] : m === 2 ? "one of ".concat(d, " ").concat(a[0], " or ").concat(a[1]) : "of ".concat(d, " ").concat(a[0]);
    } else
      return "of ".concat(d, " ").concat(String(a));
  }
  function g(a, d, m) {
    return a.substr(0, d.length) === d;
  }
  function i(a, d, m) {
    return (m === void 0 || m > a.length) && (m = a.length), a.substring(m - d.length, m) === d;
  }
  function c(a, d, m) {
    return typeof m != "number" && (m = 0), m + d.length > a.length ? !1 : a.indexOf(d, m) !== -1;
  }
  return n("ERR_INVALID_OPT_VALUE", function(a, d) {
    return 'The value "' + d + '" is invalid for option "' + a + '"';
  }, TypeError), n("ERR_INVALID_ARG_TYPE", function(a, d, m) {
    var p;
    typeof d == "string" && g(d, "not ") ? (p = "must not be", d = d.replace(/^not /, "")) : p = "must be";
    var o;
    if (i(a, " argument"))
      o = "The ".concat(a, " ").concat(p, " ").concat(t(d, "type"));
    else {
      var l = c(a, ".") ? "property" : "argument";
      o = 'The "'.concat(a, '" ').concat(l, " ").concat(p, " ").concat(t(d, "type"));
    }
    return o += ". Received type ".concat(typeof m), o;
  }, TypeError), n("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), n("ERR_METHOD_NOT_IMPLEMENTED", function(a) {
    return "The " + a + " method is not implemented";
  }), n("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), n("ERR_STREAM_DESTROYED", function(a) {
    return "Cannot call " + a + " after a stream was destroyed";
  }), n("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), n("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), n("ERR_STREAM_WRITE_AFTER_END", "write after end"), n("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), n("ERR_UNKNOWN_ENCODING", function(a) {
    return "Unknown encoding: " + a;
  }, TypeError), n("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), Vn.codes = r, Vn;
}
var zn, ya;
function nl() {
  if (ya) return zn;
  ya = 1;
  var e = Yt().codes.ERR_INVALID_OPT_VALUE;
  function r(t, g, i) {
    return t.highWaterMark != null ? t.highWaterMark : g ? t[i] : null;
  }
  function n(t, g, i, c) {
    var a = r(g, c, i);
    if (a != null) {
      if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
        var d = c ? i : "highWaterMark";
        throw new e(d, a);
      }
      return Math.floor(a);
    }
    return t.objectMode ? 16 : 16 * 1024;
  }
  return zn = {
    getHighWaterMark: n
  }, zn;
}
var Jn, ba;
function Sh() {
  if (ba) return Jn;
  ba = 1, Jn = e;
  function e(n, t) {
    if (r("noDeprecation"))
      return n;
    var g = !1;
    function i() {
      if (!g) {
        if (r("throwDeprecation"))
          throw new Error(t);
        r("traceDeprecation") ? console.trace(t) : console.warn(t), g = !0;
      }
      return n.apply(this, arguments);
    }
    return i;
  }
  function r(n) {
    try {
      if (!Zt.localStorage) return !1;
    } catch {
      return !1;
    }
    var t = Zt.localStorage[n];
    return t == null ? !1 : String(t).toLowerCase() === "true";
  }
  return Jn;
}
var Gn, va;
function il() {
  if (va) return Gn;
  va = 1, Gn = H;
  function e($) {
    var W = this;
    this.next = null, this.entry = null, this.finish = function() {
      K(W, $);
    };
  }
  var r;
  H.WritableState = q;
  var n = {
    deprecate: Sh()
  }, t = tl(), g = wn().Buffer, i = (typeof Zt < "u" ? Zt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function c($) {
    return g.from($);
  }
  function a($) {
    return g.isBuffer($) || $ instanceof i;
  }
  var d = rl(), m = nl(), p = m.getHighWaterMark, o = Yt().codes, l = o.ERR_INVALID_ARG_TYPE, s = o.ERR_METHOD_NOT_IMPLEMENTED, f = o.ERR_MULTIPLE_CALLBACK, b = o.ERR_STREAM_CANNOT_PIPE, y = o.ERR_STREAM_DESTROYED, u = o.ERR_STREAM_NULL_VALUES, R = o.ERR_STREAM_WRITE_AFTER_END, S = o.ERR_UNKNOWN_ENCODING, I = d.errorOrDestroy;
  Qe()(H, t);
  function T() {
  }
  function q($, W, J) {
    r = r || Kt(), $ = $ || {}, typeof J != "boolean" && (J = W instanceof r), this.objectMode = !!$.objectMode, J && (this.objectMode = this.objectMode || !!$.writableObjectMode), this.highWaterMark = p(this, $, "writableHighWaterMark", J), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ee = $.decodeStrings === !1;
    this.decodeStrings = !ee, this.defaultEncoding = $.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(oe) {
      C(W, oe);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = $.emitClose !== !1, this.autoDestroy = !!$.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  q.prototype.getBuffer = function() {
    for (var W = this.bufferedRequest, J = []; W; )
      J.push(W), W = W.next;
    return J;
  }, function() {
    try {
      Object.defineProperty(q.prototype, "buffer", {
        get: n.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var D;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (D = Function.prototype[Symbol.hasInstance], Object.defineProperty(H, Symbol.hasInstance, {
    value: function(W) {
      return D.call(this, W) ? !0 : this !== H ? !1 : W && W._writableState instanceof q;
    }
  })) : D = function(W) {
    return W instanceof this;
  };
  function H($) {
    r = r || Kt();
    var W = this instanceof r;
    if (!W && !D.call(H, this)) return new H($);
    this._writableState = new q($, this, W), this.writable = !0, $ && (typeof $.write == "function" && (this._write = $.write), typeof $.writev == "function" && (this._writev = $.writev), typeof $.destroy == "function" && (this._destroy = $.destroy), typeof $.final == "function" && (this._final = $.final)), t.call(this);
  }
  H.prototype.pipe = function() {
    I(this, new b());
  };
  function G($, W) {
    var J = new R();
    I($, J), process.nextTick(W, J);
  }
  function X($, W, J, ee) {
    var oe;
    return J === null ? oe = new u() : typeof J != "string" && !W.objectMode && (oe = new l("chunk", ["string", "Buffer"], J)), oe ? (I($, oe), process.nextTick(ee, oe), !1) : !0;
  }
  H.prototype.write = function($, W, J) {
    var ee = this._writableState, oe = !1, P = !ee.objectMode && a($);
    return P && !g.isBuffer($) && ($ = c($)), typeof W == "function" && (J = W, W = null), P ? W = "buffer" : W || (W = ee.defaultEncoding), typeof J != "function" && (J = T), ee.ending ? G(this, J) : (P || X(this, ee, $, J)) && (ee.pendingcb++, oe = re(this, ee, P, $, W, J)), oe;
  }, H.prototype.cork = function() {
    this._writableState.corked++;
  }, H.prototype.uncork = function() {
    var $ = this._writableState;
    $.corked && ($.corked--, !$.writing && !$.corked && !$.bufferProcessing && $.bufferedRequest && B(this, $));
  }, H.prototype.setDefaultEncoding = function(W) {
    if (typeof W == "string" && (W = W.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((W + "").toLowerCase()) > -1)) throw new S(W);
    return this._writableState.defaultEncoding = W, this;
  }, Object.defineProperty(H.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Y($, W, J) {
    return !$.objectMode && $.decodeStrings !== !1 && typeof W == "string" && (W = g.from(W, J)), W;
  }
  Object.defineProperty(H.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function re($, W, J, ee, oe, P) {
    if (!J) {
      var O = Y(W, ee, oe);
      ee !== O && (J = !0, oe = "buffer", ee = O);
    }
    var Z = W.objectMode ? 1 : ee.length;
    W.length += Z;
    var Q = W.length < W.highWaterMark;
    if (Q || (W.needDrain = !0), W.writing || W.corked) {
      var ae = W.lastBufferedRequest;
      W.lastBufferedRequest = {
        chunk: ee,
        encoding: oe,
        isBuf: J,
        callback: P,
        next: null
      }, ae ? ae.next = W.lastBufferedRequest : W.bufferedRequest = W.lastBufferedRequest, W.bufferedRequestCount += 1;
    } else
      F($, W, !1, Z, ee, oe, P);
    return Q;
  }
  function F($, W, J, ee, oe, P, O) {
    W.writelen = ee, W.writecb = O, W.writing = !0, W.sync = !0, W.destroyed ? W.onwrite(new y("write")) : J ? $._writev(oe, W.onwrite) : $._write(oe, P, W.onwrite), W.sync = !1;
  }
  function h($, W, J, ee, oe) {
    --W.pendingcb, J ? (process.nextTick(oe, ee), process.nextTick(N, $, W), $._writableState.errorEmitted = !0, I($, ee)) : (oe(ee), $._writableState.errorEmitted = !0, I($, ee), N($, W));
  }
  function E($) {
    $.writing = !1, $.writecb = null, $.length -= $.writelen, $.writelen = 0;
  }
  function C($, W) {
    var J = $._writableState, ee = J.sync, oe = J.writecb;
    if (typeof oe != "function") throw new f();
    if (E(J), W) h($, J, ee, W, oe);
    else {
      var P = j(J) || $.destroyed;
      !P && !J.corked && !J.bufferProcessing && J.bufferedRequest && B($, J), ee ? process.nextTick(M, $, J, P, oe) : M($, J, P, oe);
    }
  }
  function M($, W, J, ee) {
    J || x($, W), W.pendingcb--, ee(), N($, W);
  }
  function x($, W) {
    W.length === 0 && W.needDrain && (W.needDrain = !1, $.emit("drain"));
  }
  function B($, W) {
    W.bufferProcessing = !0;
    var J = W.bufferedRequest;
    if ($._writev && J && J.next) {
      var ee = W.bufferedRequestCount, oe = new Array(ee), P = W.corkedRequestsFree;
      P.entry = J;
      for (var O = 0, Z = !0; J; )
        oe[O] = J, J.isBuf || (Z = !1), J = J.next, O += 1;
      oe.allBuffers = Z, F($, W, !0, W.length, oe, "", P.finish), W.pendingcb++, W.lastBufferedRequest = null, P.next ? (W.corkedRequestsFree = P.next, P.next = null) : W.corkedRequestsFree = new e(W), W.bufferedRequestCount = 0;
    } else {
      for (; J; ) {
        var Q = J.chunk, ae = J.encoding, le = J.callback, ne = W.objectMode ? 1 : Q.length;
        if (F($, W, !1, ne, Q, ae, le), J = J.next, W.bufferedRequestCount--, W.writing)
          break;
      }
      J === null && (W.lastBufferedRequest = null);
    }
    W.bufferedRequest = J, W.bufferProcessing = !1;
  }
  H.prototype._write = function($, W, J) {
    J(new s("_write()"));
  }, H.prototype._writev = null, H.prototype.end = function($, W, J) {
    var ee = this._writableState;
    return typeof $ == "function" ? (J = $, $ = null, W = null) : typeof W == "function" && (J = W, W = null), $ != null && this.write($, W), ee.corked && (ee.corked = 1, this.uncork()), ee.ending || te(this, ee, J), this;
  }, Object.defineProperty(H.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function j($) {
    return $.ending && $.length === 0 && $.bufferedRequest === null && !$.finished && !$.writing;
  }
  function A($, W) {
    $._final(function(J) {
      W.pendingcb--, J && I($, J), W.prefinished = !0, $.emit("prefinish"), N($, W);
    });
  }
  function v($, W) {
    !W.prefinished && !W.finalCalled && (typeof $._final == "function" && !W.destroyed ? (W.pendingcb++, W.finalCalled = !0, process.nextTick(A, $, W)) : (W.prefinished = !0, $.emit("prefinish")));
  }
  function N($, W) {
    var J = j(W);
    if (J && (v($, W), W.pendingcb === 0 && (W.finished = !0, $.emit("finish"), W.autoDestroy))) {
      var ee = $._readableState;
      (!ee || ee.autoDestroy && ee.endEmitted) && $.destroy();
    }
    return J;
  }
  function te($, W, J) {
    W.ending = !0, N($, W), J && (W.finished ? process.nextTick(J) : $.once("finish", J)), W.ended = !0, $.writable = !1;
  }
  function K($, W, J) {
    var ee = $.entry;
    for ($.entry = null; ee; ) {
      var oe = ee.callback;
      W.pendingcb--, oe(J), ee = ee.next;
    }
    W.corkedRequestsFree.next = $;
  }
  return Object.defineProperty(H.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(W) {
      this._writableState && (this._writableState.destroyed = W);
    }
  }), H.prototype.destroy = d.destroy, H.prototype._undestroy = d.undestroy, H.prototype._destroy = function($, W) {
    W($);
  }, Gn;
}
var Zn, _a;
function Kt() {
  if (_a) return Zn;
  _a = 1;
  var e = Object.keys || function(m) {
    var p = [];
    for (var o in m) p.push(o);
    return p;
  };
  Zn = c;
  var r = sl(), n = il();
  Qe()(c, r);
  for (var t = e(n.prototype), g = 0; g < t.length; g++) {
    var i = t[g];
    c.prototype[i] || (c.prototype[i] = n.prototype[i]);
  }
  function c(m) {
    if (!(this instanceof c)) return new c(m);
    r.call(this, m), n.call(this, m), this.allowHalfOpen = !0, m && (m.readable === !1 && (this.readable = !1), m.writable === !1 && (this.writable = !1), m.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", a)));
  }
  Object.defineProperty(c.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(c.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(c.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function a() {
    this._writableState.ended || process.nextTick(d, this);
  }
  function d(m) {
    m.end();
  }
  return Object.defineProperty(c.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(p) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = p, this._writableState.destroyed = p);
    }
  }), Zn;
}
var Kn = {}, Ea;
function Ra() {
  if (Ea) return Kn;
  Ea = 1;
  var e = st().Buffer, r = e.isEncoding || function(u) {
    switch (u = "" + u, u && u.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function n(u) {
    if (!u) return "utf8";
    for (var R; ; )
      switch (u) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return u;
        default:
          if (R) return;
          u = ("" + u).toLowerCase(), R = !0;
      }
  }
  function t(u) {
    var R = n(u);
    if (typeof R != "string" && (e.isEncoding === r || !r(u))) throw new Error("Unknown encoding: " + u);
    return R || u;
  }
  Kn.StringDecoder = g;
  function g(u) {
    this.encoding = t(u);
    var R;
    switch (this.encoding) {
      case "utf16le":
        this.text = o, this.end = l, R = 4;
        break;
      case "utf8":
        this.fillLast = d, R = 4;
        break;
      case "base64":
        this.text = s, this.end = f, R = 3;
        break;
      default:
        this.write = b, this.end = y;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(R);
  }
  g.prototype.write = function(u) {
    if (u.length === 0) return "";
    var R, S;
    if (this.lastNeed) {
      if (R = this.fillLast(u), R === void 0) return "";
      S = this.lastNeed, this.lastNeed = 0;
    } else
      S = 0;
    return S < u.length ? R ? R + this.text(u, S) : this.text(u, S) : R || "";
  }, g.prototype.end = p, g.prototype.text = m, g.prototype.fillLast = function(u) {
    if (this.lastNeed <= u.length)
      return u.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    u.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, u.length), this.lastNeed -= u.length;
  };
  function i(u) {
    return u <= 127 ? 0 : u >> 5 === 6 ? 2 : u >> 4 === 14 ? 3 : u >> 3 === 30 ? 4 : u >> 6 === 2 ? -1 : -2;
  }
  function c(u, R, S) {
    var I = R.length - 1;
    if (I < S) return 0;
    var T = i(R[I]);
    return T >= 0 ? (T > 0 && (u.lastNeed = T - 1), T) : --I < S || T === -2 ? 0 : (T = i(R[I]), T >= 0 ? (T > 0 && (u.lastNeed = T - 2), T) : --I < S || T === -2 ? 0 : (T = i(R[I]), T >= 0 ? (T > 0 && (T === 2 ? T = 0 : u.lastNeed = T - 3), T) : 0));
  }
  function a(u, R, S) {
    if ((R[0] & 192) !== 128)
      return u.lastNeed = 0, "";
    if (u.lastNeed > 1 && R.length > 1) {
      if ((R[1] & 192) !== 128)
        return u.lastNeed = 1, "";
      if (u.lastNeed > 2 && R.length > 2 && (R[2] & 192) !== 128)
        return u.lastNeed = 2, "";
    }
  }
  function d(u) {
    var R = this.lastTotal - this.lastNeed, S = a(this, u);
    if (S !== void 0) return S;
    if (this.lastNeed <= u.length)
      return u.copy(this.lastChar, R, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    u.copy(this.lastChar, R, 0, u.length), this.lastNeed -= u.length;
  }
  function m(u, R) {
    var S = c(this, u, R);
    if (!this.lastNeed) return u.toString("utf8", R);
    this.lastTotal = S;
    var I = u.length - (S - this.lastNeed);
    return u.copy(this.lastChar, 0, I), u.toString("utf8", R, I);
  }
  function p(u) {
    var R = u && u.length ? this.write(u) : "";
    return this.lastNeed ? R + "" : R;
  }
  function o(u, R) {
    if ((u.length - R) % 2 === 0) {
      var S = u.toString("utf16le", R);
      if (S) {
        var I = S.charCodeAt(S.length - 1);
        if (I >= 55296 && I <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = u[u.length - 2], this.lastChar[1] = u[u.length - 1], S.slice(0, -1);
      }
      return S;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = u[u.length - 1], u.toString("utf16le", R, u.length - 1);
  }
  function l(u) {
    var R = u && u.length ? this.write(u) : "";
    if (this.lastNeed) {
      var S = this.lastTotal - this.lastNeed;
      return R + this.lastChar.toString("utf16le", 0, S);
    }
    return R;
  }
  function s(u, R) {
    var S = (u.length - R) % 3;
    return S === 0 ? u.toString("base64", R) : (this.lastNeed = 3 - S, this.lastTotal = 3, S === 1 ? this.lastChar[0] = u[u.length - 1] : (this.lastChar[0] = u[u.length - 2], this.lastChar[1] = u[u.length - 1]), u.toString("base64", R, u.length - S));
  }
  function f(u) {
    var R = u && u.length ? this.write(u) : "";
    return this.lastNeed ? R + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : R;
  }
  function b(u) {
    return u.toString(this.encoding);
  }
  function y(u) {
    return u && u.length ? this.write(u) : "";
  }
  return Kn;
}
var Qn, Sa;
function Us() {
  if (Sa) return Qn;
  Sa = 1;
  var e = Yt().codes.ERR_STREAM_PREMATURE_CLOSE;
  function r(i) {
    var c = !1;
    return function() {
      if (!c) {
        c = !0;
        for (var a = arguments.length, d = new Array(a), m = 0; m < a; m++)
          d[m] = arguments[m];
        i.apply(this, d);
      }
    };
  }
  function n() {
  }
  function t(i) {
    return i.setHeader && typeof i.abort == "function";
  }
  function g(i, c, a) {
    if (typeof c == "function") return g(i, null, c);
    c || (c = {}), a = r(a || n);
    var d = c.readable || c.readable !== !1 && i.readable, m = c.writable || c.writable !== !1 && i.writable, p = function() {
      i.writable || l();
    }, o = i._writableState && i._writableState.finished, l = function() {
      m = !1, o = !0, d || a.call(i);
    }, s = i._readableState && i._readableState.endEmitted, f = function() {
      d = !1, s = !0, m || a.call(i);
    }, b = function(S) {
      a.call(i, S);
    }, y = function() {
      var S;
      if (d && !s)
        return (!i._readableState || !i._readableState.ended) && (S = new e()), a.call(i, S);
      if (m && !o)
        return (!i._writableState || !i._writableState.ended) && (S = new e()), a.call(i, S);
    }, u = function() {
      i.req.on("finish", l);
    };
    return t(i) ? (i.on("complete", l), i.on("abort", y), i.req ? u() : i.on("request", u)) : m && !i._writableState && (i.on("end", p), i.on("close", p)), i.on("end", f), i.on("finish", l), c.error !== !1 && i.on("error", b), i.on("close", y), function() {
      i.removeListener("complete", l), i.removeListener("abort", y), i.removeListener("request", u), i.req && i.req.removeListener("finish", l), i.removeListener("end", p), i.removeListener("close", p), i.removeListener("finish", l), i.removeListener("end", f), i.removeListener("error", b), i.removeListener("close", y);
    };
  }
  return Qn = g, Qn;
}
var Yn, Ca;
function Ch() {
  if (Ca) return Yn;
  Ca = 1;
  var e;
  function r(S, I, T) {
    return I = n(I), I in S ? Object.defineProperty(S, I, { value: T, enumerable: !0, configurable: !0, writable: !0 }) : S[I] = T, S;
  }
  function n(S) {
    var I = t(S, "string");
    return typeof I == "symbol" ? I : String(I);
  }
  function t(S, I) {
    if (typeof S != "object" || S === null) return S;
    var T = S[Symbol.toPrimitive];
    if (T !== void 0) {
      var q = T.call(S, I || "default");
      if (typeof q != "object") return q;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (I === "string" ? String : Number)(S);
  }
  var g = Us(), i = Symbol("lastResolve"), c = Symbol("lastReject"), a = Symbol("error"), d = Symbol("ended"), m = Symbol("lastPromise"), p = Symbol("handlePromise"), o = Symbol("stream");
  function l(S, I) {
    return {
      value: S,
      done: I
    };
  }
  function s(S) {
    var I = S[i];
    if (I !== null) {
      var T = S[o].read();
      T !== null && (S[m] = null, S[i] = null, S[c] = null, I(l(T, !1)));
    }
  }
  function f(S) {
    process.nextTick(s, S);
  }
  function b(S, I) {
    return function(T, q) {
      S.then(function() {
        if (I[d]) {
          T(l(void 0, !0));
          return;
        }
        I[p](T, q);
      }, q);
    };
  }
  var y = Object.getPrototypeOf(function() {
  }), u = Object.setPrototypeOf((e = {
    get stream() {
      return this[o];
    },
    next: function() {
      var I = this, T = this[a];
      if (T !== null)
        return Promise.reject(T);
      if (this[d])
        return Promise.resolve(l(void 0, !0));
      if (this[o].destroyed)
        return new Promise(function(G, X) {
          process.nextTick(function() {
            I[a] ? X(I[a]) : G(l(void 0, !0));
          });
        });
      var q = this[m], D;
      if (q)
        D = new Promise(b(q, this));
      else {
        var H = this[o].read();
        if (H !== null)
          return Promise.resolve(l(H, !1));
        D = new Promise(this[p]);
      }
      return this[m] = D, D;
    }
  }, r(e, Symbol.asyncIterator, function() {
    return this;
  }), r(e, "return", function() {
    var I = this;
    return new Promise(function(T, q) {
      I[o].destroy(null, function(D) {
        if (D) {
          q(D);
          return;
        }
        T(l(void 0, !0));
      });
    });
  }), e), y), R = function(I) {
    var T, q = Object.create(u, (T = {}, r(T, o, {
      value: I,
      writable: !0
    }), r(T, i, {
      value: null,
      writable: !0
    }), r(T, c, {
      value: null,
      writable: !0
    }), r(T, a, {
      value: null,
      writable: !0
    }), r(T, d, {
      value: I._readableState.endEmitted,
      writable: !0
    }), r(T, p, {
      value: function(H, G) {
        var X = q[o].read();
        X ? (q[m] = null, q[i] = null, q[c] = null, H(l(X, !1))) : (q[i] = H, q[c] = G);
      },
      writable: !0
    }), T));
    return q[m] = null, g(I, function(D) {
      if (D && D.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var H = q[c];
        H !== null && (q[m] = null, q[i] = null, q[c] = null, H(D)), q[a] = D;
        return;
      }
      var G = q[i];
      G !== null && (q[m] = null, q[i] = null, q[c] = null, G(l(void 0, !0))), q[d] = !0;
    }), I.on("readable", f.bind(null, q)), q;
  };
  return Yn = R, Yn;
}
var Xn, Ma;
function Mh() {
  return Ma || (Ma = 1, Xn = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Xn;
}
var ei, ka;
function sl() {
  if (ka) return ei;
  ka = 1, ei = G;
  var e;
  G.ReadableState = H, dn().EventEmitter;
  var r = function(O, Z) {
    return O.listeners(Z).length;
  }, n = tl(), t = wn().Buffer, g = (typeof Zt < "u" ? Zt : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function i(P) {
    return t.from(P);
  }
  function c(P) {
    return t.isBuffer(P) || P instanceof g;
  }
  var a = Ps, d;
  a && a.debuglog ? d = a.debuglog("stream") : d = function() {
  };
  var m = Rh(), p = rl(), o = nl(), l = o.getHighWaterMark, s = Yt().codes, f = s.ERR_INVALID_ARG_TYPE, b = s.ERR_STREAM_PUSH_AFTER_EOF, y = s.ERR_METHOD_NOT_IMPLEMENTED, u = s.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, R, S, I;
  Qe()(G, n);
  var T = p.errorOrDestroy, q = ["error", "close", "destroy", "pause", "resume"];
  function D(P, O, Z) {
    if (typeof P.prependListener == "function") return P.prependListener(O, Z);
    !P._events || !P._events[O] ? P.on(O, Z) : Array.isArray(P._events[O]) ? P._events[O].unshift(Z) : P._events[O] = [Z, P._events[O]];
  }
  function H(P, O, Z) {
    e = e || Kt(), P = P || {}, typeof Z != "boolean" && (Z = O instanceof e), this.objectMode = !!P.objectMode, Z && (this.objectMode = this.objectMode || !!P.readableObjectMode), this.highWaterMark = l(this, P, "readableHighWaterMark", Z), this.buffer = new m(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = P.emitClose !== !1, this.autoDestroy = !!P.autoDestroy, this.destroyed = !1, this.defaultEncoding = P.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, P.encoding && (R || (R = Ra().StringDecoder), this.decoder = new R(P.encoding), this.encoding = P.encoding);
  }
  function G(P) {
    if (e = e || Kt(), !(this instanceof G)) return new G(P);
    var O = this instanceof e;
    this._readableState = new H(P, this, O), this.readable = !0, P && (typeof P.read == "function" && (this._read = P.read), typeof P.destroy == "function" && (this._destroy = P.destroy)), n.call(this);
  }
  Object.defineProperty(G.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(O) {
      this._readableState && (this._readableState.destroyed = O);
    }
  }), G.prototype.destroy = p.destroy, G.prototype._undestroy = p.undestroy, G.prototype._destroy = function(P, O) {
    O(P);
  }, G.prototype.push = function(P, O) {
    var Z = this._readableState, Q;
    return Z.objectMode ? Q = !0 : typeof P == "string" && (O = O || Z.defaultEncoding, O !== Z.encoding && (P = t.from(P, O), O = ""), Q = !0), X(this, P, O, !1, Q);
  }, G.prototype.unshift = function(P) {
    return X(this, P, null, !0, !1);
  };
  function X(P, O, Z, Q, ae) {
    d("readableAddChunk", O);
    var le = P._readableState;
    if (O === null)
      le.reading = !1, C(P, le);
    else {
      var ne;
      if (ae || (ne = re(le, O)), ne)
        T(P, ne);
      else if (le.objectMode || O && O.length > 0)
        if (typeof O != "string" && !le.objectMode && Object.getPrototypeOf(O) !== t.prototype && (O = i(O)), Q)
          le.endEmitted ? T(P, new u()) : Y(P, le, O, !0);
        else if (le.ended)
          T(P, new b());
        else {
          if (le.destroyed)
            return !1;
          le.reading = !1, le.decoder && !Z ? (O = le.decoder.write(O), le.objectMode || O.length !== 0 ? Y(P, le, O, !1) : B(P, le)) : Y(P, le, O, !1);
        }
      else Q || (le.reading = !1, B(P, le));
    }
    return !le.ended && (le.length < le.highWaterMark || le.length === 0);
  }
  function Y(P, O, Z, Q) {
    O.flowing && O.length === 0 && !O.sync ? (O.awaitDrain = 0, P.emit("data", Z)) : (O.length += O.objectMode ? 1 : Z.length, Q ? O.buffer.unshift(Z) : O.buffer.push(Z), O.needReadable && M(P)), B(P, O);
  }
  function re(P, O) {
    var Z;
    return !c(O) && typeof O != "string" && O !== void 0 && !P.objectMode && (Z = new f("chunk", ["string", "Buffer", "Uint8Array"], O)), Z;
  }
  G.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, G.prototype.setEncoding = function(P) {
    R || (R = Ra().StringDecoder);
    var O = new R(P);
    this._readableState.decoder = O, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Z = this._readableState.buffer.head, Q = ""; Z !== null; )
      Q += O.write(Z.data), Z = Z.next;
    return this._readableState.buffer.clear(), Q !== "" && this._readableState.buffer.push(Q), this._readableState.length = Q.length, this;
  };
  var F = 1073741824;
  function h(P) {
    return P >= F ? P = F : (P--, P |= P >>> 1, P |= P >>> 2, P |= P >>> 4, P |= P >>> 8, P |= P >>> 16, P++), P;
  }
  function E(P, O) {
    return P <= 0 || O.length === 0 && O.ended ? 0 : O.objectMode ? 1 : P !== P ? O.flowing && O.length ? O.buffer.head.data.length : O.length : (P > O.highWaterMark && (O.highWaterMark = h(P)), P <= O.length ? P : O.ended ? O.length : (O.needReadable = !0, 0));
  }
  G.prototype.read = function(P) {
    d("read", P), P = parseInt(P, 10);
    var O = this._readableState, Z = P;
    if (P !== 0 && (O.emittedReadable = !1), P === 0 && O.needReadable && ((O.highWaterMark !== 0 ? O.length >= O.highWaterMark : O.length > 0) || O.ended))
      return d("read: emitReadable", O.length, O.ended), O.length === 0 && O.ended ? J(this) : M(this), null;
    if (P = E(P, O), P === 0 && O.ended)
      return O.length === 0 && J(this), null;
    var Q = O.needReadable;
    d("need readable", Q), (O.length === 0 || O.length - P < O.highWaterMark) && (Q = !0, d("length less than watermark", Q)), O.ended || O.reading ? (Q = !1, d("reading or ended", Q)) : Q && (d("do read"), O.reading = !0, O.sync = !0, O.length === 0 && (O.needReadable = !0), this._read(O.highWaterMark), O.sync = !1, O.reading || (P = E(Z, O)));
    var ae;
    return P > 0 ? ae = W(P, O) : ae = null, ae === null ? (O.needReadable = O.length <= O.highWaterMark, P = 0) : (O.length -= P, O.awaitDrain = 0), O.length === 0 && (O.ended || (O.needReadable = !0), Z !== P && O.ended && J(this)), ae !== null && this.emit("data", ae), ae;
  };
  function C(P, O) {
    if (d("onEofChunk"), !O.ended) {
      if (O.decoder) {
        var Z = O.decoder.end();
        Z && Z.length && (O.buffer.push(Z), O.length += O.objectMode ? 1 : Z.length);
      }
      O.ended = !0, O.sync ? M(P) : (O.needReadable = !1, O.emittedReadable || (O.emittedReadable = !0, x(P)));
    }
  }
  function M(P) {
    var O = P._readableState;
    d("emitReadable", O.needReadable, O.emittedReadable), O.needReadable = !1, O.emittedReadable || (d("emitReadable", O.flowing), O.emittedReadable = !0, process.nextTick(x, P));
  }
  function x(P) {
    var O = P._readableState;
    d("emitReadable_", O.destroyed, O.length, O.ended), !O.destroyed && (O.length || O.ended) && (P.emit("readable"), O.emittedReadable = !1), O.needReadable = !O.flowing && !O.ended && O.length <= O.highWaterMark, $(P);
  }
  function B(P, O) {
    O.readingMore || (O.readingMore = !0, process.nextTick(j, P, O));
  }
  function j(P, O) {
    for (; !O.reading && !O.ended && (O.length < O.highWaterMark || O.flowing && O.length === 0); ) {
      var Z = O.length;
      if (d("maybeReadMore read 0"), P.read(0), Z === O.length)
        break;
    }
    O.readingMore = !1;
  }
  G.prototype._read = function(P) {
    T(this, new y("_read()"));
  }, G.prototype.pipe = function(P, O) {
    var Z = this, Q = this._readableState;
    switch (Q.pipesCount) {
      case 0:
        Q.pipes = P;
        break;
      case 1:
        Q.pipes = [Q.pipes, P];
        break;
      default:
        Q.pipes.push(P);
        break;
    }
    Q.pipesCount += 1, d("pipe count=%d opts=%j", Q.pipesCount, O);
    var ae = (!O || O.end !== !1) && P !== process.stdout && P !== process.stderr, le = ae ? fe : ye;
    Q.endEmitted ? process.nextTick(le) : Z.once("end", le), P.on("unpipe", ne);
    function ne(k, w) {
      d("onunpipe"), k === Z && w && w.hasUnpiped === !1 && (w.hasUnpiped = !0, he());
    }
    function fe() {
      d("onend"), P.end();
    }
    var He = A(Z);
    P.on("drain", He);
    var me = !1;
    function he() {
      d("cleanup"), P.removeListener("close", we), P.removeListener("finish", je), P.removeListener("drain", He), P.removeListener("error", pe), P.removeListener("unpipe", ne), Z.removeListener("end", fe), Z.removeListener("end", ye), Z.removeListener("data", ve), me = !0, Q.awaitDrain && (!P._writableState || P._writableState.needDrain) && He();
    }
    Z.on("data", ve);
    function ve(k) {
      d("ondata");
      var w = P.write(k);
      d("dest.write", w), w === !1 && ((Q.pipesCount === 1 && Q.pipes === P || Q.pipesCount > 1 && oe(Q.pipes, P) !== -1) && !me && (d("false write response, pause", Q.awaitDrain), Q.awaitDrain++), Z.pause());
    }
    function pe(k) {
      d("onerror", k), ye(), P.removeListener("error", pe), r(P, "error") === 0 && T(P, k);
    }
    D(P, "error", pe);
    function we() {
      P.removeListener("finish", je), ye();
    }
    P.once("close", we);
    function je() {
      d("onfinish"), P.removeListener("close", we), ye();
    }
    P.once("finish", je);
    function ye() {
      d("unpipe"), Z.unpipe(P);
    }
    return P.emit("pipe", Z), Q.flowing || (d("pipe resume"), Z.resume()), P;
  };
  function A(P) {
    return function() {
      var Z = P._readableState;
      d("pipeOnDrain", Z.awaitDrain), Z.awaitDrain && Z.awaitDrain--, Z.awaitDrain === 0 && r(P, "data") && (Z.flowing = !0, $(P));
    };
  }
  G.prototype.unpipe = function(P) {
    var O = this._readableState, Z = {
      hasUnpiped: !1
    };
    if (O.pipesCount === 0) return this;
    if (O.pipesCount === 1)
      return P && P !== O.pipes ? this : (P || (P = O.pipes), O.pipes = null, O.pipesCount = 0, O.flowing = !1, P && P.emit("unpipe", this, Z), this);
    if (!P) {
      var Q = O.pipes, ae = O.pipesCount;
      O.pipes = null, O.pipesCount = 0, O.flowing = !1;
      for (var le = 0; le < ae; le++) Q[le].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var ne = oe(O.pipes, P);
    return ne === -1 ? this : (O.pipes.splice(ne, 1), O.pipesCount -= 1, O.pipesCount === 1 && (O.pipes = O.pipes[0]), P.emit("unpipe", this, Z), this);
  }, G.prototype.on = function(P, O) {
    var Z = n.prototype.on.call(this, P, O), Q = this._readableState;
    return P === "data" ? (Q.readableListening = this.listenerCount("readable") > 0, Q.flowing !== !1 && this.resume()) : P === "readable" && !Q.endEmitted && !Q.readableListening && (Q.readableListening = Q.needReadable = !0, Q.flowing = !1, Q.emittedReadable = !1, d("on readable", Q.length, Q.reading), Q.length ? M(this) : Q.reading || process.nextTick(N, this)), Z;
  }, G.prototype.addListener = G.prototype.on, G.prototype.removeListener = function(P, O) {
    var Z = n.prototype.removeListener.call(this, P, O);
    return P === "readable" && process.nextTick(v, this), Z;
  }, G.prototype.removeAllListeners = function(P) {
    var O = n.prototype.removeAllListeners.apply(this, arguments);
    return (P === "readable" || P === void 0) && process.nextTick(v, this), O;
  };
  function v(P) {
    var O = P._readableState;
    O.readableListening = P.listenerCount("readable") > 0, O.resumeScheduled && !O.paused ? O.flowing = !0 : P.listenerCount("data") > 0 && P.resume();
  }
  function N(P) {
    d("readable nexttick read 0"), P.read(0);
  }
  G.prototype.resume = function() {
    var P = this._readableState;
    return P.flowing || (d("resume"), P.flowing = !P.readableListening, te(this, P)), P.paused = !1, this;
  };
  function te(P, O) {
    O.resumeScheduled || (O.resumeScheduled = !0, process.nextTick(K, P, O));
  }
  function K(P, O) {
    d("resume", O.reading), O.reading || P.read(0), O.resumeScheduled = !1, P.emit("resume"), $(P), O.flowing && !O.reading && P.read(0);
  }
  G.prototype.pause = function() {
    return d("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (d("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function $(P) {
    var O = P._readableState;
    for (d("flow", O.flowing); O.flowing && P.read() !== null; ) ;
  }
  G.prototype.wrap = function(P) {
    var O = this, Z = this._readableState, Q = !1;
    P.on("end", function() {
      if (d("wrapped end"), Z.decoder && !Z.ended) {
        var ne = Z.decoder.end();
        ne && ne.length && O.push(ne);
      }
      O.push(null);
    }), P.on("data", function(ne) {
      if (d("wrapped data"), Z.decoder && (ne = Z.decoder.write(ne)), !(Z.objectMode && ne == null) && !(!Z.objectMode && (!ne || !ne.length))) {
        var fe = O.push(ne);
        fe || (Q = !0, P.pause());
      }
    });
    for (var ae in P)
      this[ae] === void 0 && typeof P[ae] == "function" && (this[ae] = /* @__PURE__ */ function(fe) {
        return function() {
          return P[fe].apply(P, arguments);
        };
      }(ae));
    for (var le = 0; le < q.length; le++)
      P.on(q[le], this.emit.bind(this, q[le]));
    return this._read = function(ne) {
      d("wrapped _read", ne), Q && (Q = !1, P.resume());
    }, this;
  }, typeof Symbol == "function" && (G.prototype[Symbol.asyncIterator] = function() {
    return S === void 0 && (S = Ch()), S(this);
  }), Object.defineProperty(G.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(G.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(G.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(O) {
      this._readableState && (this._readableState.flowing = O);
    }
  }), G._fromList = W, Object.defineProperty(G.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function W(P, O) {
    if (O.length === 0) return null;
    var Z;
    return O.objectMode ? Z = O.buffer.shift() : !P || P >= O.length ? (O.decoder ? Z = O.buffer.join("") : O.buffer.length === 1 ? Z = O.buffer.first() : Z = O.buffer.concat(O.length), O.buffer.clear()) : Z = O.buffer.consume(P, O.decoder), Z;
  }
  function J(P) {
    var O = P._readableState;
    d("endReadable", O.endEmitted), O.endEmitted || (O.ended = !0, process.nextTick(ee, O, P));
  }
  function ee(P, O) {
    if (d("endReadableNT", P.endEmitted, P.length), !P.endEmitted && P.length === 0 && (P.endEmitted = !0, O.readable = !1, O.emit("end"), P.autoDestroy)) {
      var Z = O._writableState;
      (!Z || Z.autoDestroy && Z.finished) && O.destroy();
    }
  }
  typeof Symbol == "function" && (G.from = function(P, O) {
    return I === void 0 && (I = Mh()), I(G, P, O);
  });
  function oe(P, O) {
    for (var Z = 0, Q = P.length; Z < Q; Z++)
      if (P[Z] === O) return Z;
    return -1;
  }
  return ei;
}
var ti, Ia;
function ol() {
  if (Ia) return ti;
  Ia = 1, ti = a;
  var e = Yt().codes, r = e.ERR_METHOD_NOT_IMPLEMENTED, n = e.ERR_MULTIPLE_CALLBACK, t = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, g = e.ERR_TRANSFORM_WITH_LENGTH_0, i = Kt();
  Qe()(a, i);
  function c(p, o) {
    var l = this._transformState;
    l.transforming = !1;
    var s = l.writecb;
    if (s === null)
      return this.emit("error", new n());
    l.writechunk = null, l.writecb = null, o != null && this.push(o), s(p);
    var f = this._readableState;
    f.reading = !1, (f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
  }
  function a(p) {
    if (!(this instanceof a)) return new a(p);
    i.call(this, p), this._transformState = {
      afterTransform: c.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, p && (typeof p.transform == "function" && (this._transform = p.transform), typeof p.flush == "function" && (this._flush = p.flush)), this.on("prefinish", d);
  }
  function d() {
    var p = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(o, l) {
      m(p, o, l);
    }) : m(this, null, null);
  }
  a.prototype.push = function(p, o) {
    return this._transformState.needTransform = !1, i.prototype.push.call(this, p, o);
  }, a.prototype._transform = function(p, o, l) {
    l(new r("_transform()"));
  }, a.prototype._write = function(p, o, l) {
    var s = this._transformState;
    if (s.writecb = l, s.writechunk = p, s.writeencoding = o, !s.transforming) {
      var f = this._readableState;
      (s.needTransform || f.needReadable || f.length < f.highWaterMark) && this._read(f.highWaterMark);
    }
  }, a.prototype._read = function(p) {
    var o = this._transformState;
    o.writechunk !== null && !o.transforming ? (o.transforming = !0, this._transform(o.writechunk, o.writeencoding, o.afterTransform)) : o.needTransform = !0;
  }, a.prototype._destroy = function(p, o) {
    i.prototype._destroy.call(this, p, function(l) {
      o(l);
    });
  };
  function m(p, o, l) {
    if (o) return p.emit("error", o);
    if (l != null && p.push(l), p._writableState.length) throw new g();
    if (p._transformState.transforming) throw new t();
    return p.push(null);
  }
  return ti;
}
var ri, xa;
function kh() {
  if (xa) return ri;
  xa = 1, ri = r;
  var e = ol();
  Qe()(r, e);
  function r(n) {
    if (!(this instanceof r)) return new r(n);
    e.call(this, n);
  }
  return r.prototype._transform = function(n, t, g) {
    g(null, n);
  }, ri;
}
var ni, Aa;
function Ih() {
  if (Aa) return ni;
  Aa = 1;
  var e;
  function r(l) {
    var s = !1;
    return function() {
      s || (s = !0, l.apply(void 0, arguments));
    };
  }
  var n = Yt().codes, t = n.ERR_MISSING_ARGS, g = n.ERR_STREAM_DESTROYED;
  function i(l) {
    if (l) throw l;
  }
  function c(l) {
    return l.setHeader && typeof l.abort == "function";
  }
  function a(l, s, f, b) {
    b = r(b);
    var y = !1;
    l.on("close", function() {
      y = !0;
    }), e === void 0 && (e = Us()), e(l, {
      readable: s,
      writable: f
    }, function(R) {
      if (R) return b(R);
      y = !0, b();
    });
    var u = !1;
    return function(R) {
      if (!y && !u) {
        if (u = !0, c(l)) return l.abort();
        if (typeof l.destroy == "function") return l.destroy();
        b(R || new g("pipe"));
      }
    };
  }
  function d(l) {
    l();
  }
  function m(l, s) {
    return l.pipe(s);
  }
  function p(l) {
    return !l.length || typeof l[l.length - 1] != "function" ? i : l.pop();
  }
  function o() {
    for (var l = arguments.length, s = new Array(l), f = 0; f < l; f++)
      s[f] = arguments[f];
    var b = p(s);
    if (Array.isArray(s[0]) && (s = s[0]), s.length < 2)
      throw new t("streams");
    var y, u = s.map(function(R, S) {
      var I = S < s.length - 1, T = S > 0;
      return a(R, I, T, function(q) {
        y || (y = q), q && u.forEach(d), !I && (u.forEach(d), b(y));
      });
    });
    return s.reduce(m);
  }
  return ni = o, ni;
}
var Ta;
function al() {
  return Ta || (Ta = 1, function(e, r) {
    r = e.exports = sl(), r.Stream = r, r.Readable = r, r.Writable = il(), r.Duplex = Kt(), r.Transform = ol(), r.PassThrough = kh(), r.finished = Us(), r.pipeline = Ih();
  }(nn, nn.exports)), nn.exports;
}
var ii, La;
function xh() {
  if (La) return ii;
  La = 1;
  const { Transform: e } = al();
  return ii = (r) => class ul extends e {
    constructor(t, g, i, c, a) {
      super(a), this._rate = t, this._capacity = g, this._delimitedSuffix = i, this._hashBitLength = c, this._options = a, this._state = new r(), this._state.initialize(t, g), this._finalized = !1;
    }
    _transform(t, g, i) {
      let c = null;
      try {
        this.update(t, g);
      } catch (a) {
        c = a;
      }
      i(c);
    }
    _flush(t) {
      let g = null;
      try {
        this.push(this.digest());
      } catch (i) {
        g = i;
      }
      t(g);
    }
    update(t, g) {
      if (!Buffer.isBuffer(t) && typeof t != "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Digest already called");
      return Buffer.isBuffer(t) || (t = Buffer.from(t, g)), this._state.absorb(t), this;
    }
    digest(t) {
      if (this._finalized) throw new Error("Digest already called");
      this._finalized = !0, this._delimitedSuffix && this._state.absorbLastFewBits(this._delimitedSuffix);
      let g = this._state.squeeze(this._hashBitLength / 8);
      return t !== void 0 && (g = g.toString(t)), this._resetState(), g;
    }
    // remove result from memory
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    // because sometimes we need hash right now and little later
    _clone() {
      const t = new ul(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
      return this._state.copy(t._state), t._finalized = this._finalized, t;
    }
  }, ii;
}
var si, Ba;
function Ah() {
  if (Ba) return si;
  Ba = 1;
  const { Transform: e } = al();
  return si = (r) => class cl extends e {
    constructor(t, g, i, c) {
      super(c), this._rate = t, this._capacity = g, this._delimitedSuffix = i, this._options = c, this._state = new r(), this._state.initialize(t, g), this._finalized = !1;
    }
    _transform(t, g, i) {
      let c = null;
      try {
        this.update(t, g);
      } catch (a) {
        c = a;
      }
      i(c);
    }
    _flush() {
    }
    _read(t) {
      this.push(this.squeeze(t));
    }
    update(t, g) {
      if (!Buffer.isBuffer(t) && typeof t != "string") throw new TypeError("Data must be a string or a buffer");
      if (this._finalized) throw new Error("Squeeze already called");
      return Buffer.isBuffer(t) || (t = Buffer.from(t, g)), this._state.absorb(t), this;
    }
    squeeze(t, g) {
      this._finalized || (this._finalized = !0, this._state.absorbLastFewBits(this._delimitedSuffix));
      let i = this._state.squeeze(t);
      return g !== void 0 && (i = i.toString(g)), i;
    }
    _resetState() {
      return this._state.initialize(this._rate, this._capacity), this;
    }
    _clone() {
      const t = new cl(this._rate, this._capacity, this._delimitedSuffix, this._options);
      return this._state.copy(t._state), t._finalized = this._finalized, t;
    }
  }, si;
}
var oi, Na;
function Th() {
  if (Na) return oi;
  Na = 1;
  const e = xh(), r = Ah();
  return oi = function(n) {
    const t = e(n), g = r(n);
    return function(i, c) {
      switch (typeof i == "string" ? i.toLowerCase() : i) {
        case "keccak224":
          return new t(1152, 448, null, 224, c);
        case "keccak256":
          return new t(1088, 512, null, 256, c);
        case "keccak384":
          return new t(832, 768, null, 384, c);
        case "keccak512":
          return new t(576, 1024, null, 512, c);
        case "sha3-224":
          return new t(1152, 448, 6, 224, c);
        case "sha3-256":
          return new t(1088, 512, 6, 256, c);
        case "sha3-384":
          return new t(832, 768, 6, 384, c);
        case "sha3-512":
          return new t(576, 1024, 6, 512, c);
        case "shake128":
          return new g(1344, 256, 31, c);
        case "shake256":
          return new g(1088, 512, 31, c);
        default:
          throw new Error("Invald algorithm: " + i);
      }
    };
  }, oi;
}
var ai = {}, Pa;
function Lh() {
  if (Pa) return ai;
  Pa = 1;
  const e = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  return ai.p1600 = function(r) {
    for (let n = 0; n < 24; ++n) {
      const t = r[0] ^ r[10] ^ r[20] ^ r[30] ^ r[40], g = r[1] ^ r[11] ^ r[21] ^ r[31] ^ r[41], i = r[2] ^ r[12] ^ r[22] ^ r[32] ^ r[42], c = r[3] ^ r[13] ^ r[23] ^ r[33] ^ r[43], a = r[4] ^ r[14] ^ r[24] ^ r[34] ^ r[44], d = r[5] ^ r[15] ^ r[25] ^ r[35] ^ r[45], m = r[6] ^ r[16] ^ r[26] ^ r[36] ^ r[46], p = r[7] ^ r[17] ^ r[27] ^ r[37] ^ r[47], o = r[8] ^ r[18] ^ r[28] ^ r[38] ^ r[48], l = r[9] ^ r[19] ^ r[29] ^ r[39] ^ r[49];
      let s = o ^ (i << 1 | c >>> 31), f = l ^ (c << 1 | i >>> 31);
      const b = r[0] ^ s, y = r[1] ^ f, u = r[10] ^ s, R = r[11] ^ f, S = r[20] ^ s, I = r[21] ^ f, T = r[30] ^ s, q = r[31] ^ f, D = r[40] ^ s, H = r[41] ^ f;
      s = t ^ (a << 1 | d >>> 31), f = g ^ (d << 1 | a >>> 31);
      const G = r[2] ^ s, X = r[3] ^ f, Y = r[12] ^ s, re = r[13] ^ f, F = r[22] ^ s, h = r[23] ^ f, E = r[32] ^ s, C = r[33] ^ f, M = r[42] ^ s, x = r[43] ^ f;
      s = i ^ (m << 1 | p >>> 31), f = c ^ (p << 1 | m >>> 31);
      const B = r[4] ^ s, j = r[5] ^ f, A = r[14] ^ s, v = r[15] ^ f, N = r[24] ^ s, te = r[25] ^ f, K = r[34] ^ s, $ = r[35] ^ f, W = r[44] ^ s, J = r[45] ^ f;
      s = a ^ (o << 1 | l >>> 31), f = d ^ (l << 1 | o >>> 31);
      const ee = r[6] ^ s, oe = r[7] ^ f, P = r[16] ^ s, O = r[17] ^ f, Z = r[26] ^ s, Q = r[27] ^ f, ae = r[36] ^ s, le = r[37] ^ f, ne = r[46] ^ s, fe = r[47] ^ f;
      s = m ^ (t << 1 | g >>> 31), f = p ^ (g << 1 | t >>> 31);
      const He = r[8] ^ s, me = r[9] ^ f, he = r[18] ^ s, ve = r[19] ^ f, pe = r[28] ^ s, we = r[29] ^ f, je = r[38] ^ s, ye = r[39] ^ f, k = r[48] ^ s, w = r[49] ^ f, _ = b, L = y, U = R << 4 | u >>> 28, V = u << 4 | R >>> 28, z = S << 3 | I >>> 29, de = I << 3 | S >>> 29, ce = q << 9 | T >>> 23, ue = T << 9 | q >>> 23, be = D << 18 | H >>> 14, se = H << 18 | D >>> 14, _e = G << 1 | X >>> 31, At = X << 1 | G >>> 31, Ee = re << 12 | Y >>> 20, Re = Y << 12 | re >>> 20, Tt = F << 10 | h >>> 22, Se = h << 10 | F >>> 22, Ce = C << 13 | E >>> 19, Lt = E << 13 | C >>> 19, Me = M << 2 | x >>> 30, ke = x << 2 | M >>> 30, Bt = j << 30 | B >>> 2, Ie = B << 30 | j >>> 2, xe = A << 6 | v >>> 26, Nt = v << 6 | A >>> 26, Ae = te << 11 | N >>> 21, Te = N << 11 | te >>> 21, Pt = K << 15 | $ >>> 17, Le = $ << 15 | K >>> 17, Be = J << 29 | W >>> 3, Ot = W << 29 | J >>> 3, Ne = ee << 28 | oe >>> 4, Pe = oe << 28 | ee >>> 4, Ft = O << 23 | P >>> 9, Oe = P << 23 | O >>> 9, Fe = Z << 25 | Q >>> 7, at = Q << 25 | Z >>> 7, ut = ae << 21 | le >>> 11, ct = le << 21 | ae >>> 11, lt = fe << 24 | ne >>> 8, ht = ne << 24 | fe >>> 8, dt = He << 27 | me >>> 5, ft = me << 27 | He >>> 5, pt = he << 20 | ve >>> 12, gt = ve << 20 | he >>> 12, mt = we << 7 | pe >>> 25, wt = pe << 7 | we >>> 25, yt = je << 8 | ye >>> 24, bt = ye << 8 | je >>> 24, vt = k << 14 | w >>> 18, _t = w << 14 | k >>> 18;
      r[0] = _ ^ ~Ee & Ae, r[1] = L ^ ~Re & Te, r[10] = Ne ^ ~pt & z, r[11] = Pe ^ ~gt & de, r[20] = _e ^ ~xe & Fe, r[21] = At ^ ~Nt & at, r[30] = dt ^ ~U & Tt, r[31] = ft ^ ~V & Se, r[40] = Bt ^ ~Ft & mt, r[41] = Ie ^ ~Oe & wt, r[2] = Ee ^ ~Ae & ut, r[3] = Re ^ ~Te & ct, r[12] = pt ^ ~z & Ce, r[13] = gt ^ ~de & Lt, r[22] = xe ^ ~Fe & yt, r[23] = Nt ^ ~at & bt, r[32] = U ^ ~Tt & Pt, r[33] = V ^ ~Se & Le, r[42] = Ft ^ ~mt & ce, r[43] = Oe ^ ~wt & ue, r[4] = Ae ^ ~ut & vt, r[5] = Te ^ ~ct & _t, r[14] = z ^ ~Ce & Be, r[15] = de ^ ~Lt & Ot, r[24] = Fe ^ ~yt & be, r[25] = at ^ ~bt & se, r[34] = Tt ^ ~Pt & lt, r[35] = Se ^ ~Le & ht, r[44] = mt ^ ~ce & Me, r[45] = wt ^ ~ue & ke, r[6] = ut ^ ~vt & _, r[7] = ct ^ ~_t & L, r[16] = Ce ^ ~Be & Ne, r[17] = Lt ^ ~Ot & Pe, r[26] = yt ^ ~be & _e, r[27] = bt ^ ~se & At, r[36] = Pt ^ ~lt & dt, r[37] = Le ^ ~ht & ft, r[46] = ce ^ ~Me & Bt, r[47] = ue ^ ~ke & Ie, r[8] = vt ^ ~_ & Ee, r[9] = _t ^ ~L & Re, r[18] = Be ^ ~Ne & pt, r[19] = Ot ^ ~Pe & gt, r[28] = be ^ ~_e & xe, r[29] = se ^ ~At & Nt, r[38] = lt ^ ~dt & U, r[39] = ht ^ ~ft & V, r[48] = Me ^ ~Bt & Ft, r[49] = ke ^ ~Ie & Oe, r[0] ^= e[n * 2], r[1] ^= e[n * 2 + 1];
    }
  }, ai;
}
var ui, Oa;
function Bh() {
  if (Oa) return ui;
  Oa = 1;
  const e = Lh();
  function r() {
    this.state = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ], this.blockSize = null, this.count = 0, this.squeezing = !1;
  }
  return r.prototype.initialize = function(n, t) {
    for (let g = 0; g < 50; ++g) this.state[g] = 0;
    this.blockSize = n / 8, this.count = 0, this.squeezing = !1;
  }, r.prototype.absorb = function(n) {
    for (let t = 0; t < n.length; ++t)
      this.state[~~(this.count / 4)] ^= n[t] << 8 * (this.count % 4), this.count += 1, this.count === this.blockSize && (e.p1600(this.state), this.count = 0);
  }, r.prototype.absorbLastFewBits = function(n) {
    this.state[~~(this.count / 4)] ^= n << 8 * (this.count % 4), n & 128 && this.count === this.blockSize - 1 && e.p1600(this.state), this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4), e.p1600(this.state), this.count = 0, this.squeezing = !0;
  }, r.prototype.squeeze = function(n) {
    this.squeezing || this.absorbLastFewBits(1);
    const t = Buffer.alloc(n);
    for (let g = 0; g < n; ++g)
      t[g] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255, this.count += 1, this.count === this.blockSize && (e.p1600(this.state), this.count = 0);
    return t;
  }, r.prototype.copy = function(n) {
    for (let t = 0; t < 50; ++t) n.state[t] = this.state[t];
    n.blockSize = this.blockSize, n.count = this.count, n.squeezing = this.squeezing;
  }, ui = r, ui;
}
var ci, Fa;
function Nh() {
  return Fa || (Fa = 1, ci = Th()(Bh())), ci;
}
var li, Da;
function ll() {
  if (Da) return li;
  Da = 1;
  const e = Nh(), r = fn();
  function n(o) {
    return Buffer.allocUnsafe(o).fill(0);
  }
  function t(o, l, s) {
    const f = n(l);
    return o = i(o), s ? o.length < l ? (o.copy(f), f) : o.slice(0, l) : o.length < l ? (o.copy(f, l - o.length), f) : o.slice(-l);
  }
  function g(o, l) {
    return t(o, l, !0);
  }
  function i(o) {
    if (!Buffer.isBuffer(o))
      if (Array.isArray(o))
        o = Buffer.from(o);
      else if (typeof o == "string")
        m(o) ? o = Buffer.from(d(p(o)), "hex") : o = Buffer.from(o);
      else if (typeof o == "number")
        o = intToBuffer(o);
      else if (o == null)
        o = Buffer.allocUnsafe(0);
      else if (r.isBN(o))
        o = o.toArrayLike(Buffer);
      else if (o.toArray)
        o = Buffer.from(o.toArray());
      else
        throw new Error("invalid type");
    return o;
  }
  function c(o) {
    return o = i(o), "0x" + o.toString("hex");
  }
  function a(o, l) {
    return o = i(o), l || (l = 256), e("keccak" + l).update(o).digest();
  }
  function d(o) {
    return o.length % 2 ? "0" + o : o;
  }
  function m(o) {
    return typeof o == "string" && o.match(/^0x[0-9A-Fa-f]*$/);
  }
  function p(o) {
    return typeof o == "string" && o.startsWith("0x") ? o.slice(2) : o;
  }
  return li = {
    zeros: n,
    setLength: t,
    setLengthRight: g,
    isHexString: m,
    stripHexPrefix: p,
    toBuffer: i,
    bufferToHex: c,
    keccak: a
  }, li;
}
var hi, qa;
function Ph() {
  if (qa) return hi;
  qa = 1;
  const e = /* @__PURE__ */ ll(), r = fn();
  function n(s) {
    return s.startsWith("int[") ? "int256" + s.slice(3) : s === "int" ? "int256" : s.startsWith("uint[") ? "uint256" + s.slice(4) : s === "uint" ? "uint256" : s.startsWith("fixed[") ? "fixed128x128" + s.slice(5) : s === "fixed" ? "fixed128x128" : s.startsWith("ufixed[") ? "ufixed128x128" + s.slice(6) : s === "ufixed" ? "ufixed128x128" : s;
  }
  function t(s) {
    return parseInt(/^\D+(\d+)$/.exec(s)[1], 10);
  }
  function g(s) {
    var f = /^\D+(\d+)x(\d+)$/.exec(s);
    return [parseInt(f[1], 10), parseInt(f[2], 10)];
  }
  function i(s) {
    var f = s.match(/(.*)\[(.*?)\]$/);
    return f ? f[2] === "" ? "dynamic" : parseInt(f[2], 10) : null;
  }
  function c(s) {
    var f = typeof s;
    if (f === "string")
      return e.isHexString(s) ? new r(e.stripHexPrefix(s), 16) : new r(s, 10);
    if (f === "number")
      return new r(s);
    if (s.toArray)
      return s;
    throw new Error("Argument is not a number");
  }
  function a(s, f) {
    var b, y, u, R;
    if (s === "address")
      return a("uint160", c(f));
    if (s === "bool")
      return a("uint8", f ? 1 : 0);
    if (s === "string")
      return a("bytes", new Buffer(f, "utf8"));
    if (m(s)) {
      if (typeof f.length > "u")
        throw new Error("Not an array?");
      if (b = i(s), b !== "dynamic" && b !== 0 && f.length > b)
        throw new Error("Elements exceed array size: " + b);
      u = [], s = s.slice(0, s.lastIndexOf("[")), typeof f == "string" && (f = JSON.parse(f));
      for (R in f)
        u.push(a(s, f[R]));
      if (b === "dynamic") {
        var S = a("uint256", f.length);
        u.unshift(S);
      }
      return Buffer.concat(u);
    } else {
      if (s === "bytes")
        return f = new Buffer(f), u = Buffer.concat([a("uint256", f.length), f]), f.length % 32 !== 0 && (u = Buffer.concat([u, e.zeros(32 - f.length % 32)])), u;
      if (s.startsWith("bytes")) {
        if (b = t(s), b < 1 || b > 32)
          throw new Error("Invalid bytes<N> width: " + b);
        return e.setLengthRight(f, 32);
      } else if (s.startsWith("uint")) {
        if (b = t(s), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid uint<N> width: " + b);
        if (y = c(f), y.bitLength() > b)
          throw new Error("Supplied uint exceeds width: " + b + " vs " + y.bitLength());
        if (y < 0)
          throw new Error("Supplied uint is negative");
        return y.toArrayLike(Buffer, "be", 32);
      } else if (s.startsWith("int")) {
        if (b = t(s), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid int<N> width: " + b);
        if (y = c(f), y.bitLength() > b)
          throw new Error("Supplied int exceeds width: " + b + " vs " + y.bitLength());
        return y.toTwos(256).toArrayLike(Buffer, "be", 32);
      } else if (s.startsWith("ufixed")) {
        if (b = g(s), y = c(f), y < 0)
          throw new Error("Supplied ufixed is negative");
        return a("uint256", y.mul(new r(2).pow(new r(b[1]))));
      } else if (s.startsWith("fixed"))
        return b = g(s), a("int256", c(f).mul(new r(2).pow(new r(b[1]))));
    }
    throw new Error("Unsupported or invalid type: " + s);
  }
  function d(s) {
    return s === "string" || s === "bytes" || i(s) === "dynamic";
  }
  function m(s) {
    return s.lastIndexOf("]") === s.length - 1;
  }
  function p(s, f) {
    var b = [], y = [], u = 32 * s.length;
    for (var R in s) {
      var S = n(s[R]), I = f[R], T = a(S, I);
      d(S) ? (b.push(a("uint256", u)), y.push(T), u += T.length) : b.push(T);
    }
    return Buffer.concat(b.concat(y));
  }
  function o(s, f) {
    if (s.length !== f.length)
      throw new Error("Number of types are not matching the values");
    for (var b, y, u = [], R = 0; R < s.length; R++) {
      var S = n(s[R]), I = f[R];
      if (S === "bytes")
        u.push(I);
      else if (S === "string")
        u.push(new Buffer(I, "utf8"));
      else if (S === "bool")
        u.push(new Buffer(I ? "01" : "00", "hex"));
      else if (S === "address")
        u.push(e.setLength(I, 20));
      else if (S.startsWith("bytes")) {
        if (b = t(S), b < 1 || b > 32)
          throw new Error("Invalid bytes<N> width: " + b);
        u.push(e.setLengthRight(I, b));
      } else if (S.startsWith("uint")) {
        if (b = t(S), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid uint<N> width: " + b);
        if (y = c(I), y.bitLength() > b)
          throw new Error("Supplied uint exceeds width: " + b + " vs " + y.bitLength());
        u.push(y.toArrayLike(Buffer, "be", b / 8));
      } else if (S.startsWith("int")) {
        if (b = t(S), b % 8 || b < 8 || b > 256)
          throw new Error("Invalid int<N> width: " + b);
        if (y = c(I), y.bitLength() > b)
          throw new Error("Supplied int exceeds width: " + b + " vs " + y.bitLength());
        u.push(y.toTwos(b).toArrayLike(Buffer, "be", b / 8));
      } else
        throw new Error("Unsupported or invalid type: " + S);
    }
    return Buffer.concat(u);
  }
  function l(s, f) {
    return e.keccak(o(s, f));
  }
  return hi = {
    rawEncode: p,
    solidityPack: o,
    soliditySHA3: l
  }, hi;
}
var di, ja;
function Oh() {
  if (ja) return di;
  ja = 1;
  const e = /* @__PURE__ */ ll(), r = /* @__PURE__ */ Ph(), n = {
    type: "object",
    properties: {
      types: {
        type: "object",
        additionalProperties: {
          type: "array",
          items: {
            type: "object",
            properties: {
              name: { type: "string" },
              type: { type: "string" }
            },
            required: ["name", "type"]
          }
        }
      },
      primaryType: { type: "string" },
      domain: { type: "object" },
      message: { type: "object" }
    },
    required: ["types", "primaryType", "domain", "message"]
  }, t = {
    /**
     * Encodes an object by encoding and concatenating each of its members
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to encode
     * @param {Object} types - Type definitions
     * @returns {string} - Encoded representation of an object
     */
    encodeData(i, c, a, d = !0) {
      const m = ["bytes32"], p = [this.hashType(i, a)];
      if (d) {
        const o = (l, s, f) => {
          if (a[s] !== void 0)
            return ["bytes32", f == null ? "0x0000000000000000000000000000000000000000000000000000000000000000" : e.keccak(this.encodeData(s, f, a, d))];
          if (f === void 0)
            throw new Error(`missing value for field ${l} of type ${s}`);
          if (s === "bytes")
            return ["bytes32", e.keccak(f)];
          if (s === "string")
            return typeof f == "string" && (f = Buffer.from(f, "utf8")), ["bytes32", e.keccak(f)];
          if (s.lastIndexOf("]") === s.length - 1) {
            const b = s.slice(0, s.lastIndexOf("[")), y = f.map((u) => o(l, b, u));
            return ["bytes32", e.keccak(r.rawEncode(
              y.map(([u]) => u),
              y.map(([, u]) => u)
            ))];
          }
          return [s, f];
        };
        for (const l of a[i]) {
          const [s, f] = o(l.name, l.type, c[l.name]);
          m.push(s), p.push(f);
        }
      } else
        for (const o of a[i]) {
          let l = c[o.name];
          if (l !== void 0)
            if (o.type === "bytes")
              m.push("bytes32"), l = e.keccak(l), p.push(l);
            else if (o.type === "string")
              m.push("bytes32"), typeof l == "string" && (l = Buffer.from(l, "utf8")), l = e.keccak(l), p.push(l);
            else if (a[o.type] !== void 0)
              m.push("bytes32"), l = e.keccak(this.encodeData(o.type, l, a, d)), p.push(l);
            else {
              if (o.type.lastIndexOf("]") === o.type.length - 1)
                throw new Error("Arrays currently unimplemented in encodeData");
              m.push(o.type), p.push(l);
            }
        }
      return r.rawEncode(m, p);
    },
    /**
     * Encodes the type of an object by encoding a comma delimited list of its members
     *
     * @param {string} primaryType - Root type to encode
     * @param {Object} types - Type definitions
     * @returns {string} - Encoded representation of the type of an object
     */
    encodeType(i, c) {
      let a = "", d = this.findTypeDependencies(i, c).filter((m) => m !== i);
      d = [i].concat(d.sort());
      for (const m of d) {
        if (!c[m])
          throw new Error("No type definition specified: " + m);
        a += m + "(" + c[m].map(({ name: o, type: l }) => l + " " + o).join(",") + ")";
      }
      return a;
    },
    /**
     * Finds all types within a type defintion object
     *
     * @param {string} primaryType - Root type
     * @param {Object} types - Type definitions
     * @param {Array} results - current set of accumulated types
     * @returns {Array} - Set of all types found in the type definition
     */
    findTypeDependencies(i, c, a = []) {
      if (i = i.match(/^\w*/)[0], a.includes(i) || c[i] === void 0)
        return a;
      a.push(i);
      for (const d of c[i])
        for (const m of this.findTypeDependencies(d.type, c, a))
          !a.includes(m) && a.push(m);
      return a;
    },
    /**
     * Hashes an object
     *
     * @param {string} primaryType - Root type
     * @param {Object} data - Object to hash
     * @param {Object} types - Type definitions
     * @returns {Buffer} - Hash of an object
     */
    hashStruct(i, c, a, d = !0) {
      return e.keccak(this.encodeData(i, c, a, d));
    },
    /**
     * Hashes the type of an object
     *
     * @param {string} primaryType - Root type to hash
     * @param {Object} types - Type definitions
     * @returns {string} - Hash of an object
     */
    hashType(i, c) {
      return e.keccak(this.encodeType(i, c));
    },
    /**
     * Removes properties from a message object that are not defined per EIP-712
     *
     * @param {Object} data - typed message object
     * @returns {Object} - typed message object with only allowed fields
     */
    sanitizeData(i) {
      const c = {};
      for (const a in n.properties)
        i[a] && (c[a] = i[a]);
      return c.types && (c.types = Object.assign({ EIP712Domain: [] }, c.types)), c;
    },
    /**
     * Returns the hash of a typed message as per EIP-712 for signing
     *
     * @param {Object} typedData - Types message data to sign
     * @returns {string} - sha3 hash for signing
     */
    hash(i, c = !0) {
      const a = this.sanitizeData(i), d = [Buffer.from("1901", "hex")];
      return d.push(this.hashStruct("EIP712Domain", a.domain, a.types, c)), a.primaryType !== "EIP712Domain" && d.push(this.hashStruct(a.primaryType, a.message, a.types, c)), e.keccak(Buffer.concat(d));
    }
  };
  di = {
    TYPED_MESSAGE_SCHEMA: n,
    TypedDataUtils: t,
    hashForSignTypedDataLegacy: function(i) {
      return g(i.data);
    },
    hashForSignTypedData_v3: function(i) {
      return t.hash(i.data, !1);
    },
    hashForSignTypedData_v4: function(i) {
      return t.hash(i.data);
    }
  };
  function g(i) {
    const c = new Error("Expect argument to be non-empty array");
    if (typeof i != "object" || !i.length) throw c;
    const a = i.map(function(p) {
      return p.type === "bytes" ? e.toBuffer(p.value) : p.value;
    }), d = i.map(function(p) {
      return p.type;
    }), m = i.map(function(p) {
      if (!p.name) throw c;
      return p.type + " " + p.name;
    });
    return r.soliditySHA3(
      ["bytes32", "bytes32"],
      [
        r.soliditySHA3(new Array(i.length).fill("string"), m),
        r.soliditySHA3(d, a)
      ]
    );
  }
  return di;
}
var St = {}, $a;
function Fh() {
  if ($a) return St;
  $a = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.filterFromParam = St.FilterPolyfill = void 0;
  const e = /* @__PURE__ */ mn(), r = /* @__PURE__ */ tt(), n = 5 * 60 * 1e3, t = {
    jsonrpc: "2.0",
    id: 0
  };
  let g = class {
    constructor(l) {
      this.logFilters = /* @__PURE__ */ new Map(), this.blockFilters = /* @__PURE__ */ new Set(), this.pendingTransactionFilters = /* @__PURE__ */ new Set(), this.cursors = /* @__PURE__ */ new Map(), this.timeouts = /* @__PURE__ */ new Map(), this.nextFilterId = (0, e.IntNumber)(1), this.REQUEST_THROTTLE_INTERVAL = 1e3, this.lastFetchTimestamp = /* @__PURE__ */ new Date(0), this.resolvers = [], this.provider = l;
    }
    async newFilter(l) {
      const s = i(l), f = this.makeFilterId(), b = await this.setInitialCursorPosition(f, s.fromBlock);
      return console.info(`Installing new log filter(${f}):`, s, "initial cursor position:", b), this.logFilters.set(f, s), this.setFilterTimeout(f), (0, r.hexStringFromIntNumber)(f);
    }
    async newBlockFilter() {
      const l = this.makeFilterId(), s = await this.setInitialCursorPosition(l, "latest");
      return console.info(`Installing new block filter (${l}) with initial cursor position:`, s), this.blockFilters.add(l), this.setFilterTimeout(l), (0, r.hexStringFromIntNumber)(l);
    }
    async newPendingTransactionFilter() {
      const l = this.makeFilterId(), s = await this.setInitialCursorPosition(l, "latest");
      return console.info(`Installing new block filter (${l}) with initial cursor position:`, s), this.pendingTransactionFilters.add(l), this.setFilterTimeout(l), (0, r.hexStringFromIntNumber)(l);
    }
    uninstallFilter(l) {
      const s = (0, r.intNumberFromHexString)(l);
      return console.info(`Uninstalling filter (${s})`), this.deleteFilter(s), !0;
    }
    getFilterChanges(l) {
      const s = (0, r.intNumberFromHexString)(l);
      return this.timeouts.has(s) && this.setFilterTimeout(s), this.logFilters.has(s) ? this.getLogFilterChanges(s) : this.blockFilters.has(s) ? this.getBlockFilterChanges(s) : this.pendingTransactionFilters.has(s) ? this.getPendingTransactionFilterChanges(s) : Promise.resolve(m());
    }
    async getFilterLogs(l) {
      const s = (0, r.intNumberFromHexString)(l), f = this.logFilters.get(s);
      return f ? this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_getLogs", params: [c(f)] })) : m();
    }
    makeFilterId() {
      return (0, e.IntNumber)(++this.nextFilterId);
    }
    sendAsyncPromise(l) {
      return new Promise((s, f) => {
        this.provider.sendAsync(l, (b, y) => {
          if (b)
            return f(b);
          if (Array.isArray(y) || y == null)
            return f(new Error(`unexpected response received: ${JSON.stringify(y)}`));
          s(y);
        });
      });
    }
    deleteFilter(l) {
      console.info(`Deleting filter (${l})`), this.logFilters.delete(l), this.blockFilters.delete(l), this.pendingTransactionFilters.delete(l), this.cursors.delete(l), this.timeouts.delete(l);
    }
    async getLogFilterChanges(l) {
      const s = this.logFilters.get(l), f = this.cursors.get(l);
      if (!f || !s)
        return m();
      const b = await this.getCurrentBlockHeight(), y = s.toBlock === "latest" ? b : s.toBlock;
      if (f > b || f > Number(s.toBlock))
        return p();
      console.info(`Fetching logs from ${f} to ${y} for filter ${l}`);
      const u = await this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_getLogs", params: [
        c(Object.assign(Object.assign({}, s), { fromBlock: f, toBlock: y }))
      ] }));
      if (Array.isArray(u.result)) {
        const R = u.result.map((I) => (0, r.intNumberFromHexString)(I.blockNumber || "0x0")), S = Math.max(...R);
        if (S && S > f) {
          const I = (0, e.IntNumber)(S + 1);
          console.info(`Moving cursor position for filter (${l}) from ${f} to ${I}`), this.cursors.set(l, I);
        }
      }
      return u;
    }
    async getBlockFilterChanges(l) {
      const s = this.cursors.get(l);
      if (!s)
        return m();
      const f = await this.getCurrentBlockHeight();
      if (s > f)
        return p();
      console.info(`Fetching blocks from ${s} to ${f} for filter (${l})`);
      const b = (await Promise.all(
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        (0, r.range)(s, f + 1).map((u) => this.getBlockHashByNumber((0, e.IntNumber)(u)))
      )).filter((u) => !!u), y = (0, e.IntNumber)(s + b.length);
      return console.info(`Moving cursor position for filter (${l}) from ${s} to ${y}`), this.cursors.set(l, y), Object.assign(Object.assign({}, t), { result: b });
    }
    async getPendingTransactionFilterChanges(l) {
      return Promise.resolve(p());
    }
    async setInitialCursorPosition(l, s) {
      const f = await this.getCurrentBlockHeight(), b = typeof s == "number" && s > f ? s : f;
      return this.cursors.set(l, b), b;
    }
    setFilterTimeout(l) {
      const s = this.timeouts.get(l);
      s && window.clearTimeout(s);
      const f = window.setTimeout(() => {
        console.info(`Filter (${l}) timed out`), this.deleteFilter(l);
      }, n);
      this.timeouts.set(l, f);
    }
    // throttle eth_blockNumber requests
    async getCurrentBlockHeight() {
      const l = /* @__PURE__ */ new Date();
      if (l.getTime() - this.lastFetchTimestamp.getTime() > this.REQUEST_THROTTLE_INTERVAL) {
        this.lastFetchTimestamp = l;
        const s = await this._getCurrentBlockHeight();
        this.currentBlockHeight = s, this.resolvers.forEach((f) => f(s)), this.resolvers = [];
      }
      return this.currentBlockHeight ? this.currentBlockHeight : new Promise((s) => this.resolvers.push(s));
    }
    async _getCurrentBlockHeight() {
      const { result: l } = await this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_blockNumber", params: [] }));
      return (0, r.intNumberFromHexString)((0, r.ensureHexString)(l));
    }
    async getBlockHashByNumber(l) {
      const s = await this.sendAsyncPromise(Object.assign(Object.assign({}, t), { method: "eth_getBlockByNumber", params: [(0, r.hexStringFromIntNumber)(l), !1] }));
      return s.result && typeof s.result.hash == "string" ? (0, r.ensureHexString)(s.result.hash) : null;
    }
  };
  St.FilterPolyfill = g;
  function i(o) {
    return {
      fromBlock: a(o.fromBlock),
      toBlock: a(o.toBlock),
      addresses: o.address === void 0 ? null : Array.isArray(o.address) ? o.address : [o.address],
      topics: o.topics || []
    };
  }
  St.filterFromParam = i;
  function c(o) {
    const l = {
      fromBlock: d(o.fromBlock),
      toBlock: d(o.toBlock),
      topics: o.topics
    };
    return o.addresses !== null && (l.address = o.addresses), l;
  }
  function a(o) {
    if (o === void 0 || o === "latest" || o === "pending")
      return "latest";
    if (o === "earliest")
      return (0, e.IntNumber)(0);
    if ((0, r.isHexString)(o))
      return (0, r.intNumberFromHexString)(o);
    throw new Error(`Invalid block option: ${String(o)}`);
  }
  function d(o) {
    return o === "latest" ? o : (0, r.hexStringFromIntNumber)(o);
  }
  function m() {
    return Object.assign(Object.assign({}, t), { error: { code: -32e3, message: "filter not found" } });
  }
  function p() {
    return Object.assign(Object.assign({}, t), { result: [] });
  }
  return St;
}
var kr = {}, Ir = {}, Vt = {}, fi, Ua;
function Hs() {
  if (Ua) return fi;
  Ua = 1, fi = e;
  function e(r) {
    r = r || {};
    var n = r.max || Number.MAX_SAFE_INTEGER, t = typeof r.start < "u" ? r.start : Math.floor(Math.random() * n);
    return function() {
      return t = t % n, t++;
    };
  }
  return fi;
}
var pi, Ha;
function Dh() {
  if (Ha) return pi;
  Ha = 1;
  const e = (r, n) => function() {
    const t = n.promiseModule, g = new Array(arguments.length);
    for (let i = 0; i < arguments.length; i++)
      g[i] = arguments[i];
    return new t((i, c) => {
      n.errorFirst ? g.push(function(a, d) {
        if (n.multiArgs) {
          const m = new Array(arguments.length - 1);
          for (let p = 1; p < arguments.length; p++)
            m[p - 1] = arguments[p];
          a ? (m.unshift(a), c(m)) : i(m);
        } else a ? c(a) : i(d);
      }) : g.push(function(a) {
        if (n.multiArgs) {
          const d = new Array(arguments.length - 1);
          for (let m = 0; m < arguments.length; m++)
            d[m] = arguments[m];
          i(d);
        } else
          i(a);
      }), r.apply(this, g);
    });
  };
  return pi = (r, n) => {
    n = Object.assign({
      exclude: [/.+(Sync|Stream)$/],
      errorFirst: !0,
      promiseModule: Promise
    }, n);
    const t = (i) => {
      const c = (a) => typeof a == "string" ? i === a : a.test(i);
      return n.include ? n.include.some(c) : !n.exclude.some(c);
    };
    let g;
    typeof r == "function" ? g = function() {
      return n.excludeMain ? r.apply(this, arguments) : e(r, n).apply(this, arguments);
    } : g = Object.create(Object.getPrototypeOf(r));
    for (const i in r) {
      const c = r[i];
      g[i] = typeof c == "function" && t(i) ? e(c, n) : c;
    }
    return g;
  }, pi;
}
var zt = {}, sn = {}, Wa;
function Ws() {
  if (Wa) return sn;
  Wa = 1, Object.defineProperty(sn, "__esModule", { value: !0 });
  const e = dn();
  function r(g, i, c) {
    try {
      Reflect.apply(g, i, c);
    } catch (a) {
      setTimeout(() => {
        throw a;
      });
    }
  }
  function n(g) {
    const i = g.length, c = new Array(i);
    for (let a = 0; a < i; a += 1)
      c[a] = g[a];
    return c;
  }
  class t extends e.EventEmitter {
    emit(i, ...c) {
      let a = i === "error";
      const d = this._events;
      if (d !== void 0)
        a = a && d.error === void 0;
      else if (!a)
        return !1;
      if (a) {
        let p;
        if (c.length > 0 && ([p] = c), p instanceof Error)
          throw p;
        const o = new Error(`Unhandled error.${p ? ` (${p.message})` : ""}`);
        throw o.context = p, o;
      }
      const m = d[i];
      if (m === void 0)
        return !1;
      if (typeof m == "function")
        r(m, this, c);
      else {
        const p = m.length, o = n(m);
        for (let l = 0; l < p; l += 1)
          r(o[l], this, c);
      }
      return !0;
    }
  }
  return sn.default = t, sn;
}
var Va;
function hl() {
  if (Va) return zt;
  Va = 1;
  var e = zt.__importDefault || function(a) {
    return a && a.__esModule ? a : { default: a };
  };
  Object.defineProperty(zt, "__esModule", { value: !0 }), zt.BaseBlockTracker = void 0;
  const r = e(Ws()), n = 1e3, t = (a, d) => a + d, g = ["sync", "latest"];
  let i = class extends r.default {
    constructor(d) {
      super(), this._blockResetDuration = d.blockResetDuration || 20 * n, this._usePastBlocks = d.usePastBlocks || !1, this._currentBlock = null, this._isRunning = !1, this._onNewListener = this._onNewListener.bind(this), this._onRemoveListener = this._onRemoveListener.bind(this), this._resetCurrentBlock = this._resetCurrentBlock.bind(this), this._setupInternalEvents();
    }
    async destroy() {
      this._cancelBlockResetTimeout(), await this._maybeEnd(), super.removeAllListeners();
    }
    isRunning() {
      return this._isRunning;
    }
    getCurrentBlock() {
      return this._currentBlock;
    }
    async getLatestBlock() {
      return this._currentBlock ? this._currentBlock : await new Promise((m) => this.once("latest", m));
    }
    // dont allow module consumer to remove our internal event listeners
    removeAllListeners(d) {
      return d ? super.removeAllListeners(d) : super.removeAllListeners(), this._setupInternalEvents(), this._onRemoveListener(), this;
    }
    _setupInternalEvents() {
      this.removeListener("newListener", this._onNewListener), this.removeListener("removeListener", this._onRemoveListener), this.on("newListener", this._onNewListener), this.on("removeListener", this._onRemoveListener);
    }
    _onNewListener(d) {
      g.includes(d) && this._maybeStart();
    }
    _onRemoveListener() {
      this._getBlockTrackerEventCount() > 0 || this._maybeEnd();
    }
    async _maybeStart() {
      this._isRunning || (this._isRunning = !0, this._cancelBlockResetTimeout(), await this._start(), this.emit("_started"));
    }
    async _maybeEnd() {
      this._isRunning && (this._isRunning = !1, this._setupBlockResetTimeout(), await this._end(), this.emit("_ended"));
    }
    _getBlockTrackerEventCount() {
      return g.map((d) => this.listenerCount(d)).reduce(t);
    }
    _shouldUseNewBlock(d) {
      const m = this._currentBlock;
      if (!m)
        return !0;
      const p = c(d), o = c(m);
      return this._usePastBlocks && p < o || p > o;
    }
    _newPotentialLatest(d) {
      this._shouldUseNewBlock(d) && this._setCurrentBlock(d);
    }
    _setCurrentBlock(d) {
      const m = this._currentBlock;
      this._currentBlock = d, this.emit("latest", d), this.emit("sync", { oldBlock: m, newBlock: d });
    }
    _setupBlockResetTimeout() {
      this._cancelBlockResetTimeout(), this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration), this._blockResetTimeout.unref && this._blockResetTimeout.unref();
    }
    _cancelBlockResetTimeout() {
      this._blockResetTimeout && clearTimeout(this._blockResetTimeout);
    }
    _resetCurrentBlock() {
      this._currentBlock = null;
    }
  };
  zt.BaseBlockTracker = i;
  function c(a) {
    return Number.parseInt(a, 16);
  }
  return zt;
}
var gi = {}, xr = {}, Ge = {};
class dl extends TypeError {
  constructor(r, n) {
    let t;
    const { message: g, explanation: i, ...c } = r, { path: a } = r, d = a.length === 0 ? g : `At path: ${a.join(".")} -- ${g}`;
    super(i ?? d), i != null && (this.cause = d), Object.assign(this, c), this.name = this.constructor.name, this.failures = () => t ?? (t = [r, ...n()]);
  }
}
function qh(e) {
  return ze(e) && typeof e[Symbol.iterator] == "function";
}
function ze(e) {
  return typeof e == "object" && e != null;
}
function za(e) {
  if (Object.prototype.toString.call(e) !== "[object Object]")
    return !1;
  const r = Object.getPrototypeOf(e);
  return r === null || r === Object.prototype;
}
function qe(e) {
  return typeof e == "symbol" ? e.toString() : typeof e == "string" ? JSON.stringify(e) : `${e}`;
}
function jh(e) {
  const { done: r, value: n } = e.next();
  return r ? void 0 : n;
}
function $h(e, r, n, t) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = { message: e });
  const { path: g, branch: i } = r, { type: c } = n, { refinement: a, message: d = `Expected a value of type \`${c}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${qe(t)}\`` } = e;
  return {
    value: t,
    type: c,
    refinement: a,
    key: g[g.length - 1],
    path: g,
    branch: i,
    ...e,
    message: d
  };
}
function* Bs(e, r, n, t) {
  qh(e) || (e = [e]);
  for (const g of e) {
    const i = $h(g, r, n, t);
    i && (yield i);
  }
}
function* Vs(e, r, n = {}) {
  const { path: t = [], branch: g = [e], coerce: i = !1, mask: c = !1 } = n, a = { path: t, branch: g };
  if (i && (e = r.coercer(e, a), c && r.type !== "type" && ze(r.schema) && ze(e) && !Array.isArray(e)))
    for (const m in e)
      r.schema[m] === void 0 && delete e[m];
  let d = "valid";
  for (const m of r.validator(e, a))
    m.explanation = n.message, d = "not_valid", yield [m, void 0];
  for (let [m, p, o] of r.entries(e, a)) {
    const l = Vs(p, o, {
      path: m === void 0 ? t : [...t, m],
      branch: m === void 0 ? g : [...g, p],
      coerce: i,
      mask: c,
      message: n.message
    });
    for (const s of l)
      s[0] ? (d = s[0].refinement != null ? "not_refined" : "not_valid", yield [s[0], void 0]) : i && (p = s[1], m === void 0 ? e = p : e instanceof Map ? e.set(m, p) : e instanceof Set ? e.add(p) : ze(e) && (p !== void 0 || m in e) && (e[m] = p));
  }
  if (d !== "not_valid")
    for (const m of r.refiner(e, a))
      m.explanation = n.message, d = "not_refined", yield [m, void 0];
  d === "valid" && (yield [void 0, e]);
}
class De {
  constructor(r) {
    const { type: n, schema: t, validator: g, refiner: i, coercer: c = (d) => d, entries: a = function* () {
    } } = r;
    this.type = n, this.schema = t, this.entries = a, this.coercer = c, g ? this.validator = (d, m) => {
      const p = g(d, m);
      return Bs(p, m, this, d);
    } : this.validator = () => [], i ? this.refiner = (d, m) => {
      const p = i(d, m);
      return Bs(p, m, this, d);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(r, n) {
    return fl(r, this, n);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(r, n) {
    return pl(r, this, n);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(r) {
    return zs(r, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(r, n) {
    return gl(r, this, n);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(r, n = {}) {
    return Xt(r, this, n);
  }
}
function fl(e, r, n) {
  const t = Xt(e, r, { message: n });
  if (t[0])
    throw t[0];
}
function pl(e, r, n) {
  const t = Xt(e, r, { coerce: !0, message: n });
  if (t[0])
    throw t[0];
  return t[1];
}
function gl(e, r, n) {
  const t = Xt(e, r, { coerce: !0, mask: !0, message: n });
  if (t[0])
    throw t[0];
  return t[1];
}
function zs(e, r) {
  return !Xt(e, r)[0];
}
function Xt(e, r, n = {}) {
  const t = Vs(e, r, n), g = jh(t);
  return g[0] ? [new dl(g[0], function* () {
    for (const c of t)
      c[0] && (yield c[0]);
  }), void 0] : [void 0, g[1]];
}
function Uh(...e) {
  const r = e[0].type === "type", n = e.map((g) => g.schema), t = Object.assign({}, ...n);
  return r ? Wr(t) : Hr(t);
}
function Ve(e, r) {
  return new De({ type: e, schema: null, validator: r });
}
function Hh(e, r) {
  return new De({
    ...e,
    refiner: (n, t) => n === void 0 || e.refiner(n, t),
    validator(n, t) {
      return n === void 0 ? !0 : (r(n, t), e.validator(n, t));
    }
  });
}
function Wh(e) {
  return new De({
    type: "dynamic",
    schema: null,
    *entries(r, n) {
      yield* e(r, n).entries(r, n);
    },
    validator(r, n) {
      return e(r, n).validator(r, n);
    },
    coercer(r, n) {
      return e(r, n).coercer(r, n);
    },
    refiner(r, n) {
      return e(r, n).refiner(r, n);
    }
  });
}
function Vh(e) {
  let r;
  return new De({
    type: "lazy",
    schema: null,
    *entries(n, t) {
      r ?? (r = e()), yield* r.entries(n, t);
    },
    validator(n, t) {
      return r ?? (r = e()), r.validator(n, t);
    },
    coercer(n, t) {
      return r ?? (r = e()), r.coercer(n, t);
    },
    refiner(n, t) {
      return r ?? (r = e()), r.refiner(n, t);
    }
  });
}
function zh(e, r) {
  const { schema: n } = e, t = { ...n };
  for (const g of r)
    delete t[g];
  switch (e.type) {
    case "type":
      return Wr(t);
    default:
      return Hr(t);
  }
}
function Jh(e) {
  const r = e instanceof De, n = r ? { ...e.schema } : { ...e };
  for (const t in n)
    n[t] = ml(n[t]);
  return r && e.type === "type" ? Wr(n) : Hr(n);
}
function Gh(e, r) {
  const { schema: n } = e, t = {};
  for (const g of r)
    t[g] = n[g];
  switch (e.type) {
    case "type":
      return Wr(t);
    default:
      return Hr(t);
  }
}
function Zh(e, r) {
  return console.warn("superstruct@0.11 - The `struct` helper has been renamed to `define`."), Ve(e, r);
}
function Kh() {
  return Ve("any", () => !0);
}
function Qh(e) {
  return new De({
    type: "array",
    schema: e,
    *entries(r) {
      if (e && Array.isArray(r))
        for (const [n, t] of r.entries())
          yield [n, t, e];
    },
    coercer(r) {
      return Array.isArray(r) ? r.slice() : r;
    },
    validator(r) {
      return Array.isArray(r) || `Expected an array value, but received: ${qe(r)}`;
    }
  });
}
function Yh() {
  return Ve("bigint", (e) => typeof e == "bigint");
}
function Xh() {
  return Ve("boolean", (e) => typeof e == "boolean");
}
function ed() {
  return Ve("date", (e) => e instanceof Date && !isNaN(e.getTime()) || `Expected a valid \`Date\` object, but received: ${qe(e)}`);
}
function td(e) {
  const r = {}, n = e.map((t) => qe(t)).join();
  for (const t of e)
    r[t] = t;
  return new De({
    type: "enums",
    schema: r,
    validator(t) {
      return e.includes(t) || `Expected one of \`${n}\`, but received: ${qe(t)}`;
    }
  });
}
function rd() {
  return Ve("func", (e) => typeof e == "function" || `Expected a function, but received: ${qe(e)}`);
}
function nd(e) {
  return Ve("instance", (r) => r instanceof e || `Expected a \`${e.name}\` instance, but received: ${qe(r)}`);
}
function id() {
  return Ve("integer", (e) => typeof e == "number" && !isNaN(e) && Number.isInteger(e) || `Expected an integer, but received: ${qe(e)}`);
}
function sd(e) {
  return new De({
    type: "intersection",
    schema: null,
    *entries(r, n) {
      for (const t of e)
        yield* t.entries(r, n);
    },
    *validator(r, n) {
      for (const t of e)
        yield* t.validator(r, n);
    },
    *refiner(r, n) {
      for (const t of e)
        yield* t.refiner(r, n);
    }
  });
}
function od(e) {
  const r = qe(e), n = typeof e;
  return new De({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(t) {
      return t === e || `Expected the literal \`${r}\`, but received: ${qe(t)}`;
    }
  });
}
function ad(e, r) {
  return new De({
    type: "map",
    schema: null,
    *entries(n) {
      if (e && r && n instanceof Map)
        for (const [t, g] of n.entries())
          yield [t, t, e], yield [t, g, r];
    },
    coercer(n) {
      return n instanceof Map ? new Map(n) : n;
    },
    validator(n) {
      return n instanceof Map || `Expected a \`Map\` object, but received: ${qe(n)}`;
    }
  });
}
function Js() {
  return Ve("never", () => !1);
}
function ud(e) {
  return new De({
    ...e,
    validator: (r, n) => r === null || e.validator(r, n),
    refiner: (r, n) => r === null || e.refiner(r, n)
  });
}
function cd() {
  return Ve("number", (e) => typeof e == "number" && !isNaN(e) || `Expected a number, but received: ${qe(e)}`);
}
function Hr(e) {
  const r = e ? Object.keys(e) : [], n = Js();
  return new De({
    type: "object",
    schema: e || null,
    *entries(t) {
      if (e && ze(t)) {
        const g = new Set(Object.keys(t));
        for (const i of r)
          g.delete(i), yield [i, t[i], e[i]];
        for (const i of g)
          yield [i, t[i], n];
      }
    },
    validator(t) {
      return ze(t) || `Expected an object, but received: ${qe(t)}`;
    },
    coercer(t) {
      return ze(t) ? { ...t } : t;
    }
  });
}
function ml(e) {
  return new De({
    ...e,
    validator: (r, n) => r === void 0 || e.validator(r, n),
    refiner: (r, n) => r === void 0 || e.refiner(r, n)
  });
}
function ld(e, r) {
  return new De({
    type: "record",
    schema: null,
    *entries(n) {
      if (ze(n))
        for (const t in n) {
          const g = n[t];
          yield [t, t, e], yield [t, g, r];
        }
    },
    validator(n) {
      return ze(n) || `Expected an object, but received: ${qe(n)}`;
    }
  });
}
function hd() {
  return Ve("regexp", (e) => e instanceof RegExp);
}
function dd(e) {
  return new De({
    type: "set",
    schema: null,
    *entries(r) {
      if (e && r instanceof Set)
        for (const n of r)
          yield [n, n, e];
    },
    coercer(r) {
      return r instanceof Set ? new Set(r) : r;
    },
    validator(r) {
      return r instanceof Set || `Expected a \`Set\` object, but received: ${qe(r)}`;
    }
  });
}
function wl() {
  return Ve("string", (e) => typeof e == "string" || `Expected a string, but received: ${qe(e)}`);
}
function fd(e) {
  const r = Js();
  return new De({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const t = Math.max(e.length, n.length);
        for (let g = 0; g < t; g++)
          yield [g, n[g], e[g] || r];
      }
    },
    validator(n) {
      return Array.isArray(n) || `Expected an array, but received: ${qe(n)}`;
    }
  });
}
function Wr(e) {
  const r = Object.keys(e);
  return new De({
    type: "type",
    schema: e,
    *entries(n) {
      if (ze(n))
        for (const t of r)
          yield [t, n[t], e[t]];
    },
    validator(n) {
      return ze(n) || `Expected an object, but received: ${qe(n)}`;
    },
    coercer(n) {
      return ze(n) ? { ...n } : n;
    }
  });
}
function pd(e) {
  const r = e.map((n) => n.type).join(" | ");
  return new De({
    type: "union",
    schema: null,
    coercer(n) {
      for (const t of e) {
        const [g, i] = t.validate(n, { coerce: !0 });
        if (!g)
          return i;
      }
      return n;
    },
    validator(n, t) {
      const g = [];
      for (const i of e) {
        const [...c] = Vs(n, i, t), [a] = c;
        if (a[0])
          for (const [d] of c)
            d && g.push(d);
        else
          return [];
      }
      return [
        `Expected the value to satisfy a union of \`${r}\`, but received: ${qe(n)}`,
        ...g
      ];
    }
  });
}
function yl() {
  return Ve("unknown", () => !0);
}
function Gs(e, r, n) {
  return new De({
    ...e,
    coercer: (t, g) => zs(t, r) ? e.coercer(n(t, g), g) : e.coercer(t, g)
  });
}
function gd(e, r, n = {}) {
  return Gs(e, yl(), (t) => {
    const g = typeof r == "function" ? r() : r;
    if (t === void 0)
      return g;
    if (!n.strict && za(t) && za(g)) {
      const i = { ...t };
      let c = !1;
      for (const a in g)
        i[a] === void 0 && (i[a] = g[a], c = !0);
      if (c)
        return i;
    }
    return t;
  });
}
function md(e) {
  return Gs(e, wl(), (r) => r.trim());
}
function wd(e) {
  return It(e, "empty", (r) => {
    const n = bl(r);
    return n === 0 || `Expected an empty ${e.type} but received one with a size of \`${n}\``;
  });
}
function bl(e) {
  return e instanceof Map || e instanceof Set ? e.size : e.length;
}
function yd(e, r, n = {}) {
  const { exclusive: t } = n;
  return It(e, "max", (g) => t ? g < r : g <= r || `Expected a ${e.type} less than ${t ? "" : "or equal to "}${r} but received \`${g}\``);
}
function bd(e, r, n = {}) {
  const { exclusive: t } = n;
  return It(e, "min", (g) => t ? g > r : g >= r || `Expected a ${e.type} greater than ${t ? "" : "or equal to "}${r} but received \`${g}\``);
}
function vd(e) {
  return It(e, "nonempty", (r) => bl(r) > 0 || `Expected a nonempty ${e.type} but received an empty one`);
}
function _d(e, r) {
  return It(e, "pattern", (n) => r.test(n) || `Expected a ${e.type} matching \`/${r.source}/\` but received "${n}"`);
}
function Ed(e, r, n = r) {
  const t = `Expected a ${e.type}`, g = r === n ? `of \`${r}\`` : `between \`${r}\` and \`${n}\``;
  return It(e, "size", (i) => {
    if (typeof i == "number" || i instanceof Date)
      return r <= i && i <= n || `${t} ${g} but received \`${i}\``;
    if (i instanceof Map || i instanceof Set) {
      const { size: c } = i;
      return r <= c && c <= n || `${t} with a size ${g} but received one with a size of \`${c}\``;
    } else {
      const { length: c } = i;
      return r <= c && c <= n || `${t} with a length ${g} but received one with a length of \`${c}\``;
    }
  });
}
function It(e, r, n) {
  return new De({
    ...e,
    *refiner(t, g) {
      yield* e.refiner(t, g);
      const i = n(t, g), c = Bs(i, g, e, t);
      for (const a of c)
        yield { ...a, refinement: r };
    }
  });
}
const Rd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Struct: De,
  StructError: dl,
  any: Kh,
  array: Qh,
  assert: fl,
  assign: Uh,
  bigint: Yh,
  boolean: Xh,
  coerce: Gs,
  create: pl,
  date: ed,
  defaulted: gd,
  define: Ve,
  deprecated: Hh,
  dynamic: Wh,
  empty: wd,
  enums: td,
  func: rd,
  instance: nd,
  integer: id,
  intersection: sd,
  is: zs,
  lazy: Vh,
  literal: od,
  map: ad,
  mask: gl,
  max: yd,
  min: bd,
  never: Js,
  nonempty: vd,
  nullable: ud,
  number: cd,
  object: Hr,
  omit: zh,
  optional: ml,
  partial: Jh,
  pattern: _d,
  pick: Gh,
  record: ld,
  refine: It,
  regexp: hd,
  set: dd,
  size: Ed,
  string: wl,
  struct: Zh,
  trimmed: md,
  tuple: fd,
  type: Wr,
  union: pd,
  unknown: yl,
  validate: Xt
}, Symbol.toStringTag, { value: "Module" })), xt = /* @__PURE__ */ $r(Rd);
var Ja;
function ot() {
  if (Ja) return Ge;
  Ja = 1, Object.defineProperty(Ge, "__esModule", { value: !0 }), Ge.assertExhaustive = Ge.assertStruct = Ge.assert = Ge.AssertionError = void 0;
  const e = xt;
  function r(m) {
    return typeof m == "object" && m !== null && "message" in m;
  }
  function n(m) {
    var p, o;
    return typeof ((o = (p = m == null ? void 0 : m.prototype) === null || p === void 0 ? void 0 : p.constructor) === null || o === void 0 ? void 0 : o.name) == "string";
  }
  function t(m) {
    const p = r(m) ? m.message : String(m);
    return p.endsWith(".") ? p.slice(0, -1) : p;
  }
  function g(m, p) {
    return n(m) ? new m({
      message: p
    }) : m({
      message: p
    });
  }
  class i extends Error {
    constructor(p) {
      super(p.message), this.code = "ERR_ASSERTION";
    }
  }
  Ge.AssertionError = i;
  function c(m, p = "Assertion failed.", o = i) {
    if (!m)
      throw p instanceof Error ? p : g(o, p);
  }
  Ge.assert = c;
  function a(m, p, o = "Assertion failed", l = i) {
    try {
      (0, e.assert)(m, p);
    } catch (s) {
      throw g(l, `${o}: ${t(s)}.`);
    }
  }
  Ge.assertStruct = a;
  function d(m) {
    throw new Error("Invalid branch reached. Should be detected during compilation.");
  }
  return Ge.assertExhaustive = d, Ge;
}
var Ar = {}, Ga;
function vl() {
  if (Ga) return Ar;
  Ga = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.base64 = void 0;
  const e = xt, r = ot(), n = (t, g = {}) => {
    var i, c;
    const a = (i = g.paddingRequired) !== null && i !== void 0 ? i : !1, d = (c = g.characterSet) !== null && c !== void 0 ? c : "base64";
    let m;
    d === "base64" ? m = String.raw`[A-Za-z0-9+\/]` : ((0, r.assert)(d === "base64url"), m = String.raw`[-_A-Za-z0-9]`);
    let p;
    return a ? p = new RegExp(`^(?:${m}{4})*(?:${m}{3}=|${m}{2}==)?$`, "u") : p = new RegExp(`^(?:${m}{4})*(?:${m}{2,3}|${m}{3}=|${m}{2}==)?$`, "u"), (0, e.pattern)(t, p);
  };
  return Ar.base64 = n, Ar;
}
var ge = {}, mi = {}, Za;
function bn() {
  return Za || (Za = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.remove0x = e.add0x = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.StrictHexStruct = e.HexStruct = void 0;
    const r = xt, n = ot();
    e.HexStruct = (0, r.pattern)((0, r.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, r.pattern)((0, r.string)(), /^0x[0-9a-f]+$/iu);
    function t(m) {
      return (0, r.is)(m, e.HexStruct);
    }
    e.isHexString = t;
    function g(m) {
      return (0, r.is)(m, e.StrictHexStruct);
    }
    e.isStrictHexString = g;
    function i(m) {
      (0, n.assert)(t(m), "Value must be a hexadecimal string.");
    }
    e.assertIsHexString = i;
    function c(m) {
      (0, n.assert)(g(m), 'Value must be a hexadecimal string, starting with "0x".');
    }
    e.assertIsStrictHexString = c;
    function a(m) {
      return m.startsWith("0x") ? m : m.startsWith("0X") ? `0x${m.substring(2)}` : `0x${m}`;
    }
    e.add0x = a;
    function d(m) {
      return m.startsWith("0x") || m.startsWith("0X") ? m.substring(2) : m;
    }
    e.remove0x = d;
  }(mi)), mi;
}
var Ka;
function _l() {
  if (Ka) return ge;
  Ka = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.createDataView = ge.concatBytes = ge.valueToBytes = ge.stringToBytes = ge.numberToBytes = ge.signedBigIntToBytes = ge.bigIntToBytes = ge.hexToBytes = ge.bytesToString = ge.bytesToNumber = ge.bytesToSignedBigInt = ge.bytesToBigInt = ge.bytesToHex = ge.assertIsBytes = ge.isBytes = void 0;
  const e = ot(), r = bn(), n = 48, t = 58, g = 87;
  function i() {
    const D = [];
    return () => {
      if (D.length === 0)
        for (let H = 0; H < 256; H++)
          D.push(H.toString(16).padStart(2, "0"));
      return D;
    };
  }
  const c = i();
  function a(D) {
    return D instanceof Uint8Array;
  }
  ge.isBytes = a;
  function d(D) {
    (0, e.assert)(a(D), "Value must be a Uint8Array.");
  }
  ge.assertIsBytes = d;
  function m(D) {
    if (d(D), D.length === 0)
      return "0x";
    const H = c(), G = new Array(D.length);
    for (let X = 0; X < D.length; X++)
      G[X] = H[D[X]];
    return (0, r.add0x)(G.join(""));
  }
  ge.bytesToHex = m;
  function p(D) {
    d(D);
    const H = m(D);
    return BigInt(H);
  }
  ge.bytesToBigInt = p;
  function o(D) {
    d(D);
    let H = BigInt(0);
    for (const G of D)
      H = (H << BigInt(8)) + BigInt(G);
    return BigInt.asIntN(D.length * 8, H);
  }
  ge.bytesToSignedBigInt = o;
  function l(D) {
    d(D);
    const H = p(D);
    return (0, e.assert)(H <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), Number(H);
  }
  ge.bytesToNumber = l;
  function s(D) {
    return d(D), new TextDecoder().decode(D);
  }
  ge.bytesToString = s;
  function f(D) {
    var H;
    if (((H = D == null ? void 0 : D.toLowerCase) === null || H === void 0 ? void 0 : H.call(D)) === "0x")
      return new Uint8Array();
    (0, r.assertIsHexString)(D);
    const G = (0, r.remove0x)(D).toLowerCase(), X = G.length % 2 === 0 ? G : `0${G}`, Y = new Uint8Array(X.length / 2);
    for (let re = 0; re < Y.length; re++) {
      const F = X.charCodeAt(re * 2), h = X.charCodeAt(re * 2 + 1), E = F - (F < t ? n : g), C = h - (h < t ? n : g);
      Y[re] = E * 16 + C;
    }
    return Y;
  }
  ge.hexToBytes = f;
  function b(D) {
    (0, e.assert)(typeof D == "bigint", "Value must be a bigint."), (0, e.assert)(D >= BigInt(0), "Value must be a non-negative bigint.");
    const H = D.toString(16);
    return f(H);
  }
  ge.bigIntToBytes = b;
  function y(D, H) {
    (0, e.assert)(H > 0);
    const G = D >> BigInt(31);
    return !((~D & G) + (D & ~G) >> BigInt(H * 8 + -1));
  }
  function u(D, H) {
    (0, e.assert)(typeof D == "bigint", "Value must be a bigint."), (0, e.assert)(typeof H == "number", "Byte length must be a number."), (0, e.assert)(H > 0, "Byte length must be greater than 0."), (0, e.assert)(y(D, H), "Byte length is too small to represent the given value.");
    let G = D;
    const X = new Uint8Array(H);
    for (let Y = 0; Y < X.length; Y++)
      X[Y] = Number(BigInt.asUintN(8, G)), G >>= BigInt(8);
    return X.reverse();
  }
  ge.signedBigIntToBytes = u;
  function R(D) {
    (0, e.assert)(typeof D == "number", "Value must be a number."), (0, e.assert)(D >= 0, "Value must be a non-negative number."), (0, e.assert)(Number.isSafeInteger(D), "Value is not a safe integer. Use `bigIntToBytes` instead.");
    const H = D.toString(16);
    return f(H);
  }
  ge.numberToBytes = R;
  function S(D) {
    return (0, e.assert)(typeof D == "string", "Value must be a string."), new TextEncoder().encode(D);
  }
  ge.stringToBytes = S;
  function I(D) {
    if (typeof D == "bigint")
      return b(D);
    if (typeof D == "number")
      return R(D);
    if (typeof D == "string")
      return D.startsWith("0x") ? f(D) : S(D);
    if (a(D))
      return D;
    throw new TypeError(`Unsupported value type: "${typeof D}".`);
  }
  ge.valueToBytes = I;
  function T(D) {
    const H = new Array(D.length);
    let G = 0;
    for (let Y = 0; Y < D.length; Y++) {
      const re = I(D[Y]);
      H[Y] = re, G += re.length;
    }
    const X = new Uint8Array(G);
    for (let Y = 0, re = 0; Y < H.length; Y++)
      X.set(H[Y], re), re += H[Y].length;
    return X;
  }
  ge.concatBytes = T;
  function q(D) {
    if (typeof Buffer < "u" && D instanceof Buffer) {
      const H = D.buffer.slice(D.byteOffset, D.byteOffset + D.byteLength);
      return new DataView(H);
    }
    return new DataView(D.buffer, D.byteOffset, D.byteLength);
  }
  return ge.createDataView = q, ge;
}
var Tr = {}, Qa;
function Sd() {
  if (Qa) return Tr;
  Qa = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.ChecksumStruct = void 0;
  const e = xt, r = vl();
  return Tr.ChecksumStruct = (0, e.size)((0, r.base64)((0, e.string)(), { paddingRequired: !0 }), 44, 44), Tr;
}
var Ze = {}, Ya;
function Cd() {
  if (Ya) return Ze;
  Ya = 1, Object.defineProperty(Ze, "__esModule", { value: !0 }), Ze.createHex = Ze.createBytes = Ze.createBigInt = Ze.createNumber = void 0;
  const e = xt, r = ot(), n = _l(), t = bn(), g = (0, e.union)([(0, e.number)(), (0, e.bigint)(), (0, e.string)(), t.StrictHexStruct]), i = (0, e.coerce)((0, e.number)(), g, Number), c = (0, e.coerce)((0, e.bigint)(), g, BigInt);
  (0, e.union)([t.StrictHexStruct, (0, e.instance)(Uint8Array)]);
  const a = (0, e.coerce)((0, e.instance)(Uint8Array), (0, e.union)([t.StrictHexStruct]), n.hexToBytes), d = (0, e.coerce)(t.StrictHexStruct, (0, e.instance)(Uint8Array), n.bytesToHex);
  function m(s) {
    try {
      const f = (0, e.create)(s, i);
      return (0, r.assert)(Number.isFinite(f), `Expected a number-like value, got "${s}".`), f;
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a number-like value, got "${s}".`) : f;
    }
  }
  Ze.createNumber = m;
  function p(s) {
    try {
      return (0, e.create)(s, c);
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a number-like value, got "${String(f.value)}".`) : f;
    }
  }
  Ze.createBigInt = p;
  function o(s) {
    if (typeof s == "string" && s.toLowerCase() === "0x")
      return new Uint8Array();
    try {
      return (0, e.create)(s, a);
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a bytes-like value, got "${String(f.value)}".`) : f;
    }
  }
  Ze.createBytes = o;
  function l(s) {
    if (s instanceof Uint8Array && s.length === 0 || typeof s == "string" && s.toLowerCase() === "0x")
      return "0x";
    try {
      return (0, e.create)(s, d);
    } catch (f) {
      throw f instanceof e.StructError ? new Error(`Expected a bytes-like value, got "${String(f.value)}".`) : f;
    }
  }
  return Ze.createHex = l, Ze;
}
var et = {}, Xa;
function Md() {
  if (Xa) return et;
  Xa = 1;
  var e = et.__classPrivateFieldSet || function(c, a, d, m, p) {
    if (m === "m") throw new TypeError("Private method is not writable");
    if (m === "a" && !p) throw new TypeError("Private accessor was defined without a setter");
    if (typeof a == "function" ? c !== a || !p : !a.has(c)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return m === "a" ? p.call(c, d) : p ? p.value = d : a.set(c, d), d;
  }, r = et.__classPrivateFieldGet || function(c, a, d, m) {
    if (d === "a" && !m) throw new TypeError("Private accessor was defined without a getter");
    if (typeof a == "function" ? c !== a || !m : !a.has(c)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return d === "m" ? m : d === "a" ? m.call(c) : m ? m.value : a.get(c);
  }, n, t;
  Object.defineProperty(et, "__esModule", { value: !0 }), et.FrozenSet = et.FrozenMap = void 0;
  class g {
    constructor(a) {
      n.set(this, void 0), e(this, n, new Map(a), "f"), Object.freeze(this);
    }
    get size() {
      return r(this, n, "f").size;
    }
    [(n = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      return r(this, n, "f")[Symbol.iterator]();
    }
    entries() {
      return r(this, n, "f").entries();
    }
    forEach(a, d) {
      return r(this, n, "f").forEach((m, p, o) => a.call(d, m, p, this));
    }
    get(a) {
      return r(this, n, "f").get(a);
    }
    has(a) {
      return r(this, n, "f").has(a);
    }
    keys() {
      return r(this, n, "f").keys();
    }
    values() {
      return r(this, n, "f").values();
    }
    toString() {
      return `FrozenMap(${this.size}) {${this.size > 0 ? ` ${[...this.entries()].map(([a, d]) => `${String(a)} => ${String(d)}`).join(", ")} ` : ""}}`;
    }
  }
  et.FrozenMap = g;
  class i {
    constructor(a) {
      t.set(this, void 0), e(this, t, new Set(a), "f"), Object.freeze(this);
    }
    get size() {
      return r(this, t, "f").size;
    }
    [(t = /* @__PURE__ */ new WeakMap(), Symbol.iterator)]() {
      return r(this, t, "f")[Symbol.iterator]();
    }
    entries() {
      return r(this, t, "f").entries();
    }
    forEach(a, d) {
      return r(this, t, "f").forEach((m, p, o) => a.call(d, m, p, this));
    }
    has(a) {
      return r(this, t, "f").has(a);
    }
    keys() {
      return r(this, t, "f").keys();
    }
    values() {
      return r(this, t, "f").values();
    }
    toString() {
      return `FrozenSet(${this.size}) {${this.size > 0 ? ` ${[...this.values()].map((a) => String(a)).join(", ")} ` : ""}}`;
    }
  }
  return et.FrozenSet = i, Object.freeze(g), Object.freeze(g.prototype), Object.freeze(i), Object.freeze(i.prototype), et;
}
var wi = {}, eu;
function kd() {
  return eu || (eu = 1, Object.defineProperty(wi, "__esModule", { value: !0 })), wi;
}
var yi = {}, tu;
function Id() {
  return tu || (tu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.getJsonSize = e.isValidJson = e.JsonStruct = e.UnsafeJsonStruct = void 0;
    const r = xt, n = ot(), t = () => (0, r.define)("finite number", (T) => (0, r.is)(T, (0, r.number)()) && Number.isFinite(T));
    e.UnsafeJsonStruct = (0, r.union)([
      (0, r.literal)(null),
      (0, r.boolean)(),
      t(),
      (0, r.string)(),
      (0, r.array)((0, r.lazy)(() => e.UnsafeJsonStruct)),
      (0, r.record)((0, r.string)(), (0, r.lazy)(() => e.UnsafeJsonStruct))
    ]), e.JsonStruct = (0, r.define)("Json", (T, q) => {
      function D(H, G) {
        const Y = [...G.validator(H, q)];
        return Y.length > 0 ? Y : !0;
      }
      try {
        const H = D(T, e.UnsafeJsonStruct);
        return H !== !0 ? H : D(JSON.parse(JSON.stringify(T)), e.UnsafeJsonStruct);
      } catch (H) {
        return H instanceof RangeError ? "Circular reference detected" : !1;
      }
    });
    function g(T) {
      return (0, r.is)(T, e.JsonStruct);
    }
    e.isValidJson = g;
    function i(T) {
      (0, n.assertStruct)(T, e.JsonStruct, "Invalid JSON value");
      const q = JSON.stringify(T);
      return new TextEncoder().encode(q).byteLength;
    }
    e.getJsonSize = i, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, r.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, r.nullable)((0, r.union)([(0, r.number)(), (0, r.string)()])), e.JsonRpcErrorStruct = (0, r.object)({
      code: (0, r.integer)(),
      message: (0, r.string)(),
      data: (0, r.optional)(e.JsonStruct),
      stack: (0, r.optional)((0, r.string)())
    }), e.JsonRpcParamsStruct = (0, r.optional)((0, r.union)([(0, r.record)((0, r.string)(), e.JsonStruct), (0, r.array)(e.JsonStruct)])), e.JsonRpcRequestStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      method: (0, r.string)(),
      params: e.JsonRpcParamsStruct
    }), e.JsonRpcNotificationStruct = (0, r.omit)(e.JsonRpcRequestStruct, ["id"]);
    function c(T) {
      return (0, r.is)(T, e.JsonRpcNotificationStruct);
    }
    e.isJsonRpcNotification = c;
    function a(T, q) {
      (0, n.assertStruct)(T, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", q);
    }
    e.assertIsJsonRpcNotification = a;
    function d(T) {
      return (0, r.is)(T, e.JsonRpcRequestStruct);
    }
    e.isJsonRpcRequest = d;
    function m(T, q) {
      (0, n.assertStruct)(T, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", q);
    }
    e.assertIsJsonRpcRequest = m, e.PendingJsonRpcResponseStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      result: (0, r.optional)((0, r.unknown)()),
      error: (0, r.optional)(e.JsonRpcErrorStruct)
    }), e.JsonRpcSuccessStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      result: e.JsonStruct
    }), e.JsonRpcFailureStruct = (0, r.object)({
      id: e.JsonRpcIdStruct,
      jsonrpc: e.JsonRpcVersionStruct,
      error: e.JsonRpcErrorStruct
    }), e.JsonRpcResponseStruct = (0, r.union)([
      e.JsonRpcSuccessStruct,
      e.JsonRpcFailureStruct
    ]);
    function p(T) {
      return (0, r.is)(T, e.PendingJsonRpcResponseStruct);
    }
    e.isPendingJsonRpcResponse = p;
    function o(T, q) {
      (0, n.assertStruct)(T, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", q);
    }
    e.assertIsPendingJsonRpcResponse = o;
    function l(T) {
      return (0, r.is)(T, e.JsonRpcResponseStruct);
    }
    e.isJsonRpcResponse = l;
    function s(T, q) {
      (0, n.assertStruct)(T, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", q);
    }
    e.assertIsJsonRpcResponse = s;
    function f(T) {
      return (0, r.is)(T, e.JsonRpcSuccessStruct);
    }
    e.isJsonRpcSuccess = f;
    function b(T, q) {
      (0, n.assertStruct)(T, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", q);
    }
    e.assertIsJsonRpcSuccess = b;
    function y(T) {
      return (0, r.is)(T, e.JsonRpcFailureStruct);
    }
    e.isJsonRpcFailure = y;
    function u(T, q) {
      (0, n.assertStruct)(T, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", q);
    }
    e.assertIsJsonRpcFailure = u;
    function R(T) {
      return (0, r.is)(T, e.JsonRpcErrorStruct);
    }
    e.isJsonRpcError = R;
    function S(T, q) {
      (0, n.assertStruct)(T, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", q);
    }
    e.assertIsJsonRpcError = S;
    function I(T) {
      const { permitEmptyString: q, permitFractions: D, permitNull: H } = Object.assign({ permitEmptyString: !0, permitFractions: !1, permitNull: !0 }, T);
      return (X) => !!(typeof X == "number" && (D || Number.isInteger(X)) || typeof X == "string" && (q || X.length > 0) || H && X === null);
    }
    e.getJsonRpcIdValidator = I;
  }(yi)), yi;
}
var bi = {}, ru;
function xd() {
  return ru || (ru = 1, Object.defineProperty(bi, "__esModule", { value: !0 })), bi;
}
var nt = {}, on = { exports: {} }, vi, nu;
function Ad() {
  if (nu) return vi;
  nu = 1;
  var e = 1e3, r = e * 60, n = r * 60, t = n * 24, g = t * 7, i = t * 365.25;
  vi = function(p, o) {
    o = o || {};
    var l = typeof p;
    if (l === "string" && p.length > 0)
      return c(p);
    if (l === "number" && isFinite(p))
      return o.long ? d(p) : a(p);
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(p)
    );
  };
  function c(p) {
    if (p = String(p), !(p.length > 100)) {
      var o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        p
      );
      if (o) {
        var l = parseFloat(o[1]), s = (o[2] || "ms").toLowerCase();
        switch (s) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return l * i;
          case "weeks":
          case "week":
          case "w":
            return l * g;
          case "days":
          case "day":
          case "d":
            return l * t;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return l * n;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return l * r;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return l * e;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return l;
          default:
            return;
        }
      }
    }
  }
  function a(p) {
    var o = Math.abs(p);
    return o >= t ? Math.round(p / t) + "d" : o >= n ? Math.round(p / n) + "h" : o >= r ? Math.round(p / r) + "m" : o >= e ? Math.round(p / e) + "s" : p + "ms";
  }
  function d(p) {
    var o = Math.abs(p);
    return o >= t ? m(p, o, t, "day") : o >= n ? m(p, o, n, "hour") : o >= r ? m(p, o, r, "minute") : o >= e ? m(p, o, e, "second") : p + " ms";
  }
  function m(p, o, l, s) {
    var f = o >= l * 1.5;
    return Math.round(p / l) + " " + s + (f ? "s" : "");
  }
  return vi;
}
var _i, iu;
function Td() {
  if (iu) return _i;
  iu = 1;
  function e(r) {
    t.debug = t, t.default = t, t.coerce = m, t.disable = a, t.enable = i, t.enabled = d, t.humanize = Ad(), t.destroy = p, Object.keys(r).forEach((o) => {
      t[o] = r[o];
    }), t.names = [], t.skips = [], t.formatters = {};
    function n(o) {
      let l = 0;
      for (let s = 0; s < o.length; s++)
        l = (l << 5) - l + o.charCodeAt(s), l |= 0;
      return t.colors[Math.abs(l) % t.colors.length];
    }
    t.selectColor = n;
    function t(o) {
      let l, s = null, f, b;
      function y(...u) {
        if (!y.enabled)
          return;
        const R = y, S = Number(/* @__PURE__ */ new Date()), I = S - (l || S);
        R.diff = I, R.prev = l, R.curr = S, l = S, u[0] = t.coerce(u[0]), typeof u[0] != "string" && u.unshift("%O");
        let T = 0;
        u[0] = u[0].replace(/%([a-zA-Z%])/g, (D, H) => {
          if (D === "%%")
            return "%";
          T++;
          const G = t.formatters[H];
          if (typeof G == "function") {
            const X = u[T];
            D = G.call(R, X), u.splice(T, 1), T--;
          }
          return D;
        }), t.formatArgs.call(R, u), (R.log || t.log).apply(R, u);
      }
      return y.namespace = o, y.useColors = t.useColors(), y.color = t.selectColor(o), y.extend = g, y.destroy = t.destroy, Object.defineProperty(y, "enabled", {
        enumerable: !0,
        configurable: !1,
        get: () => s !== null ? s : (f !== t.namespaces && (f = t.namespaces, b = t.enabled(o)), b),
        set: (u) => {
          s = u;
        }
      }), typeof t.init == "function" && t.init(y), y;
    }
    function g(o, l) {
      const s = t(this.namespace + (typeof l > "u" ? ":" : l) + o);
      return s.log = this.log, s;
    }
    function i(o) {
      t.save(o), t.namespaces = o, t.names = [], t.skips = [];
      const l = (typeof o == "string" ? o : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const s of l)
        s[0] === "-" ? t.skips.push(s.slice(1)) : t.names.push(s);
    }
    function c(o, l) {
      let s = 0, f = 0, b = -1, y = 0;
      for (; s < o.length; )
        if (f < l.length && (l[f] === o[s] || l[f] === "*"))
          l[f] === "*" ? (b = f, y = s, f++) : (s++, f++);
        else if (b !== -1)
          f = b + 1, y++, s = y;
        else
          return !1;
      for (; f < l.length && l[f] === "*"; )
        f++;
      return f === l.length;
    }
    function a() {
      const o = [
        ...t.names,
        ...t.skips.map((l) => "-" + l)
      ].join(",");
      return t.enable(""), o;
    }
    function d(o) {
      for (const l of t.skips)
        if (c(o, l))
          return !1;
      for (const l of t.names)
        if (c(o, l))
          return !0;
      return !1;
    }
    function m(o) {
      return o instanceof Error ? o.stack || o.message : o;
    }
    function p() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return t.enable(t.load()), t;
  }
  return _i = e, _i;
}
var su;
function Ld() {
  return su || (su = 1, function(e, r) {
    r.formatArgs = t, r.save = g, r.load = i, r.useColors = n, r.storage = c(), r.destroy = /* @__PURE__ */ (() => {
      let d = !1;
      return () => {
        d || (d = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })(), r.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function n() {
      if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs))
        return !0;
      if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))
        return !1;
      let d;
      return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator < "u" && navigator.userAgent && (d = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(d[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function t(d) {
      if (d[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + d[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors)
        return;
      const m = "color: " + this.color;
      d.splice(1, 0, m, "color: inherit");
      let p = 0, o = 0;
      d[0].replace(/%[a-zA-Z%]/g, (l) => {
        l !== "%%" && (p++, l === "%c" && (o = p));
      }), d.splice(o, 0, m);
    }
    r.log = console.debug || console.log || (() => {
    });
    function g(d) {
      try {
        d ? r.storage.setItem("debug", d) : r.storage.removeItem("debug");
      } catch {
      }
    }
    function i() {
      let d;
      try {
        d = r.storage.getItem("debug");
      } catch {
      }
      return !d && typeof process < "u" && "env" in process && (d = process.env.DEBUG), d;
    }
    function c() {
      try {
        return localStorage;
      } catch {
      }
    }
    e.exports = Td()(r);
    const { formatters: a } = e.exports;
    a.j = function(d) {
      try {
        return JSON.stringify(d);
      } catch (m) {
        return "[UnexpectedJSONParseError]: " + m.message;
      }
    };
  }(on, on.exports)), on.exports;
}
var ou;
function Bd() {
  if (ou) return nt;
  ou = 1;
  var e = nt.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(nt, "__esModule", { value: !0 }), nt.createModuleLogger = nt.createProjectLogger = void 0;
  const n = (0, e(Ld()).default)("metamask");
  function t(i) {
    return n.extend(i);
  }
  nt.createProjectLogger = t;
  function g(i, c) {
    return i.extend(c);
  }
  return nt.createModuleLogger = g, nt;
}
var Ei = {}, au;
function Nd() {
  return au || (au = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0;
    function r(m) {
      return Array.isArray(m) && m.length > 0;
    }
    e.isNonEmptyArray = r;
    function n(m) {
      return m == null;
    }
    e.isNullOrUndefined = n;
    function t(m) {
      return !!m && typeof m == "object" && !Array.isArray(m);
    }
    e.isObject = t;
    const g = (m, p) => Object.hasOwnProperty.call(m, p);
    e.hasProperty = g, function(m) {
      m[m.Null = 4] = "Null", m[m.Comma = 1] = "Comma", m[m.Wrapper = 1] = "Wrapper", m[m.True = 4] = "True", m[m.False = 5] = "False", m[m.Quote = 1] = "Quote", m[m.Colon = 1] = "Colon", m[m.Date = 24] = "Date";
    }(e.JsonSize || (e.JsonSize = {})), e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu;
    function i(m) {
      if (typeof m != "object" || m === null)
        return !1;
      try {
        let p = m;
        for (; Object.getPrototypeOf(p) !== null; )
          p = Object.getPrototypeOf(p);
        return Object.getPrototypeOf(m) === p;
      } catch {
        return !1;
      }
    }
    e.isPlainObject = i;
    function c(m) {
      return m.charCodeAt(0) <= 127;
    }
    e.isASCII = c;
    function a(m) {
      var p;
      return m.split("").reduce((l, s) => c(s) ? l + 1 : l + 2, 0) + ((p = m.match(e.ESCAPE_CHARACTERS_REGEXP)) !== null && p !== void 0 ? p : []).length;
    }
    e.calculateStringSize = a;
    function d(m) {
      return m.toString().length;
    }
    e.calculateNumberSize = d;
  }(Ei)), Ei;
}
var Ke = {}, uu;
function Pd() {
  if (uu) return Ke;
  uu = 1, Object.defineProperty(Ke, "__esModule", { value: !0 }), Ke.hexToBigInt = Ke.hexToNumber = Ke.bigIntToHex = Ke.numberToHex = void 0;
  const e = ot(), r = bn(), n = (c) => ((0, e.assert)(typeof c == "number", "Value must be a number."), (0, e.assert)(c >= 0, "Value must be a non-negative number."), (0, e.assert)(Number.isSafeInteger(c), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, r.add0x)(c.toString(16)));
  Ke.numberToHex = n;
  const t = (c) => ((0, e.assert)(typeof c == "bigint", "Value must be a bigint."), (0, e.assert)(c >= 0, "Value must be a non-negative bigint."), (0, r.add0x)(c.toString(16)));
  Ke.bigIntToHex = t;
  const g = (c) => {
    (0, r.assertIsHexString)(c);
    const a = parseInt(c, 16);
    return (0, e.assert)(Number.isSafeInteger(a), "Value is not a safe integer. Use `hexToBigInt` instead."), a;
  };
  Ke.hexToNumber = g;
  const i = (c) => ((0, r.assertIsHexString)(c), BigInt((0, r.add0x)(c)));
  return Ke.hexToBigInt = i, Ke;
}
var Ri = {}, cu;
function Od() {
  return cu || (cu = 1, Object.defineProperty(Ri, "__esModule", { value: !0 })), Ri;
}
var Si = {}, lu;
function Fd() {
  return lu || (lu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.timeSince = e.inMilliseconds = e.Duration = void 0, function(i) {
      i[i.Millisecond = 1] = "Millisecond", i[i.Second = 1e3] = "Second", i[i.Minute = 6e4] = "Minute", i[i.Hour = 36e5] = "Hour", i[i.Day = 864e5] = "Day", i[i.Week = 6048e5] = "Week", i[i.Year = 31536e6] = "Year";
    }(e.Duration || (e.Duration = {}));
    const r = (i) => Number.isInteger(i) && i >= 0, n = (i, c) => {
      if (!r(i))
        throw new Error(`"${c}" must be a non-negative integer. Received: "${i}".`);
    };
    function t(i, c) {
      return n(i, "count"), i * c;
    }
    e.inMilliseconds = t;
    function g(i) {
      return n(i, "timestamp"), Date.now() - i;
    }
    e.timeSince = g;
  }(Si)), Si;
}
var Ci = {}, hu;
function Dd() {
  return hu || (hu = 1, Object.defineProperty(Ci, "__esModule", { value: !0 })), Ci;
}
var Mi = {}, an = { exports: {} }, ki, du;
function vn() {
  if (du) return ki;
  du = 1;
  const e = "2.0.0", r = 256, n = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
  9007199254740991, t = 16, g = r - 6;
  return ki = {
    MAX_LENGTH: r,
    MAX_SAFE_COMPONENT_LENGTH: t,
    MAX_SAFE_BUILD_LENGTH: g,
    MAX_SAFE_INTEGER: n,
    RELEASE_TYPES: [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ],
    SEMVER_SPEC_VERSION: e,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  }, ki;
}
var Ii, fu;
function _n() {
  return fu || (fu = 1, Ii = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...r) => console.error("SEMVER", ...r) : () => {
  }), Ii;
}
var pu;
function Vr() {
  return pu || (pu = 1, function(e, r) {
    const {
      MAX_SAFE_COMPONENT_LENGTH: n,
      MAX_SAFE_BUILD_LENGTH: t,
      MAX_LENGTH: g
    } = vn(), i = _n();
    r = e.exports = {};
    const c = r.re = [], a = r.safeRe = [], d = r.src = [], m = r.safeSrc = [], p = r.t = {};
    let o = 0;
    const l = "[a-zA-Z0-9-]", s = [
      ["\\s", 1],
      ["\\d", g],
      [l, t]
    ], f = (y) => {
      for (const [u, R] of s)
        y = y.split(`${u}*`).join(`${u}{0,${R}}`).split(`${u}+`).join(`${u}{1,${R}}`);
      return y;
    }, b = (y, u, R) => {
      const S = f(u), I = o++;
      i(y, I, u), p[y] = I, d[I] = u, m[I] = S, c[I] = new RegExp(u, R ? "g" : void 0), a[I] = new RegExp(S, R ? "g" : void 0);
    };
    b("NUMERICIDENTIFIER", "0|[1-9]\\d*"), b("NUMERICIDENTIFIERLOOSE", "\\d+"), b("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${l}*`), b("MAINVERSION", `(${d[p.NUMERICIDENTIFIER]})\\.(${d[p.NUMERICIDENTIFIER]})\\.(${d[p.NUMERICIDENTIFIER]})`), b("MAINVERSIONLOOSE", `(${d[p.NUMERICIDENTIFIERLOOSE]})\\.(${d[p.NUMERICIDENTIFIERLOOSE]})\\.(${d[p.NUMERICIDENTIFIERLOOSE]})`), b("PRERELEASEIDENTIFIER", `(?:${d[p.NUMERICIDENTIFIER]}|${d[p.NONNUMERICIDENTIFIER]})`), b("PRERELEASEIDENTIFIERLOOSE", `(?:${d[p.NUMERICIDENTIFIERLOOSE]}|${d[p.NONNUMERICIDENTIFIER]})`), b("PRERELEASE", `(?:-(${d[p.PRERELEASEIDENTIFIER]}(?:\\.${d[p.PRERELEASEIDENTIFIER]})*))`), b("PRERELEASELOOSE", `(?:-?(${d[p.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${d[p.PRERELEASEIDENTIFIERLOOSE]})*))`), b("BUILDIDENTIFIER", `${l}+`), b("BUILD", `(?:\\+(${d[p.BUILDIDENTIFIER]}(?:\\.${d[p.BUILDIDENTIFIER]})*))`), b("FULLPLAIN", `v?${d[p.MAINVERSION]}${d[p.PRERELEASE]}?${d[p.BUILD]}?`), b("FULL", `^${d[p.FULLPLAIN]}$`), b("LOOSEPLAIN", `[v=\\s]*${d[p.MAINVERSIONLOOSE]}${d[p.PRERELEASELOOSE]}?${d[p.BUILD]}?`), b("LOOSE", `^${d[p.LOOSEPLAIN]}$`), b("GTLT", "((?:<|>)?=?)"), b("XRANGEIDENTIFIERLOOSE", `${d[p.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), b("XRANGEIDENTIFIER", `${d[p.NUMERICIDENTIFIER]}|x|X|\\*`), b("XRANGEPLAIN", `[v=\\s]*(${d[p.XRANGEIDENTIFIER]})(?:\\.(${d[p.XRANGEIDENTIFIER]})(?:\\.(${d[p.XRANGEIDENTIFIER]})(?:${d[p.PRERELEASE]})?${d[p.BUILD]}?)?)?`), b("XRANGEPLAINLOOSE", `[v=\\s]*(${d[p.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[p.XRANGEIDENTIFIERLOOSE]})(?:\\.(${d[p.XRANGEIDENTIFIERLOOSE]})(?:${d[p.PRERELEASELOOSE]})?${d[p.BUILD]}?)?)?`), b("XRANGE", `^${d[p.GTLT]}\\s*${d[p.XRANGEPLAIN]}$`), b("XRANGELOOSE", `^${d[p.GTLT]}\\s*${d[p.XRANGEPLAINLOOSE]}$`), b("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), b("COERCE", `${d[p.COERCEPLAIN]}(?:$|[^\\d])`), b("COERCEFULL", d[p.COERCEPLAIN] + `(?:${d[p.PRERELEASE]})?(?:${d[p.BUILD]})?(?:$|[^\\d])`), b("COERCERTL", d[p.COERCE], !0), b("COERCERTLFULL", d[p.COERCEFULL], !0), b("LONETILDE", "(?:~>?)"), b("TILDETRIM", `(\\s*)${d[p.LONETILDE]}\\s+`, !0), r.tildeTrimReplace = "$1~", b("TILDE", `^${d[p.LONETILDE]}${d[p.XRANGEPLAIN]}$`), b("TILDELOOSE", `^${d[p.LONETILDE]}${d[p.XRANGEPLAINLOOSE]}$`), b("LONECARET", "(?:\\^)"), b("CARETTRIM", `(\\s*)${d[p.LONECARET]}\\s+`, !0), r.caretTrimReplace = "$1^", b("CARET", `^${d[p.LONECARET]}${d[p.XRANGEPLAIN]}$`), b("CARETLOOSE", `^${d[p.LONECARET]}${d[p.XRANGEPLAINLOOSE]}$`), b("COMPARATORLOOSE", `^${d[p.GTLT]}\\s*(${d[p.LOOSEPLAIN]})$|^$`), b("COMPARATOR", `^${d[p.GTLT]}\\s*(${d[p.FULLPLAIN]})$|^$`), b("COMPARATORTRIM", `(\\s*)${d[p.GTLT]}\\s*(${d[p.LOOSEPLAIN]}|${d[p.XRANGEPLAIN]})`, !0), r.comparatorTrimReplace = "$1$2$3", b("HYPHENRANGE", `^\\s*(${d[p.XRANGEPLAIN]})\\s+-\\s+(${d[p.XRANGEPLAIN]})\\s*$`), b("HYPHENRANGELOOSE", `^\\s*(${d[p.XRANGEPLAINLOOSE]})\\s+-\\s+(${d[p.XRANGEPLAINLOOSE]})\\s*$`), b("STAR", "(<|>)?=?\\s*\\*"), b("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), b("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }(an, an.exports)), an.exports;
}
var xi, gu;
function Zs() {
  if (gu) return xi;
  gu = 1;
  const e = Object.freeze({ loose: !0 }), r = Object.freeze({});
  return xi = (t) => t ? typeof t != "object" ? e : t : r, xi;
}
var Ai, mu;
function El() {
  if (mu) return Ai;
  mu = 1;
  const e = /^[0-9]+$/, r = (t, g) => {
    const i = e.test(t), c = e.test(g);
    return i && c && (t = +t, g = +g), t === g ? 0 : i && !c ? -1 : c && !i ? 1 : t < g ? -1 : 1;
  };
  return Ai = {
    compareIdentifiers: r,
    rcompareIdentifiers: (t, g) => r(g, t)
  }, Ai;
}
var Ti, wu;
function Ue() {
  if (wu) return Ti;
  wu = 1;
  const e = _n(), { MAX_LENGTH: r, MAX_SAFE_INTEGER: n } = vn(), { safeRe: t, safeSrc: g, t: i } = Vr(), c = Zs(), { compareIdentifiers: a } = El();
  class d {
    constructor(p, o) {
      if (o = c(o), p instanceof d) {
        if (p.loose === !!o.loose && p.includePrerelease === !!o.includePrerelease)
          return p;
        p = p.version;
      } else if (typeof p != "string")
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof p}".`);
      if (p.length > r)
        throw new TypeError(
          `version is longer than ${r} characters`
        );
      e("SemVer", p, o), this.options = o, this.loose = !!o.loose, this.includePrerelease = !!o.includePrerelease;
      const l = p.trim().match(o.loose ? t[i.LOOSE] : t[i.FULL]);
      if (!l)
        throw new TypeError(`Invalid Version: ${p}`);
      if (this.raw = p, this.major = +l[1], this.minor = +l[2], this.patch = +l[3], this.major > n || this.major < 0)
        throw new TypeError("Invalid major version");
      if (this.minor > n || this.minor < 0)
        throw new TypeError("Invalid minor version");
      if (this.patch > n || this.patch < 0)
        throw new TypeError("Invalid patch version");
      l[4] ? this.prerelease = l[4].split(".").map((s) => {
        if (/^[0-9]+$/.test(s)) {
          const f = +s;
          if (f >= 0 && f < n)
            return f;
        }
        return s;
      }) : this.prerelease = [], this.build = l[5] ? l[5].split(".") : [], this.format();
    }
    format() {
      return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
    }
    toString() {
      return this.version;
    }
    compare(p) {
      if (e("SemVer.compare", this.version, this.options, p), !(p instanceof d)) {
        if (typeof p == "string" && p === this.version)
          return 0;
        p = new d(p, this.options);
      }
      return p.version === this.version ? 0 : this.compareMain(p) || this.comparePre(p);
    }
    compareMain(p) {
      return p instanceof d || (p = new d(p, this.options)), a(this.major, p.major) || a(this.minor, p.minor) || a(this.patch, p.patch);
    }
    comparePre(p) {
      if (p instanceof d || (p = new d(p, this.options)), this.prerelease.length && !p.prerelease.length)
        return -1;
      if (!this.prerelease.length && p.prerelease.length)
        return 1;
      if (!this.prerelease.length && !p.prerelease.length)
        return 0;
      let o = 0;
      do {
        const l = this.prerelease[o], s = p.prerelease[o];
        if (e("prerelease compare", o, l, s), l === void 0 && s === void 0)
          return 0;
        if (s === void 0)
          return 1;
        if (l === void 0)
          return -1;
        if (l === s)
          continue;
        return a(l, s);
      } while (++o);
    }
    compareBuild(p) {
      p instanceof d || (p = new d(p, this.options));
      let o = 0;
      do {
        const l = this.build[o], s = p.build[o];
        if (e("build compare", o, l, s), l === void 0 && s === void 0)
          return 0;
        if (s === void 0)
          return 1;
        if (l === void 0)
          return -1;
        if (l === s)
          continue;
        return a(l, s);
      } while (++o);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(p, o, l) {
      if (p.startsWith("pre")) {
        if (!o && l === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (o) {
          const s = new RegExp(`^${this.options.loose ? g[i.PRERELEASELOOSE] : g[i.PRERELEASE]}$`), f = `-${o}`.match(s);
          if (!f || f[1] !== o)
            throw new Error(`invalid identifier: ${o}`);
        }
      }
      switch (p) {
        case "premajor":
          this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", o, l);
          break;
        case "preminor":
          this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", o, l);
          break;
        case "prepatch":
          this.prerelease.length = 0, this.inc("patch", o, l), this.inc("pre", o, l);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          this.prerelease.length === 0 && this.inc("patch", o, l), this.inc("pre", o, l);
          break;
        case "release":
          if (this.prerelease.length === 0)
            throw new Error(`version ${this.raw} is not a prerelease`);
          this.prerelease.length = 0;
          break;
        case "major":
          (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
          break;
        case "minor":
          (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
          break;
        case "patch":
          this.prerelease.length === 0 && this.patch++, this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
        case "pre": {
          const s = Number(l) ? 1 : 0;
          if (this.prerelease.length === 0)
            this.prerelease = [s];
          else {
            let f = this.prerelease.length;
            for (; --f >= 0; )
              typeof this.prerelease[f] == "number" && (this.prerelease[f]++, f = -2);
            if (f === -1) {
              if (o === this.prerelease.join(".") && l === !1)
                throw new Error("invalid increment argument: identifier already exists");
              this.prerelease.push(s);
            }
          }
          if (o) {
            let f = [o, s];
            l === !1 && (f = [o]), a(this.prerelease[0], o) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = f) : this.prerelease = f;
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${p}`);
      }
      return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
    }
  }
  return Ti = d, Ti;
}
var Li, yu;
function er() {
  if (yu) return Li;
  yu = 1;
  const e = Ue();
  return Li = (n, t, g = !1) => {
    if (n instanceof e)
      return n;
    try {
      return new e(n, t);
    } catch (i) {
      if (!g)
        return null;
      throw i;
    }
  }, Li;
}
var Bi, bu;
function qd() {
  if (bu) return Bi;
  bu = 1;
  const e = er();
  return Bi = (n, t) => {
    const g = e(n, t);
    return g ? g.version : null;
  }, Bi;
}
var Ni, vu;
function jd() {
  if (vu) return Ni;
  vu = 1;
  const e = er();
  return Ni = (n, t) => {
    const g = e(n.trim().replace(/^[=v]+/, ""), t);
    return g ? g.version : null;
  }, Ni;
}
var Pi, _u;
function $d() {
  if (_u) return Pi;
  _u = 1;
  const e = Ue();
  return Pi = (n, t, g, i, c) => {
    typeof g == "string" && (c = i, i = g, g = void 0);
    try {
      return new e(
        n instanceof e ? n.version : n,
        g
      ).inc(t, i, c).version;
    } catch {
      return null;
    }
  }, Pi;
}
var Oi, Eu;
function Ud() {
  if (Eu) return Oi;
  Eu = 1;
  const e = er();
  return Oi = (n, t) => {
    const g = e(n, null, !0), i = e(t, null, !0), c = g.compare(i);
    if (c === 0)
      return null;
    const a = c > 0, d = a ? g : i, m = a ? i : g, p = !!d.prerelease.length;
    if (!!m.prerelease.length && !p) {
      if (!m.patch && !m.minor)
        return "major";
      if (m.compareMain(d) === 0)
        return m.minor && !m.patch ? "minor" : "patch";
    }
    const l = p ? "pre" : "";
    return g.major !== i.major ? l + "major" : g.minor !== i.minor ? l + "minor" : g.patch !== i.patch ? l + "patch" : "prerelease";
  }, Oi;
}
var Fi, Ru;
function Hd() {
  if (Ru) return Fi;
  Ru = 1;
  const e = Ue();
  return Fi = (n, t) => new e(n, t).major, Fi;
}
var Di, Su;
function Wd() {
  if (Su) return Di;
  Su = 1;
  const e = Ue();
  return Di = (n, t) => new e(n, t).minor, Di;
}
var qi, Cu;
function Vd() {
  if (Cu) return qi;
  Cu = 1;
  const e = Ue();
  return qi = (n, t) => new e(n, t).patch, qi;
}
var ji, Mu;
function zd() {
  if (Mu) return ji;
  Mu = 1;
  const e = er();
  return ji = (n, t) => {
    const g = e(n, t);
    return g && g.prerelease.length ? g.prerelease : null;
  }, ji;
}
var $i, ku;
function Ye() {
  if (ku) return $i;
  ku = 1;
  const e = Ue();
  return $i = (n, t, g) => new e(n, g).compare(new e(t, g)), $i;
}
var Ui, Iu;
function Jd() {
  if (Iu) return Ui;
  Iu = 1;
  const e = Ye();
  return Ui = (n, t, g) => e(t, n, g), Ui;
}
var Hi, xu;
function Gd() {
  if (xu) return Hi;
  xu = 1;
  const e = Ye();
  return Hi = (n, t) => e(n, t, !0), Hi;
}
var Wi, Au;
function Ks() {
  if (Au) return Wi;
  Au = 1;
  const e = Ue();
  return Wi = (n, t, g) => {
    const i = new e(n, g), c = new e(t, g);
    return i.compare(c) || i.compareBuild(c);
  }, Wi;
}
var Vi, Tu;
function Zd() {
  if (Tu) return Vi;
  Tu = 1;
  const e = Ks();
  return Vi = (n, t) => n.sort((g, i) => e(g, i, t)), Vi;
}
var zi, Lu;
function Kd() {
  if (Lu) return zi;
  Lu = 1;
  const e = Ks();
  return zi = (n, t) => n.sort((g, i) => e(i, g, t)), zi;
}
var Ji, Bu;
function En() {
  if (Bu) return Ji;
  Bu = 1;
  const e = Ye();
  return Ji = (n, t, g) => e(n, t, g) > 0, Ji;
}
var Gi, Nu;
function Qs() {
  if (Nu) return Gi;
  Nu = 1;
  const e = Ye();
  return Gi = (n, t, g) => e(n, t, g) < 0, Gi;
}
var Zi, Pu;
function Rl() {
  if (Pu) return Zi;
  Pu = 1;
  const e = Ye();
  return Zi = (n, t, g) => e(n, t, g) === 0, Zi;
}
var Ki, Ou;
function Sl() {
  if (Ou) return Ki;
  Ou = 1;
  const e = Ye();
  return Ki = (n, t, g) => e(n, t, g) !== 0, Ki;
}
var Qi, Fu;
function Ys() {
  if (Fu) return Qi;
  Fu = 1;
  const e = Ye();
  return Qi = (n, t, g) => e(n, t, g) >= 0, Qi;
}
var Yi, Du;
function Xs() {
  if (Du) return Yi;
  Du = 1;
  const e = Ye();
  return Yi = (n, t, g) => e(n, t, g) <= 0, Yi;
}
var Xi, qu;
function Cl() {
  if (qu) return Xi;
  qu = 1;
  const e = Rl(), r = Sl(), n = En(), t = Ys(), g = Qs(), i = Xs();
  return Xi = (a, d, m, p) => {
    switch (d) {
      case "===":
        return typeof a == "object" && (a = a.version), typeof m == "object" && (m = m.version), a === m;
      case "!==":
        return typeof a == "object" && (a = a.version), typeof m == "object" && (m = m.version), a !== m;
      case "":
      case "=":
      case "==":
        return e(a, m, p);
      case "!=":
        return r(a, m, p);
      case ">":
        return n(a, m, p);
      case ">=":
        return t(a, m, p);
      case "<":
        return g(a, m, p);
      case "<=":
        return i(a, m, p);
      default:
        throw new TypeError(`Invalid operator: ${d}`);
    }
  }, Xi;
}
var es, ju;
function Qd() {
  if (ju) return es;
  ju = 1;
  const e = Ue(), r = er(), { safeRe: n, t } = Vr();
  return es = (i, c) => {
    if (i instanceof e)
      return i;
    if (typeof i == "number" && (i = String(i)), typeof i != "string")
      return null;
    c = c || {};
    let a = null;
    if (!c.rtl)
      a = i.match(c.includePrerelease ? n[t.COERCEFULL] : n[t.COERCE]);
    else {
      const s = c.includePrerelease ? n[t.COERCERTLFULL] : n[t.COERCERTL];
      let f;
      for (; (f = s.exec(i)) && (!a || a.index + a[0].length !== i.length); )
        (!a || f.index + f[0].length !== a.index + a[0].length) && (a = f), s.lastIndex = f.index + f[1].length + f[2].length;
      s.lastIndex = -1;
    }
    if (a === null)
      return null;
    const d = a[2], m = a[3] || "0", p = a[4] || "0", o = c.includePrerelease && a[5] ? `-${a[5]}` : "", l = c.includePrerelease && a[6] ? `+${a[6]}` : "";
    return r(`${d}.${m}.${p}${o}${l}`, c);
  }, es;
}
var ts, $u;
function Yd() {
  if ($u) return ts;
  $u = 1;
  class e {
    constructor() {
      this.max = 1e3, this.map = /* @__PURE__ */ new Map();
    }
    get(n) {
      const t = this.map.get(n);
      if (t !== void 0)
        return this.map.delete(n), this.map.set(n, t), t;
    }
    delete(n) {
      return this.map.delete(n);
    }
    set(n, t) {
      if (!this.delete(n) && t !== void 0) {
        if (this.map.size >= this.max) {
          const i = this.map.keys().next().value;
          this.delete(i);
        }
        this.map.set(n, t);
      }
      return this;
    }
  }
  return ts = e, ts;
}
var rs, Uu;
function Xe() {
  if (Uu) return rs;
  Uu = 1;
  const e = /\s+/g;
  class r {
    constructor(E, C) {
      if (C = g(C), E instanceof r)
        return E.loose === !!C.loose && E.includePrerelease === !!C.includePrerelease ? E : new r(E.raw, C);
      if (E instanceof i)
        return this.raw = E.value, this.set = [[E]], this.formatted = void 0, this;
      if (this.options = C, this.loose = !!C.loose, this.includePrerelease = !!C.includePrerelease, this.raw = E.trim().replace(e, " "), this.set = this.raw.split("||").map((M) => this.parseRange(M.trim())).filter((M) => M.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const M = this.set[0];
        if (this.set = this.set.filter((x) => !b(x[0])), this.set.length === 0)
          this.set = [M];
        else if (this.set.length > 1) {
          for (const x of this.set)
            if (x.length === 1 && y(x[0])) {
              this.set = [x];
              break;
            }
        }
      }
      this.formatted = void 0;
    }
    get range() {
      if (this.formatted === void 0) {
        this.formatted = "";
        for (let E = 0; E < this.set.length; E++) {
          E > 0 && (this.formatted += "||");
          const C = this.set[E];
          for (let M = 0; M < C.length; M++)
            M > 0 && (this.formatted += " "), this.formatted += C[M].toString().trim();
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(E) {
      const M = ((this.options.includePrerelease && s) | (this.options.loose && f)) + ":" + E, x = t.get(M);
      if (x)
        return x;
      const B = this.options.loose, j = B ? d[m.HYPHENRANGELOOSE] : d[m.HYPHENRANGE];
      E = E.replace(j, re(this.options.includePrerelease)), c("hyphen replace", E), E = E.replace(d[m.COMPARATORTRIM], p), c("comparator trim", E), E = E.replace(d[m.TILDETRIM], o), c("tilde trim", E), E = E.replace(d[m.CARETTRIM], l), c("caret trim", E);
      let A = E.split(" ").map((K) => R(K, this.options)).join(" ").split(/\s+/).map((K) => Y(K, this.options));
      B && (A = A.filter((K) => (c("loose invalid filter", K, this.options), !!K.match(d[m.COMPARATORLOOSE])))), c("range list", A);
      const v = /* @__PURE__ */ new Map(), N = A.map((K) => new i(K, this.options));
      for (const K of N) {
        if (b(K))
          return [K];
        v.set(K.value, K);
      }
      v.size > 1 && v.has("") && v.delete("");
      const te = [...v.values()];
      return t.set(M, te), te;
    }
    intersects(E, C) {
      if (!(E instanceof r))
        throw new TypeError("a Range is required");
      return this.set.some((M) => u(M, C) && E.set.some((x) => u(x, C) && M.every((B) => x.every((j) => B.intersects(j, C)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(E) {
      if (!E)
        return !1;
      if (typeof E == "string")
        try {
          E = new a(E, this.options);
        } catch {
          return !1;
        }
      for (let C = 0; C < this.set.length; C++)
        if (F(this.set[C], E, this.options))
          return !0;
      return !1;
    }
  }
  rs = r;
  const n = Yd(), t = new n(), g = Zs(), i = Rn(), c = _n(), a = Ue(), {
    safeRe: d,
    t: m,
    comparatorTrimReplace: p,
    tildeTrimReplace: o,
    caretTrimReplace: l
  } = Vr(), { FLAG_INCLUDE_PRERELEASE: s, FLAG_LOOSE: f } = vn(), b = (h) => h.value === "<0.0.0-0", y = (h) => h.value === "", u = (h, E) => {
    let C = !0;
    const M = h.slice();
    let x = M.pop();
    for (; C && M.length; )
      C = M.every((B) => x.intersects(B, E)), x = M.pop();
    return C;
  }, R = (h, E) => (c("comp", h, E), h = q(h, E), c("caret", h), h = I(h, E), c("tildes", h), h = H(h, E), c("xrange", h), h = X(h, E), c("stars", h), h), S = (h) => !h || h.toLowerCase() === "x" || h === "*", I = (h, E) => h.trim().split(/\s+/).map((C) => T(C, E)).join(" "), T = (h, E) => {
    const C = E.loose ? d[m.TILDELOOSE] : d[m.TILDE];
    return h.replace(C, (M, x, B, j, A) => {
      c("tilde", h, M, x, B, j, A);
      let v;
      return S(x) ? v = "" : S(B) ? v = `>=${x}.0.0 <${+x + 1}.0.0-0` : S(j) ? v = `>=${x}.${B}.0 <${x}.${+B + 1}.0-0` : A ? (c("replaceTilde pr", A), v = `>=${x}.${B}.${j}-${A} <${x}.${+B + 1}.0-0`) : v = `>=${x}.${B}.${j} <${x}.${+B + 1}.0-0`, c("tilde return", v), v;
    });
  }, q = (h, E) => h.trim().split(/\s+/).map((C) => D(C, E)).join(" "), D = (h, E) => {
    c("caret", h, E);
    const C = E.loose ? d[m.CARETLOOSE] : d[m.CARET], M = E.includePrerelease ? "-0" : "";
    return h.replace(C, (x, B, j, A, v) => {
      c("caret", h, x, B, j, A, v);
      let N;
      return S(B) ? N = "" : S(j) ? N = `>=${B}.0.0${M} <${+B + 1}.0.0-0` : S(A) ? B === "0" ? N = `>=${B}.${j}.0${M} <${B}.${+j + 1}.0-0` : N = `>=${B}.${j}.0${M} <${+B + 1}.0.0-0` : v ? (c("replaceCaret pr", v), B === "0" ? j === "0" ? N = `>=${B}.${j}.${A}-${v} <${B}.${j}.${+A + 1}-0` : N = `>=${B}.${j}.${A}-${v} <${B}.${+j + 1}.0-0` : N = `>=${B}.${j}.${A}-${v} <${+B + 1}.0.0-0`) : (c("no pr"), B === "0" ? j === "0" ? N = `>=${B}.${j}.${A}${M} <${B}.${j}.${+A + 1}-0` : N = `>=${B}.${j}.${A}${M} <${B}.${+j + 1}.0-0` : N = `>=${B}.${j}.${A} <${+B + 1}.0.0-0`), c("caret return", N), N;
    });
  }, H = (h, E) => (c("replaceXRanges", h, E), h.split(/\s+/).map((C) => G(C, E)).join(" ")), G = (h, E) => {
    h = h.trim();
    const C = E.loose ? d[m.XRANGELOOSE] : d[m.XRANGE];
    return h.replace(C, (M, x, B, j, A, v) => {
      c("xRange", h, M, x, B, j, A, v);
      const N = S(B), te = N || S(j), K = te || S(A), $ = K;
      return x === "=" && $ && (x = ""), v = E.includePrerelease ? "-0" : "", N ? x === ">" || x === "<" ? M = "<0.0.0-0" : M = "*" : x && $ ? (te && (j = 0), A = 0, x === ">" ? (x = ">=", te ? (B = +B + 1, j = 0, A = 0) : (j = +j + 1, A = 0)) : x === "<=" && (x = "<", te ? B = +B + 1 : j = +j + 1), x === "<" && (v = "-0"), M = `${x + B}.${j}.${A}${v}`) : te ? M = `>=${B}.0.0${v} <${+B + 1}.0.0-0` : K && (M = `>=${B}.${j}.0${v} <${B}.${+j + 1}.0-0`), c("xRange return", M), M;
    });
  }, X = (h, E) => (c("replaceStars", h, E), h.trim().replace(d[m.STAR], "")), Y = (h, E) => (c("replaceGTE0", h, E), h.trim().replace(d[E.includePrerelease ? m.GTE0PRE : m.GTE0], "")), re = (h) => (E, C, M, x, B, j, A, v, N, te, K, $) => (S(M) ? C = "" : S(x) ? C = `>=${M}.0.0${h ? "-0" : ""}` : S(B) ? C = `>=${M}.${x}.0${h ? "-0" : ""}` : j ? C = `>=${C}` : C = `>=${C}${h ? "-0" : ""}`, S(N) ? v = "" : S(te) ? v = `<${+N + 1}.0.0-0` : S(K) ? v = `<${N}.${+te + 1}.0-0` : $ ? v = `<=${N}.${te}.${K}-${$}` : h ? v = `<${N}.${te}.${+K + 1}-0` : v = `<=${v}`, `${C} ${v}`.trim()), F = (h, E, C) => {
    for (let M = 0; M < h.length; M++)
      if (!h[M].test(E))
        return !1;
    if (E.prerelease.length && !C.includePrerelease) {
      for (let M = 0; M < h.length; M++)
        if (c(h[M].semver), h[M].semver !== i.ANY && h[M].semver.prerelease.length > 0) {
          const x = h[M].semver;
          if (x.major === E.major && x.minor === E.minor && x.patch === E.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return rs;
}
var ns, Hu;
function Rn() {
  if (Hu) return ns;
  Hu = 1;
  const e = Symbol("SemVer ANY");
  class r {
    static get ANY() {
      return e;
    }
    constructor(p, o) {
      if (o = n(o), p instanceof r) {
        if (p.loose === !!o.loose)
          return p;
        p = p.value;
      }
      p = p.trim().split(/\s+/).join(" "), c("comparator", p, o), this.options = o, this.loose = !!o.loose, this.parse(p), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this);
    }
    parse(p) {
      const o = this.options.loose ? t[g.COMPARATORLOOSE] : t[g.COMPARATOR], l = p.match(o);
      if (!l)
        throw new TypeError(`Invalid comparator: ${p}`);
      this.operator = l[1] !== void 0 ? l[1] : "", this.operator === "=" && (this.operator = ""), l[2] ? this.semver = new a(l[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(p) {
      if (c("Comparator.test", p, this.options.loose), this.semver === e || p === e)
        return !0;
      if (typeof p == "string")
        try {
          p = new a(p, this.options);
        } catch {
          return !1;
        }
      return i(p, this.operator, this.semver, this.options);
    }
    intersects(p, o) {
      if (!(p instanceof r))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new d(p.value, o).test(this.value) : p.operator === "" ? p.value === "" ? !0 : new d(this.value, o).test(p.semver) : (o = n(o), o.includePrerelease && (this.value === "<0.0.0-0" || p.value === "<0.0.0-0") || !o.includePrerelease && (this.value.startsWith("<0.0.0") || p.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && p.operator.startsWith(">") || this.operator.startsWith("<") && p.operator.startsWith("<") || this.semver.version === p.semver.version && this.operator.includes("=") && p.operator.includes("=") || i(this.semver, "<", p.semver, o) && this.operator.startsWith(">") && p.operator.startsWith("<") || i(this.semver, ">", p.semver, o) && this.operator.startsWith("<") && p.operator.startsWith(">")));
    }
  }
  ns = r;
  const n = Zs(), { safeRe: t, t: g } = Vr(), i = Cl(), c = _n(), a = Ue(), d = Xe();
  return ns;
}
var is, Wu;
function Sn() {
  if (Wu) return is;
  Wu = 1;
  const e = Xe();
  return is = (n, t, g) => {
    try {
      t = new e(t, g);
    } catch {
      return !1;
    }
    return t.test(n);
  }, is;
}
var ss, Vu;
function Xd() {
  if (Vu) return ss;
  Vu = 1;
  const e = Xe();
  return ss = (n, t) => new e(n, t).set.map((g) => g.map((i) => i.value).join(" ").trim().split(" ")), ss;
}
var os, zu;
function ef() {
  if (zu) return os;
  zu = 1;
  const e = Ue(), r = Xe();
  return os = (t, g, i) => {
    let c = null, a = null, d = null;
    try {
      d = new r(g, i);
    } catch {
      return null;
    }
    return t.forEach((m) => {
      d.test(m) && (!c || a.compare(m) === -1) && (c = m, a = new e(c, i));
    }), c;
  }, os;
}
var as, Ju;
function tf() {
  if (Ju) return as;
  Ju = 1;
  const e = Ue(), r = Xe();
  return as = (t, g, i) => {
    let c = null, a = null, d = null;
    try {
      d = new r(g, i);
    } catch {
      return null;
    }
    return t.forEach((m) => {
      d.test(m) && (!c || a.compare(m) === 1) && (c = m, a = new e(c, i));
    }), c;
  }, as;
}
var us, Gu;
function rf() {
  if (Gu) return us;
  Gu = 1;
  const e = Ue(), r = Xe(), n = En();
  return us = (g, i) => {
    g = new r(g, i);
    let c = new e("0.0.0");
    if (g.test(c) || (c = new e("0.0.0-0"), g.test(c)))
      return c;
    c = null;
    for (let a = 0; a < g.set.length; ++a) {
      const d = g.set[a];
      let m = null;
      d.forEach((p) => {
        const o = new e(p.semver.version);
        switch (p.operator) {
          case ">":
            o.prerelease.length === 0 ? o.patch++ : o.prerelease.push(0), o.raw = o.format();
          /* fallthrough */
          case "":
          case ">=":
            (!m || n(o, m)) && (m = o);
            break;
          case "<":
          case "<=":
            break;
          /* istanbul ignore next */
          default:
            throw new Error(`Unexpected operation: ${p.operator}`);
        }
      }), m && (!c || n(c, m)) && (c = m);
    }
    return c && g.test(c) ? c : null;
  }, us;
}
var cs, Zu;
function nf() {
  if (Zu) return cs;
  Zu = 1;
  const e = Xe();
  return cs = (n, t) => {
    try {
      return new e(n, t).range || "*";
    } catch {
      return null;
    }
  }, cs;
}
var ls, Ku;
function eo() {
  if (Ku) return ls;
  Ku = 1;
  const e = Ue(), r = Rn(), { ANY: n } = r, t = Xe(), g = Sn(), i = En(), c = Qs(), a = Xs(), d = Ys();
  return ls = (p, o, l, s) => {
    p = new e(p, s), o = new t(o, s);
    let f, b, y, u, R;
    switch (l) {
      case ">":
        f = i, b = a, y = c, u = ">", R = ">=";
        break;
      case "<":
        f = c, b = d, y = i, u = "<", R = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (g(p, o, s))
      return !1;
    for (let S = 0; S < o.set.length; ++S) {
      const I = o.set[S];
      let T = null, q = null;
      if (I.forEach((D) => {
        D.semver === n && (D = new r(">=0.0.0")), T = T || D, q = q || D, f(D.semver, T.semver, s) ? T = D : y(D.semver, q.semver, s) && (q = D);
      }), T.operator === u || T.operator === R || (!q.operator || q.operator === u) && b(p, q.semver))
        return !1;
      if (q.operator === R && y(p, q.semver))
        return !1;
    }
    return !0;
  }, ls;
}
var hs, Qu;
function sf() {
  if (Qu) return hs;
  Qu = 1;
  const e = eo();
  return hs = (n, t, g) => e(n, t, ">", g), hs;
}
var ds, Yu;
function of() {
  if (Yu) return ds;
  Yu = 1;
  const e = eo();
  return ds = (n, t, g) => e(n, t, "<", g), ds;
}
var fs, Xu;
function af() {
  if (Xu) return fs;
  Xu = 1;
  const e = Xe();
  return fs = (n, t, g) => (n = new e(n, g), t = new e(t, g), n.intersects(t, g)), fs;
}
var ps, ec;
function uf() {
  if (ec) return ps;
  ec = 1;
  const e = Sn(), r = Ye();
  return ps = (n, t, g) => {
    const i = [];
    let c = null, a = null;
    const d = n.sort((l, s) => r(l, s, g));
    for (const l of d)
      e(l, t, g) ? (a = l, c || (c = l)) : (a && i.push([c, a]), a = null, c = null);
    c && i.push([c, null]);
    const m = [];
    for (const [l, s] of i)
      l === s ? m.push(l) : !s && l === d[0] ? m.push("*") : s ? l === d[0] ? m.push(`<=${s}`) : m.push(`${l} - ${s}`) : m.push(`>=${l}`);
    const p = m.join(" || "), o = typeof t.raw == "string" ? t.raw : String(t);
    return p.length < o.length ? p : t;
  }, ps;
}
var gs, tc;
function cf() {
  if (tc) return gs;
  tc = 1;
  const e = Xe(), r = Rn(), { ANY: n } = r, t = Sn(), g = Ye(), i = (o, l, s = {}) => {
    if (o === l)
      return !0;
    o = new e(o, s), l = new e(l, s);
    let f = !1;
    e: for (const b of o.set) {
      for (const y of l.set) {
        const u = d(b, y, s);
        if (f = f || u !== null, u)
          continue e;
      }
      if (f)
        return !1;
    }
    return !0;
  }, c = [new r(">=0.0.0-0")], a = [new r(">=0.0.0")], d = (o, l, s) => {
    if (o === l)
      return !0;
    if (o.length === 1 && o[0].semver === n) {
      if (l.length === 1 && l[0].semver === n)
        return !0;
      s.includePrerelease ? o = c : o = a;
    }
    if (l.length === 1 && l[0].semver === n) {
      if (s.includePrerelease)
        return !0;
      l = a;
    }
    const f = /* @__PURE__ */ new Set();
    let b, y;
    for (const H of o)
      H.operator === ">" || H.operator === ">=" ? b = m(b, H, s) : H.operator === "<" || H.operator === "<=" ? y = p(y, H, s) : f.add(H.semver);
    if (f.size > 1)
      return null;
    let u;
    if (b && y) {
      if (u = g(b.semver, y.semver, s), u > 0)
        return null;
      if (u === 0 && (b.operator !== ">=" || y.operator !== "<="))
        return null;
    }
    for (const H of f) {
      if (b && !t(H, String(b), s) || y && !t(H, String(y), s))
        return null;
      for (const G of l)
        if (!t(H, String(G), s))
          return !1;
      return !0;
    }
    let R, S, I, T, q = y && !s.includePrerelease && y.semver.prerelease.length ? y.semver : !1, D = b && !s.includePrerelease && b.semver.prerelease.length ? b.semver : !1;
    q && q.prerelease.length === 1 && y.operator === "<" && q.prerelease[0] === 0 && (q = !1);
    for (const H of l) {
      if (T = T || H.operator === ">" || H.operator === ">=", I = I || H.operator === "<" || H.operator === "<=", b) {
        if (D && H.semver.prerelease && H.semver.prerelease.length && H.semver.major === D.major && H.semver.minor === D.minor && H.semver.patch === D.patch && (D = !1), H.operator === ">" || H.operator === ">=") {
          if (R = m(b, H, s), R === H && R !== b)
            return !1;
        } else if (b.operator === ">=" && !t(b.semver, String(H), s))
          return !1;
      }
      if (y) {
        if (q && H.semver.prerelease && H.semver.prerelease.length && H.semver.major === q.major && H.semver.minor === q.minor && H.semver.patch === q.patch && (q = !1), H.operator === "<" || H.operator === "<=") {
          if (S = p(y, H, s), S === H && S !== y)
            return !1;
        } else if (y.operator === "<=" && !t(y.semver, String(H), s))
          return !1;
      }
      if (!H.operator && (y || b) && u !== 0)
        return !1;
    }
    return !(b && I && !y && u !== 0 || y && T && !b && u !== 0 || D || q);
  }, m = (o, l, s) => {
    if (!o)
      return l;
    const f = g(o.semver, l.semver, s);
    return f > 0 ? o : f < 0 || l.operator === ">" && o.operator === ">=" ? l : o;
  }, p = (o, l, s) => {
    if (!o)
      return l;
    const f = g(o.semver, l.semver, s);
    return f < 0 ? o : f > 0 || l.operator === "<" && o.operator === "<=" ? l : o;
  };
  return gs = i, gs;
}
var ms, rc;
function lf() {
  if (rc) return ms;
  rc = 1;
  const e = Vr(), r = vn(), n = Ue(), t = El(), g = er(), i = qd(), c = jd(), a = $d(), d = Ud(), m = Hd(), p = Wd(), o = Vd(), l = zd(), s = Ye(), f = Jd(), b = Gd(), y = Ks(), u = Zd(), R = Kd(), S = En(), I = Qs(), T = Rl(), q = Sl(), D = Ys(), H = Xs(), G = Cl(), X = Qd(), Y = Rn(), re = Xe(), F = Sn(), h = Xd(), E = ef(), C = tf(), M = rf(), x = nf(), B = eo(), j = sf(), A = of(), v = af(), N = uf(), te = cf();
  return ms = {
    parse: g,
    valid: i,
    clean: c,
    inc: a,
    diff: d,
    major: m,
    minor: p,
    patch: o,
    prerelease: l,
    compare: s,
    rcompare: f,
    compareLoose: b,
    compareBuild: y,
    sort: u,
    rsort: R,
    gt: S,
    lt: I,
    eq: T,
    neq: q,
    gte: D,
    lte: H,
    cmp: G,
    coerce: X,
    Comparator: Y,
    Range: re,
    satisfies: F,
    toComparators: h,
    maxSatisfying: E,
    minSatisfying: C,
    minVersion: M,
    validRange: x,
    outside: B,
    gtr: j,
    ltr: A,
    intersects: v,
    simplifyRange: N,
    subset: te,
    SemVer: n,
    re: e.re,
    src: e.src,
    tokens: e.t,
    SEMVER_SPEC_VERSION: r.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: r.RELEASE_TYPES,
    compareIdentifiers: t.compareIdentifiers,
    rcompareIdentifiers: t.rcompareIdentifiers
  }, ms;
}
var nc;
function hf() {
  return nc || (nc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
    const r = lf(), n = xt, t = ot();
    e.VersionStruct = (0, n.refine)((0, n.string)(), "Version", (o) => (0, r.valid)(o) === null ? `Expected SemVer version, got "${o}"` : !0), e.VersionRangeStruct = (0, n.refine)((0, n.string)(), "Version range", (o) => (0, r.validRange)(o) === null ? `Expected SemVer range, got "${o}"` : !0);
    function g(o) {
      return (0, n.is)(o, e.VersionStruct);
    }
    e.isValidSemVerVersion = g;
    function i(o) {
      return (0, n.is)(o, e.VersionRangeStruct);
    }
    e.isValidSemVerRange = i;
    function c(o) {
      (0, t.assertStruct)(o, e.VersionStruct);
    }
    e.assertIsSemVerVersion = c;
    function a(o) {
      (0, t.assertStruct)(o, e.VersionRangeStruct);
    }
    e.assertIsSemVerRange = a;
    function d(o, l) {
      return (0, r.gt)(o, l);
    }
    e.gtVersion = d;
    function m(o, l) {
      return (0, r.gtr)(o, l);
    }
    e.gtRange = m;
    function p(o, l) {
      return (0, r.satisfies)(o, l, {
        includePrerelease: !0
      });
    }
    e.satisfiesVersionRange = p;
  }(Mi)), Mi;
}
var ic;
function df() {
  return ic || (ic = 1, function(e) {
    var r = xr.__createBinding || (Object.create ? function(t, g, i, c) {
      c === void 0 && (c = i);
      var a = Object.getOwnPropertyDescriptor(g, i);
      (!a || ("get" in a ? !g.__esModule : a.writable || a.configurable)) && (a = { enumerable: !0, get: function() {
        return g[i];
      } }), Object.defineProperty(t, c, a);
    } : function(t, g, i, c) {
      c === void 0 && (c = i), t[c] = g[i];
    }), n = xr.__exportStar || function(t, g) {
      for (var i in t) i !== "default" && !Object.prototype.hasOwnProperty.call(g, i) && r(g, t, i);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), n(ot(), e), n(vl(), e), n(_l(), e), n(Sd(), e), n(Cd(), e), n(Md(), e), n(kd(), e), n(bn(), e), n(Id(), e), n(xd(), e), n(Bd(), e), n(Nd(), e), n(Pd(), e), n(Od(), e), n(Fd(), e), n(Dd(), e), n(hf(), e);
  }(xr)), xr;
}
var sc;
function ff() {
  return sc || (sc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.createModuleLogger = e.projectLogger = void 0;
    const r = df();
    Object.defineProperty(e, "createModuleLogger", { enumerable: !0, get: function() {
      return r.createModuleLogger;
    } }), e.projectLogger = (0, r.createProjectLogger)("eth-block-tracker");
  }(gi)), gi;
}
var oc;
function pf() {
  if (oc) return Vt;
  oc = 1;
  var e = Vt.__importDefault || function(p) {
    return p && p.__esModule ? p : { default: p };
  };
  Object.defineProperty(Vt, "__esModule", { value: !0 }), Vt.PollingBlockTracker = void 0;
  const r = e(Hs()), n = e(Dh()), t = hl(), g = ff(), i = (0, g.createModuleLogger)(g.projectLogger, "polling-block-tracker"), c = (0, r.default)(), a = 1e3;
  let d = class extends t.BaseBlockTracker {
    constructor(o = {}) {
      var l;
      if (!o.provider)
        throw new Error("PollingBlockTracker - no provider specified.");
      super(Object.assign(Object.assign({}, o), { blockResetDuration: (l = o.blockResetDuration) !== null && l !== void 0 ? l : o.pollingInterval })), this._provider = o.provider, this._pollingInterval = o.pollingInterval || 20 * a, this._retryTimeout = o.retryTimeout || this._pollingInterval / 10, this._keepEventLoopActive = o.keepEventLoopActive === void 0 ? !0 : o.keepEventLoopActive, this._setSkipCacheFlag = o.setSkipCacheFlag || !1;
    }
    // trigger block polling
    async checkForLatestBlock() {
      return await this._updateLatestBlock(), await this.getLatestBlock();
    }
    async _start() {
      this._synchronize();
    }
    async _end() {
    }
    async _synchronize() {
      for (var o; this._isRunning; )
        try {
          await this._updateLatestBlock();
          const l = m(this._pollingInterval, !this._keepEventLoopActive);
          this.emit("_waitingForNextIteration"), await l;
        } catch (l) {
          const s = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:
${(o = l.stack) !== null && o !== void 0 ? o : l}`);
          try {
            this.emit("error", s);
          } catch {
            console.error(s);
          }
          const f = m(this._retryTimeout, !this._keepEventLoopActive);
          this.emit("_waitingForNextIteration"), await f;
        }
    }
    async _updateLatestBlock() {
      const o = await this._fetchLatestBlock();
      this._newPotentialLatest(o);
    }
    async _fetchLatestBlock() {
      const o = {
        jsonrpc: "2.0",
        id: c(),
        method: "eth_blockNumber",
        params: []
      };
      this._setSkipCacheFlag && (o.skipCache = !0), i("Making request", o);
      const l = await (0, n.default)((s) => this._provider.sendAsync(o, s))();
      if (i("Got response", l), l.error)
        throw new Error(`PollingBlockTracker - encountered error fetching block:
${l.error.message}`);
      return l.result;
    }
  };
  Vt.PollingBlockTracker = d;
  function m(p, o) {
    return new Promise((l) => {
      const s = setTimeout(l, p);
      s.unref && o && s.unref();
    });
  }
  return Vt;
}
var Jt = {}, ac;
function gf() {
  if (ac) return Jt;
  ac = 1;
  var e = Jt.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(Jt, "__esModule", { value: !0 }), Jt.SubscribeBlockTracker = void 0;
  const r = e(Hs()), n = hl(), t = (0, r.default)();
  let g = class extends n.BaseBlockTracker {
    constructor(c = {}) {
      if (!c.provider)
        throw new Error("SubscribeBlockTracker - no provider specified.");
      super(c), this._provider = c.provider, this._subscriptionId = null;
    }
    async checkForLatestBlock() {
      return await this.getLatestBlock();
    }
    async _start() {
      if (this._subscriptionId === void 0 || this._subscriptionId === null)
        try {
          const c = await this._call("eth_blockNumber");
          this._subscriptionId = await this._call("eth_subscribe", "newHeads"), this._provider.on("data", this._handleSubData.bind(this)), this._newPotentialLatest(c);
        } catch (c) {
          this.emit("error", c);
        }
    }
    async _end() {
      if (this._subscriptionId !== null && this._subscriptionId !== void 0)
        try {
          await this._call("eth_unsubscribe", this._subscriptionId), this._subscriptionId = null;
        } catch (c) {
          this.emit("error", c);
        }
    }
    _call(c, ...a) {
      return new Promise((d, m) => {
        this._provider.sendAsync({
          id: t(),
          method: c,
          params: a,
          jsonrpc: "2.0"
        }, (p, o) => {
          p ? m(p) : d(o.result);
        });
      });
    }
    _handleSubData(c, a) {
      var d;
      a.method === "eth_subscription" && ((d = a.params) === null || d === void 0 ? void 0 : d.subscription) === this._subscriptionId && this._newPotentialLatest(a.params.result.number);
    }
  };
  return Jt.SubscribeBlockTracker = g, Jt;
}
var uc;
function mf() {
  return uc || (uc = 1, function(e) {
    var r = Ir.__createBinding || (Object.create ? function(t, g, i, c) {
      c === void 0 && (c = i), Object.defineProperty(t, c, { enumerable: !0, get: function() {
        return g[i];
      } });
    } : function(t, g, i, c) {
      c === void 0 && (c = i), t[c] = g[i];
    }), n = Ir.__exportStar || function(t, g) {
      for (var i in t) i !== "default" && !Object.prototype.hasOwnProperty.call(g, i) && r(g, t, i);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), n(pf(), e), n(gf(), e);
  }(Ir)), Ir;
}
var Lr = {}, Br = {}, Nr = {}, cc;
function Ml() {
  if (cc) return Nr;
  cc = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.getUniqueId = void 0;
  const e = 4294967295;
  let r = Math.floor(Math.random() * e);
  function n() {
    return r = (r + 1) % e, r;
  }
  return Nr.getUniqueId = n, Nr;
}
var lc;
function wf() {
  if (lc) return Br;
  lc = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.createIdRemapMiddleware = void 0;
  const e = Ml();
  function r() {
    return (n, t, g, i) => {
      const c = n.id, a = e.getUniqueId();
      n.id = a, t.id = a, g((d) => {
        n.id = c, t.id = c, d();
      });
    };
  }
  return Br.createIdRemapMiddleware = r, Br;
}
var Pr = {}, hc;
function yf() {
  if (hc) return Pr;
  hc = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.createAsyncMiddleware = void 0;
  function e(r) {
    return async (n, t, g, i) => {
      let c;
      const a = new Promise((o) => {
        c = o;
      });
      let d = null, m = !1;
      const p = async () => {
        m = !0, g((o) => {
          d = o, c();
        }), await a;
      };
      try {
        await r(n, t, p), m ? (await a, d(null)) : i(null);
      } catch (o) {
        d ? d(o) : i(o);
      }
    };
  }
  return Pr.createAsyncMiddleware = e, Pr;
}
var Or = {}, dc;
function bf() {
  if (dc) return Or;
  dc = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.createScaffoldMiddleware = void 0;
  function e(r) {
    return (n, t, g, i) => {
      const c = r[n.method];
      return c === void 0 ? g() : typeof c == "function" ? c(n, t, g, i) : (t.result = c, i());
    };
  }
  return Or.createScaffoldMiddleware = e, Or;
}
var Gt = {}, un = {}, fc;
function vf() {
  if (fc) return un;
  fc = 1, Object.defineProperty(un, "__esModule", { value: !0 });
  const e = dn();
  function r(g, i, c) {
    try {
      Reflect.apply(g, i, c);
    } catch (a) {
      setTimeout(() => {
        throw a;
      });
    }
  }
  function n(g) {
    const i = g.length, c = new Array(i);
    for (let a = 0; a < i; a += 1)
      c[a] = g[a];
    return c;
  }
  class t extends e.EventEmitter {
    emit(i, ...c) {
      let a = i === "error";
      const d = this._events;
      if (d !== void 0)
        a = a && d.error === void 0;
      else if (!a)
        return !1;
      if (a) {
        let p;
        if (c.length > 0 && ([p] = c), p instanceof Error)
          throw p;
        const o = new Error(`Unhandled error.${p ? ` (${p.message})` : ""}`);
        throw o.context = p, o;
      }
      const m = d[i];
      if (m === void 0)
        return !1;
      if (typeof m == "function")
        r(m, this, c);
      else {
        const p = m.length, o = n(m);
        for (let l = 0; l < p; l += 1)
          r(o[l], this, c);
      }
      return !0;
    }
  }
  return un.default = t, un;
}
var ws = {}, Ct = {}, ys, pc;
function _f() {
  if (pc) return ys;
  pc = 1, ys = i, i.default = i, i.stable = m, i.stableStringify = m;
  var e = "[...]", r = "[Circular]", n = [], t = [];
  function g() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function i(l, s, f, b) {
    typeof b > "u" && (b = g()), a(l, "", 0, [], void 0, 0, b);
    var y;
    try {
      t.length === 0 ? y = JSON.stringify(l, s, f) : y = JSON.stringify(l, o(s), f);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; n.length !== 0; ) {
        var u = n.pop();
        u.length === 4 ? Object.defineProperty(u[0], u[1], u[3]) : u[0][u[1]] = u[2];
      }
    }
    return y;
  }
  function c(l, s, f, b) {
    var y = Object.getOwnPropertyDescriptor(b, f);
    y.get !== void 0 ? y.configurable ? (Object.defineProperty(b, f, { value: l }), n.push([b, f, s, y])) : t.push([s, f, l]) : (b[f] = l, n.push([b, f, s]));
  }
  function a(l, s, f, b, y, u, R) {
    u += 1;
    var S;
    if (typeof l == "object" && l !== null) {
      for (S = 0; S < b.length; S++)
        if (b[S] === l) {
          c(r, l, s, y);
          return;
        }
      if (typeof R.depthLimit < "u" && u > R.depthLimit) {
        c(e, l, s, y);
        return;
      }
      if (typeof R.edgesLimit < "u" && f + 1 > R.edgesLimit) {
        c(e, l, s, y);
        return;
      }
      if (b.push(l), Array.isArray(l))
        for (S = 0; S < l.length; S++)
          a(l[S], S, S, b, l, u, R);
      else {
        var I = Object.keys(l);
        for (S = 0; S < I.length; S++) {
          var T = I[S];
          a(l[T], T, S, b, l, u, R);
        }
      }
      b.pop();
    }
  }
  function d(l, s) {
    return l < s ? -1 : l > s ? 1 : 0;
  }
  function m(l, s, f, b) {
    typeof b > "u" && (b = g());
    var y = p(l, "", 0, [], void 0, 0, b) || l, u;
    try {
      t.length === 0 ? u = JSON.stringify(y, s, f) : u = JSON.stringify(y, o(s), f);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; n.length !== 0; ) {
        var R = n.pop();
        R.length === 4 ? Object.defineProperty(R[0], R[1], R[3]) : R[0][R[1]] = R[2];
      }
    }
    return u;
  }
  function p(l, s, f, b, y, u, R) {
    u += 1;
    var S;
    if (typeof l == "object" && l !== null) {
      for (S = 0; S < b.length; S++)
        if (b[S] === l) {
          c(r, l, s, y);
          return;
        }
      try {
        if (typeof l.toJSON == "function")
          return;
      } catch {
        return;
      }
      if (typeof R.depthLimit < "u" && u > R.depthLimit) {
        c(e, l, s, y);
        return;
      }
      if (typeof R.edgesLimit < "u" && f + 1 > R.edgesLimit) {
        c(e, l, s, y);
        return;
      }
      if (b.push(l), Array.isArray(l))
        for (S = 0; S < l.length; S++)
          p(l[S], S, S, b, l, u, R);
      else {
        var I = {}, T = Object.keys(l).sort(d);
        for (S = 0; S < T.length; S++) {
          var q = T[S];
          p(l[q], q, S, b, l, u, R), I[q] = l[q];
        }
        if (typeof y < "u")
          n.push([y, s, l]), y[s] = I;
        else
          return I;
      }
      b.pop();
    }
  }
  function o(l) {
    return l = typeof l < "u" ? l : function(s, f) {
      return f;
    }, function(s, f) {
      if (t.length > 0)
        for (var b = 0; b < t.length; b++) {
          var y = t[b];
          if (y[1] === s && y[0] === f) {
            f = y[2], t.splice(b, 1);
            break;
          }
        }
      return l.call(this, s, f);
    };
  }
  return ys;
}
var gc;
function to() {
  if (gc) return Ct;
  gc = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.EthereumProviderError = Ct.EthereumRpcError = void 0;
  const e = _f();
  class r extends Error {
    constructor(c, a, d) {
      if (!Number.isInteger(c))
        throw new Error('"code" must be an integer.');
      if (!a || typeof a != "string")
        throw new Error('"message" must be a nonempty string.');
      super(a), this.code = c, d !== void 0 && (this.data = d);
    }
    /**
     * Returns a plain object with all public class properties.
     */
    serialize() {
      const c = {
        code: this.code,
        message: this.message
      };
      return this.data !== void 0 && (c.data = this.data), this.stack && (c.stack = this.stack), c;
    }
    /**
     * Return a string representation of the serialized error, omitting
     * any circular references.
     */
    toString() {
      return e.default(this.serialize(), g, 2);
    }
  }
  Ct.EthereumRpcError = r;
  class n extends r {
    /**
     * Create an Ethereum Provider JSON-RPC error.
     * `code` must be an integer in the 1000 <= 4999 range.
     */
    constructor(c, a, d) {
      if (!t(c))
        throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
      super(c, a, d);
    }
  }
  Ct.EthereumProviderError = n;
  function t(i) {
    return Number.isInteger(i) && i >= 1e3 && i <= 4999;
  }
  function g(i, c) {
    if (c !== "[Circular]")
      return c;
  }
  return Ct;
}
var bs = {}, Mt = {}, mc;
function ro() {
  return mc || (mc = 1, Object.defineProperty(Mt, "__esModule", { value: !0 }), Mt.errorValues = Mt.errorCodes = void 0, Mt.errorCodes = {
    rpc: {
      invalidInput: -32e3,
      resourceNotFound: -32001,
      resourceUnavailable: -32002,
      transactionRejected: -32003,
      methodNotSupported: -32004,
      limitExceeded: -32005,
      parse: -32700,
      invalidRequest: -32600,
      methodNotFound: -32601,
      invalidParams: -32602,
      internal: -32603
    },
    provider: {
      userRejectedRequest: 4001,
      unauthorized: 4100,
      unsupportedMethod: 4200,
      disconnected: 4900,
      chainDisconnected: 4901
    }
  }, Mt.errorValues = {
    "-32700": {
      standard: "JSON RPC 2.0",
      message: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
    },
    "-32600": {
      standard: "JSON RPC 2.0",
      message: "The JSON sent is not a valid Request object."
    },
    "-32601": {
      standard: "JSON RPC 2.0",
      message: "The method does not exist / is not available."
    },
    "-32602": {
      standard: "JSON RPC 2.0",
      message: "Invalid method parameter(s)."
    },
    "-32603": {
      standard: "JSON RPC 2.0",
      message: "Internal JSON-RPC error."
    },
    "-32000": {
      standard: "EIP-1474",
      message: "Invalid input."
    },
    "-32001": {
      standard: "EIP-1474",
      message: "Resource not found."
    },
    "-32002": {
      standard: "EIP-1474",
      message: "Resource unavailable."
    },
    "-32003": {
      standard: "EIP-1474",
      message: "Transaction rejected."
    },
    "-32004": {
      standard: "EIP-1474",
      message: "Method not supported."
    },
    "-32005": {
      standard: "EIP-1474",
      message: "Request limit exceeded."
    },
    4001: {
      standard: "EIP-1193",
      message: "User rejected the request."
    },
    4100: {
      standard: "EIP-1193",
      message: "The requested account and/or method has not been authorized by the user."
    },
    4200: {
      standard: "EIP-1193",
      message: "The requested method is not supported by this Ethereum provider."
    },
    4900: {
      standard: "EIP-1193",
      message: "The provider is disconnected from all chains."
    },
    4901: {
      standard: "EIP-1193",
      message: "The provider is disconnected from the specified chain."
    }
  }), Mt;
}
var wc;
function kl() {
  return wc || (wc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;
    const r = ro(), n = to(), t = r.errorCodes.rpc.internal, g = "Unspecified error message. This is a bug, please report it.", i = {
      code: t,
      message: c(t)
    };
    e.JSON_RPC_SERVER_ERROR_MESSAGE = "Unspecified server error.";
    function c(l, s = g) {
      if (Number.isInteger(l)) {
        const f = l.toString();
        if (o(r.errorValues, f))
          return r.errorValues[f].message;
        if (m(l))
          return e.JSON_RPC_SERVER_ERROR_MESSAGE;
      }
      return s;
    }
    e.getMessageFromCode = c;
    function a(l) {
      if (!Number.isInteger(l))
        return !1;
      const s = l.toString();
      return !!(r.errorValues[s] || m(l));
    }
    e.isValidCode = a;
    function d(l, { fallbackError: s = i, shouldIncludeStack: f = !1 } = {}) {
      var b, y;
      if (!s || !Number.isInteger(s.code) || typeof s.message != "string")
        throw new Error("Must provide fallback error with integer number code and string message.");
      if (l instanceof n.EthereumRpcError)
        return l.serialize();
      const u = {};
      if (l && typeof l == "object" && !Array.isArray(l) && o(l, "code") && a(l.code)) {
        const S = l;
        u.code = S.code, S.message && typeof S.message == "string" ? (u.message = S.message, o(S, "data") && (u.data = S.data)) : (u.message = c(u.code), u.data = { originalError: p(l) });
      } else {
        u.code = s.code;
        const S = (b = l) === null || b === void 0 ? void 0 : b.message;
        u.message = S && typeof S == "string" ? S : s.message, u.data = { originalError: p(l) };
      }
      const R = (y = l) === null || y === void 0 ? void 0 : y.stack;
      return f && l && R && typeof R == "string" && (u.stack = R), u;
    }
    e.serializeError = d;
    function m(l) {
      return l >= -32099 && l <= -32e3;
    }
    function p(l) {
      return l && typeof l == "object" && !Array.isArray(l) ? Object.assign({}, l) : l;
    }
    function o(l, s) {
      return Object.prototype.hasOwnProperty.call(l, s);
    }
  }(bs)), bs;
}
var Fr = {}, yc;
function Ef() {
  if (yc) return Fr;
  yc = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.ethErrors = void 0;
  const e = to(), r = kl(), n = ro();
  Fr.ethErrors = {
    rpc: {
      /**
       * Get a JSON RPC 2.0 Parse (-32700) error.
       */
      parse: (c) => t(n.errorCodes.rpc.parse, c),
      /**
       * Get a JSON RPC 2.0 Invalid Request (-32600) error.
       */
      invalidRequest: (c) => t(n.errorCodes.rpc.invalidRequest, c),
      /**
       * Get a JSON RPC 2.0 Invalid Params (-32602) error.
       */
      invalidParams: (c) => t(n.errorCodes.rpc.invalidParams, c),
      /**
       * Get a JSON RPC 2.0 Method Not Found (-32601) error.
       */
      methodNotFound: (c) => t(n.errorCodes.rpc.methodNotFound, c),
      /**
       * Get a JSON RPC 2.0 Internal (-32603) error.
       */
      internal: (c) => t(n.errorCodes.rpc.internal, c),
      /**
       * Get a JSON RPC 2.0 Server error.
       * Permits integer error codes in the [ -32099 <= -32005 ] range.
       * Codes -32000 through -32004 are reserved by EIP-1474.
       */
      server: (c) => {
        if (!c || typeof c != "object" || Array.isArray(c))
          throw new Error("Ethereum RPC Server errors must provide single object argument.");
        const { code: a } = c;
        if (!Number.isInteger(a) || a > -32005 || a < -32099)
          throw new Error('"code" must be an integer such that: -32099 <= code <= -32005');
        return t(a, c);
      },
      /**
       * Get an Ethereum JSON RPC Invalid Input (-32000) error.
       */
      invalidInput: (c) => t(n.errorCodes.rpc.invalidInput, c),
      /**
       * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
       */
      resourceNotFound: (c) => t(n.errorCodes.rpc.resourceNotFound, c),
      /**
       * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
       */
      resourceUnavailable: (c) => t(n.errorCodes.rpc.resourceUnavailable, c),
      /**
       * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
       */
      transactionRejected: (c) => t(n.errorCodes.rpc.transactionRejected, c),
      /**
       * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
       */
      methodNotSupported: (c) => t(n.errorCodes.rpc.methodNotSupported, c),
      /**
       * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
       */
      limitExceeded: (c) => t(n.errorCodes.rpc.limitExceeded, c)
    },
    provider: {
      /**
       * Get an Ethereum Provider User Rejected Request (4001) error.
       */
      userRejectedRequest: (c) => g(n.errorCodes.provider.userRejectedRequest, c),
      /**
       * Get an Ethereum Provider Unauthorized (4100) error.
       */
      unauthorized: (c) => g(n.errorCodes.provider.unauthorized, c),
      /**
       * Get an Ethereum Provider Unsupported Method (4200) error.
       */
      unsupportedMethod: (c) => g(n.errorCodes.provider.unsupportedMethod, c),
      /**
       * Get an Ethereum Provider Not Connected (4900) error.
       */
      disconnected: (c) => g(n.errorCodes.provider.disconnected, c),
      /**
       * Get an Ethereum Provider Chain Not Connected (4901) error.
       */
      chainDisconnected: (c) => g(n.errorCodes.provider.chainDisconnected, c),
      /**
       * Get a custom Ethereum Provider error.
       */
      custom: (c) => {
        if (!c || typeof c != "object" || Array.isArray(c))
          throw new Error("Ethereum Provider custom errors must provide single object argument.");
        const { code: a, message: d, data: m } = c;
        if (!d || typeof d != "string")
          throw new Error('"message" must be a nonempty string');
        return new e.EthereumProviderError(a, d, m);
      }
    }
  };
  function t(c, a) {
    const [d, m] = i(a);
    return new e.EthereumRpcError(c, d || r.getMessageFromCode(c), m);
  }
  function g(c, a) {
    const [d, m] = i(a);
    return new e.EthereumProviderError(c, d || r.getMessageFromCode(c), m);
  }
  function i(c) {
    if (c) {
      if (typeof c == "string")
        return [c];
      if (typeof c == "object" && !Array.isArray(c)) {
        const { message: a, data: d } = c;
        if (a && typeof a != "string")
          throw new Error("Must specify string message.");
        return [a || void 0, d];
      }
    }
    return [];
  }
  return Fr;
}
var bc;
function Rf() {
  return bc || (bc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;
    const r = to();
    Object.defineProperty(e, "EthereumRpcError", { enumerable: !0, get: function() {
      return r.EthereumRpcError;
    } }), Object.defineProperty(e, "EthereumProviderError", { enumerable: !0, get: function() {
      return r.EthereumProviderError;
    } });
    const n = kl();
    Object.defineProperty(e, "serializeError", { enumerable: !0, get: function() {
      return n.serializeError;
    } }), Object.defineProperty(e, "getMessageFromCode", { enumerable: !0, get: function() {
      return n.getMessageFromCode;
    } });
    const t = Ef();
    Object.defineProperty(e, "ethErrors", { enumerable: !0, get: function() {
      return t.ethErrors;
    } });
    const g = ro();
    Object.defineProperty(e, "errorCodes", { enumerable: !0, get: function() {
      return g.errorCodes;
    } });
  }(ws)), ws;
}
var vc;
function Il() {
  if (vc) return Gt;
  vc = 1;
  var e = Gt.__importDefault || function(i) {
    return i && i.__esModule ? i : { default: i };
  };
  Object.defineProperty(Gt, "__esModule", { value: !0 }), Gt.JsonRpcEngine = void 0;
  const r = e(vf()), n = Rf();
  let t = class it extends r.default {
    constructor() {
      super(), this._middleware = [];
    }
    /**
     * Add a middleware function to the engine's middleware stack.
     *
     * @param middleware - The middleware function to add.
     */
    push(c) {
      this._middleware.push(c);
    }
    handle(c, a) {
      if (a && typeof a != "function")
        throw new Error('"callback" must be a function if provided.');
      return Array.isArray(c) ? a ? this._handleBatch(c, a) : this._handleBatch(c) : a ? this._handle(c, a) : this._promiseHandle(c);
    }
    /**
     * Returns this engine as a middleware function that can be pushed to other
     * engines.
     *
     * @returns This engine as a middleware function.
     */
    asMiddleware() {
      return async (c, a, d, m) => {
        try {
          const [p, o, l] = await it._runAllMiddleware(c, a, this._middleware);
          return o ? (await it._runReturnHandlers(l), m(p)) : d(async (s) => {
            try {
              await it._runReturnHandlers(l);
            } catch (f) {
              return s(f);
            }
            return s();
          });
        } catch (p) {
          return m(p);
        }
      };
    }
    async _handleBatch(c, a) {
      try {
        const d = await Promise.all(
          // 1. Begin executing each request in the order received
          c.map(this._promiseHandle.bind(this))
        );
        return a ? a(null, d) : d;
      } catch (d) {
        if (a)
          return a(d);
        throw d;
      }
    }
    /**
     * A promise-wrapped _handle.
     */
    _promiseHandle(c) {
      return new Promise((a) => {
        this._handle(c, (d, m) => {
          a(m);
        });
      });
    }
    /**
     * Ensures that the request object is valid, processes it, and passes any
     * error and the response object to the given callback.
     *
     * Does not reject.
     */
    async _handle(c, a) {
      if (!c || Array.isArray(c) || typeof c != "object") {
        const o = new n.EthereumRpcError(n.errorCodes.rpc.invalidRequest, `Requests must be plain objects. Received: ${typeof c}`, { request: c });
        return a(o, { id: void 0, jsonrpc: "2.0", error: o });
      }
      if (typeof c.method != "string") {
        const o = new n.EthereumRpcError(n.errorCodes.rpc.invalidRequest, `Must specify a string method. Received: ${typeof c.method}`, { request: c });
        return a(o, { id: c.id, jsonrpc: "2.0", error: o });
      }
      const d = Object.assign({}, c), m = {
        id: d.id,
        jsonrpc: d.jsonrpc
      };
      let p = null;
      try {
        await this._processRequest(d, m);
      } catch (o) {
        p = o;
      }
      return p && (delete m.result, m.error || (m.error = n.serializeError(p))), a(p, m);
    }
    /**
     * For the given request and response, runs all middleware and their return
     * handlers, if any, and ensures that internal request processing semantics
     * are satisfied.
     */
    async _processRequest(c, a) {
      const [d, m, p] = await it._runAllMiddleware(c, a, this._middleware);
      if (it._checkForCompletion(c, a, m), await it._runReturnHandlers(p), d)
        throw d;
    }
    /**
     * Serially executes the given stack of middleware.
     *
     * @returns An array of any error encountered during middleware execution,
     * a boolean indicating whether the request was completed, and an array of
     * middleware-defined return handlers.
     */
    static async _runAllMiddleware(c, a, d) {
      const m = [];
      let p = null, o = !1;
      for (const l of d)
        if ([p, o] = await it._runMiddleware(c, a, l, m), o)
          break;
      return [p, o, m.reverse()];
    }
    /**
     * Runs an individual middleware.
     *
     * @returns An array of any error encountered during middleware exection,
     * and a boolean indicating whether the request should end.
     */
    static _runMiddleware(c, a, d, m) {
      return new Promise((p) => {
        const o = (s) => {
          const f = s || a.error;
          f && (a.error = n.serializeError(f)), p([f, !0]);
        }, l = (s) => {
          a.error ? o(a.error) : (s && (typeof s != "function" && o(new n.EthereumRpcError(n.errorCodes.rpc.internal, `JsonRpcEngine: "next" return handlers must be functions. Received "${typeof s}" for request:
${g(c)}`, { request: c })), m.push(s)), p([null, !1]));
        };
        try {
          d(c, a, l, o);
        } catch (s) {
          o(s);
        }
      });
    }
    /**
     * Serially executes array of return handlers. The request and response are
     * assumed to be in their scope.
     */
    static async _runReturnHandlers(c) {
      for (const a of c)
        await new Promise((d, m) => {
          a((p) => p ? m(p) : d());
        });
    }
    /**
     * Throws an error if the response has neither a result nor an error, or if
     * the "isComplete" flag is falsy.
     */
    static _checkForCompletion(c, a, d) {
      if (!("result" in a) && !("error" in a))
        throw new n.EthereumRpcError(n.errorCodes.rpc.internal, `JsonRpcEngine: Response has no error or result for request:
${g(c)}`, { request: c });
      if (!d)
        throw new n.EthereumRpcError(n.errorCodes.rpc.internal, `JsonRpcEngine: Nothing ended request:
${g(c)}`, { request: c });
    }
  };
  Gt.JsonRpcEngine = t;
  function g(i) {
    return JSON.stringify(i, null, 2);
  }
  return Gt;
}
var Dr = {}, _c;
function Sf() {
  if (_c) return Dr;
  _c = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.mergeMiddleware = void 0;
  const e = Il();
  function r(n) {
    const t = new e.JsonRpcEngine();
    return n.forEach((g) => t.push(g)), t.asMiddleware();
  }
  return Dr.mergeMiddleware = r, Dr;
}
var Ec;
function xl() {
  return Ec || (Ec = 1, function(e) {
    var r = Lr.__createBinding || (Object.create ? function(t, g, i, c) {
      c === void 0 && (c = i), Object.defineProperty(t, c, { enumerable: !0, get: function() {
        return g[i];
      } });
    } : function(t, g, i, c) {
      c === void 0 && (c = i), t[c] = g[i];
    }), n = Lr.__exportStar || function(t, g) {
      for (var i in t) i !== "default" && !Object.prototype.hasOwnProperty.call(g, i) && r(g, t, i);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), n(wf(), e), n(yf(), e), n(bf(), e), n(Ml(), e), n(Il(), e), n(Sf(), e);
  }(Lr)), Lr;
}
var vs = {}, cn = {};
const no = /* @__PURE__ */ $r(Ll);
var ln = {}, Rc;
function Al() {
  if (Rc) return ln;
  Rc = 1, Object.defineProperty(ln, "__esModule", { value: !0 });
  var e = no, r = (
    /** @class */
    function() {
      function n(t) {
        if (this._maxConcurrency = t, this._queue = [], t <= 0)
          throw new Error("semaphore must be initialized to a positive value");
        this._value = t;
      }
      return n.prototype.acquire = function() {
        var t = this, g = this.isLocked(), i = new Promise(function(c) {
          return t._queue.push(c);
        });
        return g || this._dispatch(), i;
      }, n.prototype.runExclusive = function(t) {
        return e.__awaiter(this, void 0, void 0, function() {
          var g, i, c;
          return e.__generator(this, function(a) {
            switch (a.label) {
              case 0:
                return [4, this.acquire()];
              case 1:
                g = a.sent(), i = g[0], c = g[1], a.label = 2;
              case 2:
                return a.trys.push([2, , 4, 5]), [4, t(i)];
              case 3:
                return [2, a.sent()];
              case 4:
                return c(), [
                  7
                  /*endfinally*/
                ];
              case 5:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, n.prototype.isLocked = function() {
        return this._value <= 0;
      }, n.prototype.release = function() {
        if (this._maxConcurrency > 1)
          throw new Error("this method is unavailabel on semaphores with concurrency > 1; use the scoped release returned by acquire instead");
        if (this._currentReleaser) {
          var t = this._currentReleaser;
          this._currentReleaser = void 0, t();
        }
      }, n.prototype._dispatch = function() {
        var t = this, g = this._queue.shift();
        if (g) {
          var i = !1;
          this._currentReleaser = function() {
            i || (i = !0, t._value++, t._dispatch());
          }, g([this._value--, this._currentReleaser]);
        }
      }, n;
    }()
  );
  return ln.default = r, ln;
}
var Sc;
function Cf() {
  if (Sc) return cn;
  Sc = 1, Object.defineProperty(cn, "__esModule", { value: !0 });
  var e = no, r = Al(), n = (
    /** @class */
    function() {
      function t() {
        this._semaphore = new r.default(1);
      }
      return t.prototype.acquire = function() {
        return e.__awaiter(this, void 0, void 0, function() {
          var g, i;
          return e.__generator(this, function(c) {
            switch (c.label) {
              case 0:
                return [4, this._semaphore.acquire()];
              case 1:
                return g = c.sent(), i = g[1], [2, i];
            }
          });
        });
      }, t.prototype.runExclusive = function(g) {
        return this._semaphore.runExclusive(function() {
          return g();
        });
      }, t.prototype.isLocked = function() {
        return this._semaphore.isLocked();
      }, t.prototype.release = function() {
        this._semaphore.release();
      }, t;
    }()
  );
  return cn.default = n, cn;
}
var qr = {}, Cc;
function Mf() {
  if (Cc) return qr;
  Cc = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.withTimeout = void 0;
  var e = no;
  function r(n, t, g) {
    var i = this;
    return g === void 0 && (g = new Error("timeout")), {
      acquire: function() {
        return new Promise(function(c, a) {
          return e.__awaiter(i, void 0, void 0, function() {
            var d, m, p;
            return e.__generator(this, function(o) {
              switch (o.label) {
                case 0:
                  return d = !1, setTimeout(function() {
                    d = !0, a(g);
                  }, t), [4, n.acquire()];
                case 1:
                  return m = o.sent(), d ? (p = Array.isArray(m) ? m[1] : m, p()) : c(m), [
                    2
                    /*return*/
                  ];
              }
            });
          });
        });
      },
      runExclusive: function(c) {
        return e.__awaiter(this, void 0, void 0, function() {
          var a, d;
          return e.__generator(this, function(m) {
            switch (m.label) {
              case 0:
                a = function() {
                }, m.label = 1;
              case 1:
                return m.trys.push([1, , 7, 8]), [4, this.acquire()];
              case 2:
                return d = m.sent(), Array.isArray(d) ? (a = d[1], [4, c(d[0])]) : [3, 4];
              case 3:
                return [2, m.sent()];
              case 4:
                return a = d, [4, c()];
              case 5:
                return [2, m.sent()];
              case 6:
                return [3, 8];
              case 7:
                return a(), [
                  7
                  /*endfinally*/
                ];
              case 8:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      },
      release: function() {
        n.release();
      },
      isLocked: function() {
        return n.isLocked();
      }
    };
  }
  return qr.withTimeout = r, qr;
}
var Mc;
function kf() {
  return Mc || (Mc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.withTimeout = e.Semaphore = e.Mutex = void 0;
    var r = Cf();
    Object.defineProperty(e, "Mutex", { enumerable: !0, get: function() {
      return r.default;
    } });
    var n = Al();
    Object.defineProperty(e, "Semaphore", { enumerable: !0, get: function() {
      return n.default;
    } });
    var t = Mf();
    Object.defineProperty(e, "withTimeout", { enumerable: !0, get: function() {
      return t.withTimeout;
    } });
  }(vs)), vs;
}
var _s, kc;
function If() {
  if (kc) return _s;
  kc = 1, _s = r;
  var e = Object.prototype.hasOwnProperty;
  function r() {
    for (var n = {}, t = 0; t < arguments.length; t++) {
      var g = arguments[t];
      for (var i in g)
        e.call(g, i) && (n[i] = g[i]);
    }
    return n;
  }
  return _s;
}
var Es, Ic;
function xf() {
  if (Ic) return Es;
  Ic = 1;
  const e = If(), r = Hs()();
  Es = n;
  function n(c) {
    const a = this;
    a.currentProvider = c;
  }
  n.prototype.getBalance = g(2, "eth_getBalance"), n.prototype.getCode = g(2, "eth_getCode"), n.prototype.getTransactionCount = g(2, "eth_getTransactionCount"), n.prototype.getStorageAt = g(3, "eth_getStorageAt"), n.prototype.call = g(2, "eth_call"), n.prototype.protocolVersion = t("eth_protocolVersion"), n.prototype.syncing = t("eth_syncing"), n.prototype.coinbase = t("eth_coinbase"), n.prototype.mining = t("eth_mining"), n.prototype.hashrate = t("eth_hashrate"), n.prototype.gasPrice = t("eth_gasPrice"), n.prototype.accounts = t("eth_accounts"), n.prototype.blockNumber = t("eth_blockNumber"), n.prototype.getBlockTransactionCountByHash = t("eth_getBlockTransactionCountByHash"), n.prototype.getBlockTransactionCountByNumber = t("eth_getBlockTransactionCountByNumber"), n.prototype.getUncleCountByBlockHash = t("eth_getUncleCountByBlockHash"), n.prototype.getUncleCountByBlockNumber = t("eth_getUncleCountByBlockNumber"), n.prototype.sign = t("eth_sign"), n.prototype.sendTransaction = t("eth_sendTransaction"), n.prototype.sendRawTransaction = t("eth_sendRawTransaction"), n.prototype.estimateGas = t("eth_estimateGas"), n.prototype.getBlockByHash = t("eth_getBlockByHash"), n.prototype.getBlockByNumber = t("eth_getBlockByNumber"), n.prototype.getTransactionByHash = t("eth_getTransactionByHash"), n.prototype.getTransactionByBlockHashAndIndex = t("eth_getTransactionByBlockHashAndIndex"), n.prototype.getTransactionByBlockNumberAndIndex = t("eth_getTransactionByBlockNumberAndIndex"), n.prototype.getTransactionReceipt = t("eth_getTransactionReceipt"), n.prototype.getUncleByBlockHashAndIndex = t("eth_getUncleByBlockHashAndIndex"), n.prototype.getUncleByBlockNumberAndIndex = t("eth_getUncleByBlockNumberAndIndex"), n.prototype.getCompilers = t("eth_getCompilers"), n.prototype.compileLLL = t("eth_compileLLL"), n.prototype.compileSolidity = t("eth_compileSolidity"), n.prototype.compileSerpent = t("eth_compileSerpent"), n.prototype.newFilter = t("eth_newFilter"), n.prototype.newBlockFilter = t("eth_newBlockFilter"), n.prototype.newPendingTransactionFilter = t("eth_newPendingTransactionFilter"), n.prototype.uninstallFilter = t("eth_uninstallFilter"), n.prototype.getFilterChanges = t("eth_getFilterChanges"), n.prototype.getFilterLogs = t("eth_getFilterLogs"), n.prototype.getLogs = t("eth_getLogs"), n.prototype.getWork = t("eth_getWork"), n.prototype.submitWork = t("eth_submitWork"), n.prototype.submitHashrate = t("eth_submitHashrate"), n.prototype.sendAsync = function(c, a) {
    this.currentProvider.sendAsync(i(c), function(m, p) {
      if (!m && p.error && (m = new Error("EthQuery - RPC Error - " + p.error.message)), m) return a(m);
      a(null, p.result);
    });
  };
  function t(c) {
    return function() {
      const a = this;
      var d = [].slice.call(arguments), m = d.pop();
      a.sendAsync({
        method: c,
        params: d
      }, m);
    };
  }
  function g(c, a) {
    return function() {
      const d = this;
      var m = [].slice.call(arguments), p = m.pop();
      m.length < c && m.push("latest"), d.sendAsync({
        method: a,
        params: m
      }, p);
    };
  }
  function i(c) {
    return e({
      // defaults
      id: r(),
      jsonrpc: "2.0",
      params: []
      // user-specified
    }, c);
  }
  return Es;
}
var Rs, xc;
function Af() {
  if (xc) return Rs;
  xc = 1;
  const e = (n, t, g, i) => function(...c) {
    const a = t.promiseModule;
    return new a((d, m) => {
      t.multiArgs ? c.push((...o) => {
        t.errorFirst ? o[0] ? m(o) : (o.shift(), d(o)) : d(o);
      }) : t.errorFirst ? c.push((o, l) => {
        o ? m(o) : d(l);
      }) : c.push(d), Reflect.apply(n, this === g ? i : this, c);
    });
  }, r = /* @__PURE__ */ new WeakMap();
  return Rs = (n, t) => {
    t = {
      exclude: [/.+(?:Sync|Stream)$/],
      errorFirst: !0,
      promiseModule: Promise,
      ...t
    };
    const g = typeof n;
    if (!(n !== null && (g === "object" || g === "function")))
      throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${n === null ? "null" : g}\``);
    const i = (d, m) => {
      let p = r.get(d);
      if (p || (p = {}, r.set(d, p)), m in p)
        return p[m];
      const o = (y) => typeof y == "string" || typeof m == "symbol" ? m === y : y.test(m), l = Reflect.getOwnPropertyDescriptor(d, m), s = l === void 0 || l.writable || l.configurable, b = (t.include ? t.include.some(o) : !t.exclude.some(o)) && s;
      return p[m] = b, b;
    }, c = /* @__PURE__ */ new WeakMap(), a = new Proxy(n, {
      apply(d, m, p) {
        const o = c.get(d);
        if (o)
          return Reflect.apply(o, m, p);
        const l = t.excludeMain ? d : e(d, t, a, d);
        return c.set(d, l), Reflect.apply(l, m, p);
      },
      get(d, m) {
        const p = d[m];
        if (!i(d, m) || p === Function.prototype[m])
          return p;
        const o = c.get(p);
        if (o)
          return o;
        if (typeof p == "function") {
          const l = e(p, t, a, d);
          return c.set(p, l), l;
        }
        return p;
      }
    });
    return a;
  }, Rs;
}
var Ss, Ac;
function io() {
  if (Ac) return Ss;
  Ac = 1;
  const e = Ws().default;
  class r extends e {
    constructor() {
      super(), this.updates = [];
    }
    async initialize() {
    }
    async update() {
      throw new Error("BaseFilter - no update method specified");
    }
    addResults(t) {
      this.updates = this.updates.concat(t), t.forEach((g) => this.emit("update", g));
    }
    addInitialResults(t) {
    }
    getChangesAndClear() {
      const t = this.updates;
      return this.updates = [], t;
    }
  }
  return Ss = r, Ss;
}
var Cs, Tc;
function Tf() {
  if (Tc) return Cs;
  Tc = 1;
  const e = io();
  class r extends e {
    constructor() {
      super(), this.allResults = [];
    }
    async update() {
      throw new Error("BaseFilterWithHistory - no update method specified");
    }
    addResults(t) {
      this.allResults = this.allResults.concat(t), super.addResults(t);
    }
    addInitialResults(t) {
      this.allResults = this.allResults.concat(t), super.addInitialResults(t);
    }
    getAllResults() {
      return this.allResults;
    }
  }
  return Cs = r, Cs;
}
var Ms, Lc;
function zr() {
  if (Lc) return Ms;
  Lc = 1, Ms = {
    minBlockRef: e,
    maxBlockRef: r,
    sortBlockRefs: n,
    bnToHex: t,
    blockRefIsNumber: g,
    hexToInt: i,
    incrementHexInt: c,
    intToHex: a,
    unsafeRandomBytes: d
  };
  function e(...p) {
    return n(p)[0];
  }
  function r(...p) {
    const o = n(p);
    return o[o.length - 1];
  }
  function n(p) {
    return p.sort((o, l) => o === "latest" || l === "earliest" ? 1 : l === "latest" || o === "earliest" ? -1 : i(o) - i(l));
  }
  function t(p) {
    return "0x" + p.toString(16);
  }
  function g(p) {
    return p && !["earliest", "latest", "pending"].includes(p);
  }
  function i(p) {
    return p == null ? p : Number.parseInt(p, 16);
  }
  function c(p) {
    if (p == null) return p;
    const o = i(p);
    return a(o + 1);
  }
  function a(p) {
    if (p == null) return p;
    let o = p.toString(16);
    return o.length % 2 && (o = "0" + o), "0x" + o;
  }
  function d(p) {
    let o = "0x";
    for (let l = 0; l < p; l++)
      o += m(), o += m();
    return o;
  }
  function m() {
    return Math.floor(Math.random() * 16).toString(16);
  }
  return Ms;
}
var ks, Bc;
function Lf() {
  if (Bc) return ks;
  Bc = 1;
  const e = xf(), r = Af(), n = Tf(), { bnToHex: t, hexToInt: g, incrementHexInt: i, minBlockRef: c, blockRefIsNumber: a } = zr();
  class d extends n {
    constructor({ provider: p, params: o }) {
      super(), this.type = "log", this.ethQuery = new e(p), this.params = Object.assign({
        fromBlock: "latest",
        toBlock: "latest",
        address: void 0,
        topics: []
      }, o), this.params.address && (Array.isArray(this.params.address) || (this.params.address = [this.params.address]), this.params.address = this.params.address.map((l) => l.toLowerCase()));
    }
    async initialize({ currentBlock: p }) {
      let o = this.params.fromBlock;
      ["latest", "pending"].includes(o) && (o = p), o === "earliest" && (o = "0x0"), this.params.fromBlock = o;
      const l = c(this.params.toBlock, p), s = Object.assign({}, this.params, { toBlock: l }), f = await this._fetchLogs(s);
      this.addInitialResults(f);
    }
    async update({ oldBlock: p, newBlock: o }) {
      const l = o;
      let s;
      p ? s = i(p) : s = o;
      const f = Object.assign({}, this.params, { fromBlock: s, toBlock: l }), y = (await this._fetchLogs(f)).filter((u) => this.matchLog(u));
      this.addResults(y);
    }
    async _fetchLogs(p) {
      return await r((l) => this.ethQuery.getLogs(p, l))();
    }
    matchLog(p) {
      if (g(this.params.fromBlock) >= g(p.blockNumber) || a(this.params.toBlock) && g(this.params.toBlock) <= g(p.blockNumber)) return !1;
      const o = p.address && p.address.toLowerCase();
      return this.params.address && o && !this.params.address.includes(o) ? !1 : this.params.topics.every((s, f) => {
        let b = p.topics[f];
        if (!b) return !1;
        b = b.toLowerCase();
        let y = Array.isArray(s) ? s : [s];
        return y.includes(null) ? !0 : (y = y.map((S) => S.toLowerCase()), y.includes(b));
      });
    }
  }
  return ks = d, ks;
}
var Is, Nc;
function so() {
  if (Nc) return Is;
  Nc = 1, Is = e;
  async function e({ provider: i, fromBlock: c, toBlock: a }) {
    c || (c = a);
    const d = r(c), p = r(a) - d + 1, o = Array(p).fill().map((s, f) => d + f).map(n);
    let l = await Promise.all(
      o.map((s) => g(i, "eth_getBlockByNumber", [s, !1]))
    );
    return l = l.filter((s) => s !== null), l;
  }
  function r(i) {
    return i == null ? i : Number.parseInt(i, 16);
  }
  function n(i) {
    return i == null ? i : "0x" + i.toString(16);
  }
  function t(i, c) {
    return new Promise((a, d) => {
      i.sendAsync(c, (m, p) => {
        m ? d(m) : p.error ? d(p.error) : p.result ? a(p.result) : d(new Error("Result was empty"));
      });
    });
  }
  async function g(i, c, a) {
    for (let d = 0; d < 3; d++)
      try {
        return await t(i, {
          id: 1,
          jsonrpc: "2.0",
          method: c,
          params: a
        });
      } catch (m) {
        console.error(
          `provider.sendAsync failed: ${m.stack || m.message || m}`
        );
      }
    return null;
  }
  return Is;
}
var xs, Pc;
function Bf() {
  if (Pc) return xs;
  Pc = 1;
  const e = io(), r = so(), { incrementHexInt: n } = zr();
  class t extends e {
    constructor({ provider: i, params: c }) {
      super(), this.type = "block", this.provider = i;
    }
    async update({ oldBlock: i, newBlock: c }) {
      const a = c, d = n(i), p = (await r({ provider: this.provider, fromBlock: d, toBlock: a })).map((o) => o.hash);
      this.addResults(p);
    }
  }
  return xs = t, xs;
}
var As, Oc;
function Nf() {
  if (Oc) return As;
  Oc = 1;
  const e = io(), r = so(), { incrementHexInt: n } = zr();
  class t extends e {
    constructor({ provider: i }) {
      super(), this.type = "tx", this.provider = i;
    }
    async update({ oldBlock: i }) {
      const c = i, a = n(i), d = await r({ provider: this.provider, fromBlock: a, toBlock: c }), m = [];
      for (const p of d)
        m.push(...p.transactions);
      this.addResults(m);
    }
  }
  return As = t, As;
}
var Ts, Fc;
function Pf() {
  if (Fc) return Ts;
  Fc = 1;
  const e = kf().Mutex, { createAsyncMiddleware: r, createScaffoldMiddleware: n } = xl(), t = Lf(), g = Bf(), i = Nf(), { intToHex: c, hexToInt: a } = zr();
  Ts = d;
  function d({ blockTracker: s, provider: f }) {
    let b = 0, y = {};
    const u = new e(), R = o({ mutex: u }), S = n({
      // install filters
      eth_newFilter: R(m(T)),
      eth_newBlockFilter: R(m(q)),
      eth_newPendingTransactionFilter: R(m(D)),
      // uninstall filters
      eth_uninstallFilter: R(p(X)),
      // checking filter changes
      eth_getFilterChanges: R(p(H)),
      eth_getFilterLogs: R(p(G))
    }), I = async ({ oldBlock: E, newBlock: C }) => {
      if (y.length === 0) return;
      const M = await u.acquire();
      try {
        await Promise.all(l(y).map(async (x) => {
          try {
            await x.update({ oldBlock: E, newBlock: C });
          } catch (B) {
            console.error(B);
          }
        }));
      } catch (x) {
        console.error(x);
      }
      M();
    };
    return S.newLogFilter = T, S.newBlockFilter = q, S.newPendingTransactionFilter = D, S.uninstallFilter = X, S.getFilterChanges = H, S.getFilterLogs = G, S.destroy = () => {
      F();
    }, S;
    async function T(E) {
      const C = new t({ provider: f, params: E });
      return await Y(C), C;
    }
    async function q() {
      const E = new g({ provider: f });
      return await Y(E), E;
    }
    async function D() {
      const E = new i({ provider: f });
      return await Y(E), E;
    }
    async function H(E) {
      const C = a(E), M = y[C];
      if (!M)
        throw new Error(`No filter for index "${C}"`);
      return M.getChangesAndClear();
    }
    async function G(E) {
      const C = a(E), M = y[C];
      if (!M)
        throw new Error(`No filter for index "${C}"`);
      let x = [];
      return M.type === "log" && (x = M.getAllResults()), x;
    }
    async function X(E) {
      const C = a(E), x = !!y[C];
      return x && await re(C), x;
    }
    async function Y(E) {
      const C = l(y).length, M = await s.getLatestBlock();
      await E.initialize({ currentBlock: M }), b++, y[b] = E, E.id = b, E.idHex = c(b);
      const x = l(y).length;
      return h({ prevFilterCount: C, newFilterCount: x }), b;
    }
    async function re(E) {
      const C = l(y).length;
      delete y[E];
      const M = l(y).length;
      h({ prevFilterCount: C, newFilterCount: M });
    }
    async function F() {
      const E = l(y).length;
      y = {}, h({ prevFilterCount: E, newFilterCount: 0 });
    }
    function h({ prevFilterCount: E, newFilterCount: C }) {
      if (E === 0 && C > 0) {
        s.on("sync", I);
        return;
      }
      if (E > 0 && C === 0) {
        s.removeListener("sync", I);
        return;
      }
    }
  }
  function m(s) {
    return p(async (...f) => {
      const b = await s(...f);
      return c(b.id);
    });
  }
  function p(s) {
    return r(async (f, b) => {
      const y = await s.apply(null, f.params);
      b.result = y;
    });
  }
  function o({ mutex: s }) {
    return (f) => async (b, y, u, R) => {
      (await s.acquire())(), f(b, y, u, R);
    };
  }
  function l(s, f) {
    const b = [];
    for (let y in s)
      b.push(s[y]);
    return b;
  }
  return Ts;
}
var Ls, Dc;
function Of() {
  if (Dc) return Ls;
  Dc = 1;
  const e = Ws().default, { createAsyncMiddleware: r, createScaffoldMiddleware: n } = xl(), t = Pf(), { unsafeRandomBytes: g, incrementHexInt: i } = zr(), c = so();
  Ls = a;
  function a({ blockTracker: m, provider: p }) {
    const o = {}, l = t({ blockTracker: m, provider: p });
    let s = !1;
    const f = new e(), b = n({
      eth_subscribe: r(y),
      eth_unsubscribe: r(u)
    });
    return b.destroy = S, { events: f, middleware: b };
    async function y(I, T) {
      if (s) throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
      const q = I.params[0], D = g(16);
      let H;
      switch (q) {
        case "newHeads":
          H = G({ subId: D });
          break;
        case "logs":
          const Y = I.params[1], re = await l.newLogFilter(Y);
          H = X({ subId: D, filter: re });
          break;
        default:
          throw new Error(`SubscriptionManager - unsupported subscription type "${q}"`);
      }
      o[D] = H, T.result = D;
      return;
      function G({ subId: Y }) {
        const re = {
          type: q,
          destroy: async () => {
            m.removeListener("sync", re.update);
          },
          update: async ({ oldBlock: F, newBlock: h }) => {
            const E = h, C = i(F);
            (await c({ provider: p, fromBlock: C, toBlock: E })).map(d).filter((B) => B !== null).forEach((B) => {
              R(Y, B);
            });
          }
        };
        return m.on("sync", re.update), re;
      }
      function X({ subId: Y, filter: re }) {
        return re.on("update", (h) => R(Y, h)), {
          type: q,
          destroy: async () => await l.uninstallFilter(re.idHex)
        };
      }
    }
    async function u(I, T) {
      if (s) throw new Error(
        "SubscriptionManager - attempting to use after destroying"
      );
      const q = I.params[0], D = o[q];
      if (!D) {
        T.result = !1;
        return;
      }
      delete o[q], await D.destroy(), T.result = !0;
    }
    function R(I, T) {
      f.emit("notification", {
        jsonrpc: "2.0",
        method: "eth_subscription",
        params: {
          subscription: I,
          result: T
        }
      });
    }
    function S() {
      f.removeAllListeners();
      for (const I in o)
        o[I].destroy(), delete o[I];
      s = !0;
    }
  }
  function d(m) {
    return m == null ? null : {
      hash: m.hash,
      parentHash: m.parentHash,
      sha3Uncles: m.sha3Uncles,
      miner: m.miner,
      stateRoot: m.stateRoot,
      transactionsRoot: m.transactionsRoot,
      receiptsRoot: m.receiptsRoot,
      logsBloom: m.logsBloom,
      difficulty: m.difficulty,
      number: m.number,
      gasLimit: m.gasLimit,
      gasUsed: m.gasUsed,
      nonce: m.nonce,
      mixHash: m.mixHash,
      timestamp: m.timestamp,
      extraData: m.extraData
    };
  }
  return Ls;
}
var qc;
function Ff() {
  if (qc) return kr;
  qc = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.SubscriptionManager = void 0;
  const e = mf(), r = Of(), n = () => {
  };
  let t = class {
    constructor(i) {
      const c = new e.PollingBlockTracker({
        provider: i,
        pollingInterval: 15e3,
        setSkipCacheFlag: !0
      }), { events: a, middleware: d } = r({
        blockTracker: c,
        provider: i
      });
      this.events = a, this.subscriptionMiddleware = d;
    }
    async handleRequest(i) {
      const c = {};
      return await this.subscriptionMiddleware(i, c, n, n), c;
    }
    destroy() {
      this.subscriptionMiddleware.destroy();
    }
  };
  return kr.SubscriptionManager = t, kr;
}
var jc;
function Ns() {
  if (jc) return Dt;
  jc = 1;
  var e = Dt.__importDefault || function(y) {
    return y && y.__esModule ? y : { default: y };
  };
  Object.defineProperty(Dt, "__esModule", { value: !0 }), Dt.CoinbaseWalletProvider = void 0;
  const r = e(fn()), n = Bl(), t = /* @__PURE__ */ gn(), g = /* @__PURE__ */ tt(), i = /* @__PURE__ */ el(), c = /* @__PURE__ */ js(), a = /* @__PURE__ */ $s(), d = /* @__PURE__ */ Fs(), m = e(/* @__PURE__ */ Oh()), p = /* @__PURE__ */ qs(), o = /* @__PURE__ */ Fh(), l = /* @__PURE__ */ Ff(), s = "DefaultChainId", f = "DefaultJsonRpcUrl";
  let b = class extends n.EventEmitter {
    constructor(u) {
      var R, S;
      super(), this._filterPolyfill = new o.FilterPolyfill(this), this._subscriptionManager = new l.SubscriptionManager(this), this._relay = null, this._addresses = [], this.hasMadeFirstChainChangedEmission = !1, this.setProviderInfo = this.setProviderInfo.bind(this), this.updateProviderInfo = this.updateProviderInfo.bind(this), this.getChainId = this.getChainId.bind(this), this.setAppInfo = this.setAppInfo.bind(this), this.enable = this.enable.bind(this), this.close = this.close.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this.request = this.request.bind(this), this._setAddresses = this._setAddresses.bind(this), this.scanQRCode = this.scanQRCode.bind(this), this.genericRequest = this.genericRequest.bind(this), this._chainIdFromOpts = u.chainId, this._jsonRpcUrlFromOpts = u.jsonRpcUrl, this._overrideIsMetaMask = u.overrideIsMetaMask, this._relayProvider = u.relayProvider, this._storage = u.storage, this._relayEventManager = u.relayEventManager, this.diagnostic = u.diagnosticLogger, this.reloadOnDisconnect = !0, this.isCoinbaseWallet = (R = u.overrideIsCoinbaseWallet) !== null && R !== void 0 ? R : !0, this.isCoinbaseBrowser = (S = u.overrideIsCoinbaseBrowser) !== null && S !== void 0 ? S : !1, this.qrUrl = u.qrUrl;
      const I = this.getChainId(), T = (0, g.prepend0x)(I.toString(16));
      this.emit("connect", { chainIdStr: T });
      const q = this._storage.getItem(c.LOCAL_STORAGE_ADDRESSES_KEY);
      if (q) {
        const D = q.split(" ");
        D[0] !== "" && (this._addresses = D.map((H) => (0, g.ensureAddressString)(H)), this.emit("accountsChanged", D));
      }
      this._subscriptionManager.events.on("notification", (D) => {
        this.emit("message", {
          type: D.method,
          data: D.params
        });
      }), this._isAuthorized() && this.initializeRelay(), window.addEventListener("message", (D) => {
        var H;
        if (!(D.origin !== location.origin || D.source !== window) && D.data.type === "walletLinkMessage" && D.data.data.action === "dappChainSwitched") {
          const G = D.data.data.chainId, X = (H = D.data.data.jsonRpcUrl) !== null && H !== void 0 ? H : this.jsonRpcUrl;
          this.updateProviderInfo(X, Number(G));
        }
      });
    }
    /** @deprecated Use `.request({ method: 'eth_accounts' })` instead. */
    get selectedAddress() {
      return this._addresses[0] || void 0;
    }
    /** @deprecated Use the chain ID. If you still need the network ID, use `.request({ method: 'net_version' })`. */
    get networkVersion() {
      return this.getChainId().toString(10);
    }
    /** @deprecated Use `.request({ method: 'eth_chainId' })` instead. */
    get chainId() {
      return (0, g.prepend0x)(this.getChainId().toString(16));
    }
    get isWalletLink() {
      return !0;
    }
    /**
     * Some DApps (i.e. Alpha Homora) seem to require the window.ethereum object return
     * true for this method.
     */
    get isMetaMask() {
      return this._overrideIsMetaMask;
    }
    get host() {
      return this.jsonRpcUrl;
    }
    get connected() {
      return !0;
    }
    isConnected() {
      return !0;
    }
    get jsonRpcUrl() {
      var u;
      return (u = this._storage.getItem(f)) !== null && u !== void 0 ? u : this._jsonRpcUrlFromOpts;
    }
    set jsonRpcUrl(u) {
      this._storage.setItem(f, u);
    }
    disableReloadOnDisconnect() {
      this.reloadOnDisconnect = !1;
    }
    setProviderInfo(u, R) {
      this.isCoinbaseBrowser || (this._chainIdFromOpts = R, this._jsonRpcUrlFromOpts = u), this.updateProviderInfo(this.jsonRpcUrl, this.getChainId());
    }
    updateProviderInfo(u, R) {
      this.jsonRpcUrl = u;
      const S = this.getChainId();
      this._storage.setItem(s, R.toString(10)), ((0, g.ensureIntNumber)(R) !== S || !this.hasMadeFirstChainChangedEmission) && (this.emit("chainChanged", this.getChainId()), this.hasMadeFirstChainChangedEmission = !0);
    }
    async watchAsset(u, R, S, I, T, q) {
      const H = await (await this.initializeRelay()).watchAsset(u, R, S, I, T, q == null ? void 0 : q.toString()).promise;
      return (0, d.isErrorResponse)(H) ? !1 : !!H.result;
    }
    async addEthereumChain(u, R, S, I, T, q) {
      var D, H;
      if ((0, g.ensureIntNumber)(u) === this.getChainId())
        return !1;
      const G = await this.initializeRelay(), X = G.inlineAddEthereumChain(u.toString());
      !this._isAuthorized() && !X && await G.requestEthereumAccounts().promise;
      const Y = await G.addEthereumChain(u.toString(), R, T, S, I, q).promise;
      return (0, d.isErrorResponse)(Y) ? !1 : (((D = Y.result) === null || D === void 0 ? void 0 : D.isApproved) === !0 && this.updateProviderInfo(R[0], u), ((H = Y.result) === null || H === void 0 ? void 0 : H.isApproved) === !0);
    }
    async switchEthereumChain(u) {
      const S = await (await this.initializeRelay()).switchEthereumChain(u.toString(10), this.selectedAddress || void 0).promise;
      if ((0, d.isErrorResponse)(S)) {
        if (!S.errorCode)
          return;
        throw S.errorCode === t.standardErrorCodes.provider.unsupportedChain ? t.standardErrors.provider.unsupportedChain() : t.standardErrors.provider.custom({
          message: S.errorMessage,
          code: S.errorCode
        });
      }
      const I = S.result;
      I.isApproved && I.rpcUrl.length > 0 && this.updateProviderInfo(I.rpcUrl, u);
    }
    setAppInfo(u, R) {
      this.initializeRelay().then((S) => S.setAppInfo(u, R));
    }
    /** @deprecated Use `.request({ method: 'eth_requestAccounts' })` instead. */
    async enable() {
      var u;
      return (u = this.diagnostic) === null || u === void 0 || u.log(p.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::enable",
        addresses_length: this._addresses.length,
        sessionIdHash: this._relay ? a.Session.hash(this._relay.session.id) : void 0
      }), this._isAuthorized() ? [...this._addresses] : await this.send("eth_requestAccounts");
    }
    async close() {
      (await this.initializeRelay()).resetAndReload();
    }
    send(u, R) {
      try {
        const S = this._send(u, R);
        if (S instanceof Promise)
          return S.catch((I) => {
            throw (0, t.serializeError)(I, u);
          });
      } catch (S) {
        throw (0, t.serializeError)(S, u);
      }
    }
    _send(u, R) {
      if (typeof u == "string") {
        const I = u, T = Array.isArray(R) ? R : R !== void 0 ? [R] : [], q = {
          jsonrpc: "2.0",
          id: 0,
          method: I,
          params: T
        };
        return this._sendRequestAsync(q).then((D) => D.result);
      }
      if (typeof R == "function") {
        const I = u, T = R;
        return this._sendAsync(I, T);
      }
      if (Array.isArray(u))
        return u.map((T) => this._sendRequest(T));
      const S = u;
      return this._sendRequest(S);
    }
    async sendAsync(u, R) {
      try {
        return this._sendAsync(u, R).catch((S) => {
          throw (0, t.serializeError)(S, u);
        });
      } catch (S) {
        return Promise.reject((0, t.serializeError)(S, u));
      }
    }
    async _sendAsync(u, R) {
      if (typeof R != "function")
        throw new Error("callback is required");
      if (Array.isArray(u)) {
        const I = R;
        this._sendMultipleRequestsAsync(u).then((T) => I(null, T)).catch((T) => I(T, null));
        return;
      }
      const S = R;
      return this._sendRequestAsync(u).then((I) => S(null, I)).catch((I) => S(I, null));
    }
    async request(u) {
      try {
        return this._request(u).catch((R) => {
          throw (0, t.serializeError)(R, u.method);
        });
      } catch (R) {
        return Promise.reject((0, t.serializeError)(R, u.method));
      }
    }
    async _request(u) {
      if (!u || typeof u != "object" || Array.isArray(u))
        throw t.standardErrors.rpc.invalidRequest({
          message: "Expected a single, non-array, object argument.",
          data: u
        });
      const { method: R, params: S } = u;
      if (typeof R != "string" || R.length === 0)
        throw t.standardErrors.rpc.invalidRequest({
          message: "'args.method' must be a non-empty string.",
          data: u
        });
      if (S !== void 0 && !Array.isArray(S) && (typeof S != "object" || S === null))
        throw t.standardErrors.rpc.invalidRequest({
          message: "'args.params' must be an object or array if provided.",
          data: u
        });
      const I = S === void 0 ? [] : S, T = this._relayEventManager.makeRequestId();
      return (await this._sendRequestAsync({
        method: R,
        params: I,
        jsonrpc: "2.0",
        id: T
      })).result;
    }
    async scanQRCode(u) {
      const S = await (await this.initializeRelay()).scanQRCode((0, g.ensureRegExpString)(u)).promise;
      if ((0, d.isErrorResponse)(S))
        throw (0, t.serializeError)(S.errorMessage, "scanQRCode");
      if (typeof S.result != "string")
        throw (0, t.serializeError)("result was not a string", "scanQRCode");
      return S.result;
    }
    async genericRequest(u, R) {
      const I = await (await this.initializeRelay()).genericRequest(u, R).promise;
      if ((0, d.isErrorResponse)(I))
        throw (0, t.serializeError)(I.errorMessage, "generic");
      if (typeof I.result != "string")
        throw (0, t.serializeError)("result was not a string", "generic");
      return I.result;
    }
    /**
     * @beta
     * This method is currently in beta. While it is available for use, please note that it is still under testing and may undergo significant changes.
     *
     * @remarks
     * IMPORTANT: Signature validation is not performed by this method. Users of this method are advised to perform their own signature validation.
     * Common web3 frontend libraries such as ethers.js and viem provide the `verifyMessage` utility function that can be used for signature validation.
     *
     * It combines `eth_requestAccounts` and "Sign-In with Ethereum" (EIP-4361) into a single call.
     * The returned account and signed message can be used to authenticate the user.
     *
     * @param {Object} params - An object with the following properties:
     * - `nonce` {string}: A unique string to prevent replay attacks.
     * - `statement` {string}: An optional human-readable ASCII assertion that the user will sign.
     * - `resources` {string[]}: An optional list of information the user wishes to have resolved as part of authentication by the relying party.
     *
     * @returns {Promise<ConnectAndSignInResponse>} A promise that resolves to an object with the following properties:
     * - `accounts` {string[]}: The Ethereum accounts of the user.
     * - `message` {string}: The overall message that the user signed. Hex encoded.
     * - `signature` {string}: The signature of the message, signed with the user's private key. Hex encoded.
     */
    async connectAndSignIn(u) {
      var R;
      (R = this.diagnostic) === null || R === void 0 || R.log(p.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::connectAndSignIn",
        sessionIdHash: this._relay ? a.Session.hash(this._relay.session.id) : void 0
      });
      let S;
      try {
        const T = await this.initializeRelay();
        if (!(T instanceof i.MobileRelay))
          throw new Error("connectAndSignIn is only supported on mobile");
        if (S = await T.connectAndSignIn(u).promise, (0, d.isErrorResponse)(S))
          throw new Error(S.errorMessage);
      } catch (T) {
        throw typeof T.message == "string" && T.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied account authorization") : T;
      }
      if (!S.result)
        throw new Error("accounts received is empty");
      const { accounts: I } = S.result;
      return this._setAddresses(I), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), S.result;
    }
    async selectProvider(u) {
      const S = await (await this.initializeRelay()).selectProvider(u).promise;
      if ((0, d.isErrorResponse)(S))
        throw (0, t.serializeError)(S.errorMessage, "selectProvider");
      if (typeof S.result != "string")
        throw (0, t.serializeError)("result was not a string", "selectProvider");
      return S.result;
    }
    supportsSubscriptions() {
      return !1;
    }
    subscribe() {
      throw new Error("Subscriptions are not supported");
    }
    unsubscribe() {
      throw new Error("Subscriptions are not supported");
    }
    disconnect() {
      return !0;
    }
    _sendRequest(u) {
      const R = {
        jsonrpc: "2.0",
        id: u.id
      }, { method: S } = u;
      if (R.result = this._handleSynchronousMethods(u), R.result === void 0)
        throw new Error(`Coinbase Wallet does not support calling ${S} synchronously without a callback. Please provide a callback parameter to call ${S} asynchronously.`);
      return R;
    }
    _setAddresses(u, R) {
      if (!Array.isArray(u))
        throw new Error("addresses is not an array");
      const S = u.map((I) => (0, g.ensureAddressString)(I));
      JSON.stringify(S) !== JSON.stringify(this._addresses) && (this._addresses = S, this.emit("accountsChanged", this._addresses), this._storage.setItem(c.LOCAL_STORAGE_ADDRESSES_KEY, S.join(" ")));
    }
    _sendRequestAsync(u) {
      return new Promise((R, S) => {
        try {
          const I = this._handleSynchronousMethods(u);
          if (I !== void 0)
            return R({
              jsonrpc: "2.0",
              id: u.id,
              result: I
            });
          const T = this._handleAsynchronousFilterMethods(u);
          if (T !== void 0) {
            T.then((D) => R(Object.assign(Object.assign({}, D), { id: u.id }))).catch((D) => S(D));
            return;
          }
          const q = this._handleSubscriptionMethods(u);
          if (q !== void 0) {
            q.then((D) => R({
              jsonrpc: "2.0",
              id: u.id,
              result: D.result
            })).catch((D) => S(D));
            return;
          }
        } catch (I) {
          return S(I);
        }
        this._handleAsynchronousMethods(u).then((I) => I && R(Object.assign(Object.assign({}, I), { id: u.id }))).catch((I) => S(I));
      });
    }
    _sendMultipleRequestsAsync(u) {
      return Promise.all(u.map((R) => this._sendRequestAsync(R)));
    }
    _handleSynchronousMethods(u) {
      const { method: R } = u, S = u.params || [];
      switch (R) {
        case "eth_accounts":
          return this._eth_accounts();
        case "eth_coinbase":
          return this._eth_coinbase();
        case "eth_uninstallFilter":
          return this._eth_uninstallFilter(S);
        case "net_version":
          return this._net_version();
        case "eth_chainId":
          return this._eth_chainId();
        default:
          return;
      }
    }
    async _handleAsynchronousMethods(u) {
      const { method: R } = u, S = u.params || [];
      switch (R) {
        case "eth_requestAccounts":
          return this._eth_requestAccounts();
        case "eth_sign":
          return this._eth_sign(S);
        case "eth_ecRecover":
          return this._eth_ecRecover(S);
        case "personal_sign":
          return this._personal_sign(S);
        case "personal_ecRecover":
          return this._personal_ecRecover(S);
        case "eth_signTransaction":
          return this._eth_signTransaction(S);
        case "eth_sendRawTransaction":
          return this._eth_sendRawTransaction(S);
        case "eth_sendTransaction":
          return this._eth_sendTransaction(S);
        case "eth_signTypedData_v1":
          return this._eth_signTypedData_v1(S);
        case "eth_signTypedData_v2":
          return this._throwUnsupportedMethodError();
        case "eth_signTypedData_v3":
          return this._eth_signTypedData_v3(S);
        case "eth_signTypedData_v4":
        case "eth_signTypedData":
          return this._eth_signTypedData_v4(S);
        case "cbWallet_arbitrary":
          return this._cbwallet_arbitrary(S);
        case "wallet_addEthereumChain":
          return this._wallet_addEthereumChain(S);
        case "wallet_switchEthereumChain":
          return this._wallet_switchEthereumChain(S);
        case "wallet_watchAsset":
          return this._wallet_watchAsset(S);
      }
      return (await this.initializeRelay()).makeEthereumJSONRPCRequest(u, this.jsonRpcUrl).catch((T) => {
        var q;
        throw (T.code === t.standardErrorCodes.rpc.methodNotFound || T.code === t.standardErrorCodes.rpc.methodNotSupported) && ((q = this.diagnostic) === null || q === void 0 || q.log(p.EVENTS.METHOD_NOT_IMPLEMENTED, {
          method: u.method,
          sessionIdHash: this._relay ? a.Session.hash(this._relay.session.id) : void 0
        })), T;
      });
    }
    _handleAsynchronousFilterMethods(u) {
      const { method: R } = u, S = u.params || [];
      switch (R) {
        case "eth_newFilter":
          return this._eth_newFilter(S);
        case "eth_newBlockFilter":
          return this._eth_newBlockFilter();
        case "eth_newPendingTransactionFilter":
          return this._eth_newPendingTransactionFilter();
        case "eth_getFilterChanges":
          return this._eth_getFilterChanges(S);
        case "eth_getFilterLogs":
          return this._eth_getFilterLogs(S);
      }
    }
    _handleSubscriptionMethods(u) {
      switch (u.method) {
        case "eth_subscribe":
        case "eth_unsubscribe":
          return this._subscriptionManager.handleRequest(u);
      }
    }
    _isKnownAddress(u) {
      try {
        const R = (0, g.ensureAddressString)(u);
        return this._addresses.map((I) => (0, g.ensureAddressString)(I)).includes(R);
      } catch {
      }
      return !1;
    }
    _ensureKnownAddress(u) {
      var R;
      if (!this._isKnownAddress(u))
        throw (R = this.diagnostic) === null || R === void 0 || R.log(p.EVENTS.UNKNOWN_ADDRESS_ENCOUNTERED), new Error("Unknown Ethereum address");
    }
    _prepareTransactionParams(u) {
      const R = u.from ? (0, g.ensureAddressString)(u.from) : this.selectedAddress;
      if (!R)
        throw new Error("Ethereum address is unavailable");
      this._ensureKnownAddress(R);
      const S = u.to ? (0, g.ensureAddressString)(u.to) : null, I = u.value != null ? (0, g.ensureBN)(u.value) : new r.default(0), T = u.data ? (0, g.ensureBuffer)(u.data) : Buffer.alloc(0), q = u.nonce != null ? (0, g.ensureIntNumber)(u.nonce) : null, D = u.gasPrice != null ? (0, g.ensureBN)(u.gasPrice) : null, H = u.maxFeePerGas != null ? (0, g.ensureBN)(u.maxFeePerGas) : null, G = u.maxPriorityFeePerGas != null ? (0, g.ensureBN)(u.maxPriorityFeePerGas) : null, X = u.gas != null ? (0, g.ensureBN)(u.gas) : null, Y = u.chainId ? (0, g.ensureIntNumber)(u.chainId) : this.getChainId();
      return {
        fromAddress: R,
        toAddress: S,
        weiValue: I,
        data: T,
        nonce: q,
        gasPriceInWei: D,
        maxFeePerGas: H,
        maxPriorityFeePerGas: G,
        gasLimit: X,
        chainId: Y
      };
    }
    _isAuthorized() {
      return this._addresses.length > 0;
    }
    _requireAuthorization() {
      if (!this._isAuthorized())
        throw t.standardErrors.provider.unauthorized({});
    }
    _throwUnsupportedMethodError() {
      throw t.standardErrors.provider.unsupportedMethod({});
    }
    async _signEthereumMessage(u, R, S, I) {
      this._ensureKnownAddress(R);
      try {
        const q = await (await this.initializeRelay()).signEthereumMessage(u, R, S, I).promise;
        if ((0, d.isErrorResponse)(q))
          throw new Error(q.errorMessage);
        return { jsonrpc: "2.0", id: 0, result: q.result };
      } catch (T) {
        throw typeof T.message == "string" && T.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied message signature") : T;
      }
    }
    async _ethereumAddressFromSignedMessage(u, R, S) {
      const T = await (await this.initializeRelay()).ethereumAddressFromSignedMessage(u, R, S).promise;
      if ((0, d.isErrorResponse)(T))
        throw new Error(T.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: T.result };
    }
    _eth_accounts() {
      return [...this._addresses];
    }
    _eth_coinbase() {
      return this.selectedAddress || null;
    }
    _net_version() {
      return this.getChainId().toString(10);
    }
    _eth_chainId() {
      return (0, g.hexStringFromIntNumber)(this.getChainId());
    }
    getChainId() {
      const u = this._storage.getItem(s);
      if (!u)
        return (0, g.ensureIntNumber)(this._chainIdFromOpts);
      const R = parseInt(u, 10);
      return (0, g.ensureIntNumber)(R);
    }
    async _eth_requestAccounts() {
      var u;
      if ((u = this.diagnostic) === null || u === void 0 || u.log(p.EVENTS.ETH_ACCOUNTS_STATE, {
        method: "provider::_eth_requestAccounts",
        addresses_length: this._addresses.length,
        sessionIdHash: this._relay ? a.Session.hash(this._relay.session.id) : void 0
      }), this._isAuthorized())
        return Promise.resolve({
          jsonrpc: "2.0",
          id: 0,
          result: this._addresses
        });
      let R;
      try {
        if (R = await (await this.initializeRelay()).requestEthereumAccounts().promise, (0, d.isErrorResponse)(R))
          throw new Error(R.errorMessage);
      } catch (S) {
        throw typeof S.message == "string" && S.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied account authorization") : S;
      }
      if (!R.result)
        throw new Error("accounts received is empty");
      return this._setAddresses(R.result), this.isCoinbaseBrowser || await this.switchEthereumChain(this.getChainId()), { jsonrpc: "2.0", id: 0, result: this._addresses };
    }
    _eth_sign(u) {
      this._requireAuthorization();
      const R = (0, g.ensureAddressString)(u[0]), S = (0, g.ensureBuffer)(u[1]);
      return this._signEthereumMessage(S, R, !1);
    }
    _eth_ecRecover(u) {
      const R = (0, g.ensureBuffer)(u[0]), S = (0, g.ensureBuffer)(u[1]);
      return this._ethereumAddressFromSignedMessage(R, S, !1);
    }
    _personal_sign(u) {
      this._requireAuthorization();
      const R = (0, g.ensureBuffer)(u[0]), S = (0, g.ensureAddressString)(u[1]);
      return this._signEthereumMessage(R, S, !0);
    }
    _personal_ecRecover(u) {
      const R = (0, g.ensureBuffer)(u[0]), S = (0, g.ensureBuffer)(u[1]);
      return this._ethereumAddressFromSignedMessage(R, S, !0);
    }
    async _eth_signTransaction(u) {
      this._requireAuthorization();
      const R = this._prepareTransactionParams(u[0] || {});
      try {
        const I = await (await this.initializeRelay()).signEthereumTransaction(R).promise;
        if ((0, d.isErrorResponse)(I))
          throw new Error(I.errorMessage);
        return { jsonrpc: "2.0", id: 0, result: I.result };
      } catch (S) {
        throw typeof S.message == "string" && S.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied transaction signature") : S;
      }
    }
    async _eth_sendRawTransaction(u) {
      const R = (0, g.ensureBuffer)(u[0]), I = await (await this.initializeRelay()).submitEthereumTransaction(R, this.getChainId()).promise;
      if ((0, d.isErrorResponse)(I))
        throw new Error(I.errorMessage);
      return { jsonrpc: "2.0", id: 0, result: I.result };
    }
    async _eth_sendTransaction(u) {
      this._requireAuthorization();
      const R = this._prepareTransactionParams(u[0] || {});
      try {
        const I = await (await this.initializeRelay()).signAndSubmitEthereumTransaction(R).promise;
        if ((0, d.isErrorResponse)(I))
          throw new Error(I.errorMessage);
        return { jsonrpc: "2.0", id: 0, result: I.result };
      } catch (S) {
        throw typeof S.message == "string" && S.message.match(/(denied|rejected)/i) ? t.standardErrors.provider.userRejectedRequest("User denied transaction signature") : S;
      }
    }
    async _eth_signTypedData_v1(u) {
      this._requireAuthorization();
      const R = (0, g.ensureParsedJSONObject)(u[0]), S = (0, g.ensureAddressString)(u[1]);
      this._ensureKnownAddress(S);
      const I = m.default.hashForSignTypedDataLegacy({ data: R }), T = JSON.stringify(R, null, 2);
      return this._signEthereumMessage(I, S, !1, T);
    }
    async _eth_signTypedData_v3(u) {
      this._requireAuthorization();
      const R = (0, g.ensureAddressString)(u[0]), S = (0, g.ensureParsedJSONObject)(u[1]);
      this._ensureKnownAddress(R);
      const I = m.default.hashForSignTypedData_v3({ data: S }), T = JSON.stringify(S, null, 2);
      return this._signEthereumMessage(I, R, !1, T);
    }
    async _eth_signTypedData_v4(u) {
      this._requireAuthorization();
      const R = (0, g.ensureAddressString)(u[0]), S = (0, g.ensureParsedJSONObject)(u[1]);
      this._ensureKnownAddress(R);
      const I = m.default.hashForSignTypedData_v4({ data: S }), T = JSON.stringify(S, null, 2);
      return this._signEthereumMessage(I, R, !1, T);
    }
    /** @deprecated */
    async _cbwallet_arbitrary(u) {
      const R = u[0], S = u[1];
      if (typeof S != "string")
        throw new Error("parameter must be a string");
      if (typeof R != "object" || R === null)
        throw new Error("parameter must be an object");
      return { jsonrpc: "2.0", id: 0, result: await this.genericRequest(R, S) };
    }
    async _wallet_addEthereumChain(u) {
      var R, S, I, T;
      const q = u[0];
      if (((R = q.rpcUrls) === null || R === void 0 ? void 0 : R.length) === 0)
        return {
          jsonrpc: "2.0",
          id: 0,
          error: { code: 2, message: "please pass in at least 1 rpcUrl" }
        };
      if (!q.chainName || q.chainName.trim() === "")
        throw t.standardErrors.rpc.invalidParams("chainName is a required field");
      if (!q.nativeCurrency)
        throw t.standardErrors.rpc.invalidParams("nativeCurrency is a required field");
      const D = parseInt(q.chainId, 16);
      return await this.addEthereumChain(D, (S = q.rpcUrls) !== null && S !== void 0 ? S : [], (I = q.blockExplorerUrls) !== null && I !== void 0 ? I : [], q.chainName, (T = q.iconUrls) !== null && T !== void 0 ? T : [], q.nativeCurrency) ? { jsonrpc: "2.0", id: 0, result: null } : {
        jsonrpc: "2.0",
        id: 0,
        error: { code: 2, message: "unable to add ethereum chain" }
      };
    }
    async _wallet_switchEthereumChain(u) {
      const R = u[0];
      return await this.switchEthereumChain(parseInt(R.chainId, 16)), { jsonrpc: "2.0", id: 0, result: null };
    }
    async _wallet_watchAsset(u) {
      const R = Array.isArray(u) ? u[0] : u;
      if (!R.type)
        throw t.standardErrors.rpc.invalidParams("Type is required");
      if ((R == null ? void 0 : R.type) !== "ERC20")
        throw t.standardErrors.rpc.invalidParams(`Asset of type '${R.type}' is not supported`);
      if (!(R != null && R.options))
        throw t.standardErrors.rpc.invalidParams("Options are required");
      if (!(R != null && R.options.address))
        throw t.standardErrors.rpc.invalidParams("Address is required");
      const S = this.getChainId(), { address: I, symbol: T, image: q, decimals: D } = R.options;
      return { jsonrpc: "2.0", id: 0, result: await this.watchAsset(R.type, I, T, D, q, S) };
    }
    _eth_uninstallFilter(u) {
      const R = (0, g.ensureHexString)(u[0]);
      return this._filterPolyfill.uninstallFilter(R);
    }
    async _eth_newFilter(u) {
      const R = u[0];
      return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newFilter(R) };
    }
    async _eth_newBlockFilter() {
      return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newBlockFilter() };
    }
    async _eth_newPendingTransactionFilter() {
      return { jsonrpc: "2.0", id: 0, result: await this._filterPolyfill.newPendingTransactionFilter() };
    }
    _eth_getFilterChanges(u) {
      const R = (0, g.ensureHexString)(u[0]);
      return this._filterPolyfill.getFilterChanges(R);
    }
    _eth_getFilterLogs(u) {
      const R = (0, g.ensureHexString)(u[0]);
      return this._filterPolyfill.getFilterLogs(R);
    }
    initializeRelay() {
      return this._relay ? Promise.resolve(this._relay) : this._relayProvider().then((u) => (u.setAccountsCallback((R, S) => this._setAddresses(R, S)), u.setChainCallback((R, S) => {
        this.updateProviderInfo(S, parseInt(R, 10));
      }), u.setDappDefaultChainCallback(this._chainIdFromOpts), this._relay = u, u));
    }
  };
  return Dt.CoinbaseWalletProvider = b, Dt;
}
var jr = {}, $c;
function Df() {
  if ($c) return jr;
  $c = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.RelayEventManager = void 0;
  const e = /* @__PURE__ */ tt();
  let r = class {
    constructor() {
      this._nextRequestId = 0, this.callbacks = /* @__PURE__ */ new Map();
    }
    makeRequestId() {
      this._nextRequestId = (this._nextRequestId + 1) % 2147483647;
      const t = this._nextRequestId, g = (0, e.prepend0x)(t.toString(16));
      return this.callbacks.get(g) && this.callbacks.delete(g), t;
    }
  };
  return jr.RelayEventManager = r, jr;
}
var Uc;
function Hc() {
  if (Uc) return tr;
  Uc = 1, Object.defineProperty(tr, "__esModule", { value: !0 }), tr.CoinbaseWalletSDK = void 0;
  const e = /* @__PURE__ */ Fl(), r = /* @__PURE__ */ Dl(), n = /* @__PURE__ */ tt(), t = /* @__PURE__ */ Ul(), g = /* @__PURE__ */ Ns(), i = /* @__PURE__ */ el(), c = /* @__PURE__ */ Xc(), a = /* @__PURE__ */ Df(), d = /* @__PURE__ */ Qc(), m = /* @__PURE__ */ Yc(), p = /* @__PURE__ */ Ds();
  let o = class Tl {
    /**
     * Constructor
     * @param options Coinbase Wallet SDK constructor options
     */
    constructor(s) {
      var f, b, y;
      this._appName = "", this._appLogoUrl = null, this._relay = null, this._relayEventManager = null;
      const u = s.linkAPIUrl || r.LINK_API_URL;
      typeof s.overrideIsMetaMask > "u" ? this._overrideIsMetaMask = !1 : this._overrideIsMetaMask = s.overrideIsMetaMask, this._overrideIsCoinbaseWallet = (f = s.overrideIsCoinbaseWallet) !== null && f !== void 0 ? f : !0, this._overrideIsCoinbaseBrowser = (b = s.overrideIsCoinbaseBrowser) !== null && b !== void 0 ? b : !1, this._diagnosticLogger = s.diagnosticLogger, this._reloadOnDisconnect = (y = s.reloadOnDisconnect) !== null && y !== void 0 ? y : !0;
      const R = new URL(u), S = `${R.protocol}//${R.host}`;
      if (this._storage = new t.ScopedLocalStorage(`-walletlink:${S}`), this._storage.setItem("version", Tl.VERSION), this.walletExtension || this.coinbaseBrowser)
        return;
      this._relayEventManager = new a.RelayEventManager();
      const I = (0, n.isMobileWeb)(), T = s.uiConstructor || ((D) => I ? new c.MobileRelayUI(D) : new d.WalletLinkRelayUI(D)), q = {
        linkAPIUrl: u,
        version: p.LIB_VERSION,
        darkMode: !!s.darkMode,
        headlessMode: !!s.headlessMode,
        uiConstructor: T,
        storage: this._storage,
        relayEventManager: this._relayEventManager,
        diagnosticLogger: this._diagnosticLogger,
        reloadOnDisconnect: this._reloadOnDisconnect,
        enableMobileWalletLink: s.enableMobileWalletLink
      };
      this._relay = I ? new i.MobileRelay(q) : new m.WalletLinkRelay(q), this.setAppInfo(s.appName, s.appLogoUrl), !s.headlessMode && this._relay.attachUI();
    }
    /**
     * Create a Web3 Provider object
     * @param jsonRpcUrl Ethereum JSON RPC URL (Default: "")
     * @param chainId Ethereum Chain ID (Default: 1)
     * @returns A Web3 Provider
     */
    makeWeb3Provider(s = "", f = 1) {
      const b = this.walletExtension;
      if (b)
        return this.isCipherProvider(b) || b.setProviderInfo(s, f), this._reloadOnDisconnect === !1 && typeof b.disableReloadOnDisconnect == "function" && b.disableReloadOnDisconnect(), b;
      const y = this.coinbaseBrowser;
      if (y)
        return y;
      const u = this._relay;
      if (!u || !this._relayEventManager || !this._storage)
        throw new Error("Relay not initialized, should never happen");
      return s || u.setConnectDisabled(!0), new g.CoinbaseWalletProvider({
        relayProvider: () => Promise.resolve(u),
        relayEventManager: this._relayEventManager,
        storage: this._storage,
        jsonRpcUrl: s,
        chainId: f,
        qrUrl: this.getQrUrl(),
        diagnosticLogger: this._diagnosticLogger,
        overrideIsMetaMask: this._overrideIsMetaMask,
        overrideIsCoinbaseWallet: this._overrideIsCoinbaseWallet,
        overrideIsCoinbaseBrowser: this._overrideIsCoinbaseBrowser
      });
    }
    /**
     * Set application information
     * @param appName Application name
     * @param appLogoUrl Application logo image URL
     */
    setAppInfo(s, f) {
      var b;
      this._appName = s || "DApp", this._appLogoUrl = f || (0, n.getFavicon)();
      const y = this.walletExtension;
      y ? this.isCipherProvider(y) || y.setAppInfo(this._appName, this._appLogoUrl) : (b = this._relay) === null || b === void 0 || b.setAppInfo(this._appName, this._appLogoUrl);
    }
    /**
     * Disconnect. After disconnecting, this will reload the web page to ensure
     * all potential stale state is cleared.
     */
    disconnect() {
      var s;
      const f = this === null || this === void 0 ? void 0 : this.walletExtension;
      f ? f.close() : (s = this._relay) === null || s === void 0 || s.resetAndReload();
    }
    /**
     * Return QR URL for mobile wallet connection, will return null if extension is installed
     */
    getQrUrl() {
      var s, f;
      return (f = (s = this._relay) === null || s === void 0 ? void 0 : s.getQRCodeUrl()) !== null && f !== void 0 ? f : null;
    }
    /**
     * Official Coinbase Wallet logo for developers to use on their frontend
     * @param type Type of wallet logo: "standard" | "circle" | "text" | "textWithLogo" | "textLight" | "textWithLogoLight"
     * @param width Width of the logo (Optional)
     * @returns SVG Data URI
     */
    getCoinbaseWalletLogo(s, f = 240) {
      return (0, e.walletLogo)(s, f);
    }
    get walletExtension() {
      var s;
      return (s = window.coinbaseWalletExtension) !== null && s !== void 0 ? s : window.walletLinkExtension;
    }
    get coinbaseBrowser() {
      var s, f;
      try {
        const b = (s = window.ethereum) !== null && s !== void 0 ? s : (f = window.top) === null || f === void 0 ? void 0 : f.ethereum;
        return b && "isCoinbaseBrowser" in b && b.isCoinbaseBrowser ? b : void 0;
      } catch {
        return;
      }
    }
    isCipherProvider(s) {
      return typeof s.isCipher == "boolean" && s.isCipher;
    }
  };
  return tr.CoinbaseWalletSDK = o, o.VERSION = p.LIB_VERSION, tr;
}
var Wc;
function qf() {
  return Wc || (Wc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CoinbaseWalletProvider = e.CoinbaseWalletSDK = void 0;
    const r = /* @__PURE__ */ Hc(), n = /* @__PURE__ */ Ns();
    var t = /* @__PURE__ */ Hc();
    Object.defineProperty(e, "CoinbaseWalletSDK", { enumerable: !0, get: function() {
      return t.CoinbaseWalletSDK;
    } });
    var g = /* @__PURE__ */ Ns();
    Object.defineProperty(e, "CoinbaseWalletProvider", { enumerable: !0, get: function() {
      return g.CoinbaseWalletProvider;
    } }), e.default = r.CoinbaseWalletSDK, typeof window < "u" && (window.CoinbaseWalletSDK = r.CoinbaseWalletSDK, window.CoinbaseWalletProvider = n.CoinbaseWalletProvider, window.WalletLink = r.CoinbaseWalletSDK, window.WalletLinkProvider = n.CoinbaseWalletProvider);
  }(xn)), xn;
}
var jf = /* @__PURE__ */ qf();
const $f = /* @__PURE__ */ Nl(jf), h0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $f
}, Symbol.toStringTag, { value: "Module" }));
export {
  h0 as i
};
